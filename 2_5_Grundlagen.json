{
    "questions": [
        {
            "question": "Ein Junior-Administrator soll ein Verzeichnis aller `.log`-Dateien auf Laufwerk `D:` erstellen und in der Datei `audit.txt` speichern. Er f√ºhrt den Befehl `dir d:\\*.log > audit.txt` aus. Am n√§chsten Tag soll er die neuen Log-Dateien an die bestehende `audit.txt` anh√§ngen. Welchen Befehl muss er verwenden, um die alten Eintr√§ge nicht zu √ºberschreiben? üìú",
            "options": [
                "dir d:\\*.log > audit.txt",
                "dir d:\\*.log | audit.txt",
                "dir d:\\*.log >> audit.txt",
                "dir d:\\*.log + audit.txt"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Operator `>>` wird als Anh√§ngesymbol verwendet. Er leitet die Ausgabe eines Befehls in eine Datei um und f√ºgt sie am Ende der Datei an, ohne den vorhandenen Inhalt zu l√∂schen. \n- **`>` (Umleitungssymbol):** W√ºrde die `audit.txt` komplett √ºberschreiben. ‚ùå\n- **`|` (Pipe):** Verkettet Befehle, indem es die Ausgabe des ersten Befehls als Eingabe f√ºr den zweiten verwendet, was hier nicht zielf√ºhrend ist. ‚ùå\n- **`+` (Zusammenf√ºhrungssymbol):** Wird prim√§r beim `copy`-Befehl verwendet, um Dateien zu kombinieren, nicht zur Umleitung von Befehlsausgaben. ‚ùå\nüí° Dieses Wissen ist entscheidend f√ºr das Logging und die Protokollierung in Skripten.",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Sie m√∂chten einen neuen 64 GB USB-Stick f√ºr die Windows-Installation vorbereiten. Der Stick muss eine einzelne, aktive prim√§re Partition enthalten, die mit NTFS formatiert ist. Welche `diskpart`-Befehlssequenz ist korrekt und vollst√§ndig? üõ†Ô∏è",
            "options": [
                "select disk 1, create partition primary, active, format fs=ntfs, assign",
                "list disk, select disk 1, clean, create partition primary, active, format fs=ntfs quick, assign",
                "list disk, select disk 1, clean, create partition, format, assign letter=e",
                "select disk 1, format fs=ntfs quick, active, assign"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die korrekte Reihenfolge ist entscheidend. Zuerst muss der Datentr√§ger mit `list disk` identifiziert und mit `select disk X` ausgew√§hlt werden. `clean` entfernt alle vorhandenen Partitionierungsinformationen. Danach wird mit `create partition primary` eine prim√§re Partition erstellt, mit `active` als bootf√§hig markiert, mit `format fs=ntfs quick` schnell formatiert und schlie√ülich mit `assign` ein Laufwerksbuchstabe zugewiesen. \n- **Option A:** Vergisst `list disk` und `clean`, was zu Fehlern f√ºhren kann, wenn der Stick nicht leer ist. ‚ùå\n- **Option C:** Ist zu unpr√§zise (`create partition` ohne 'primary', `format` ohne Dateisystem). ‚ùå\n- **Option D:** Versucht zu formatieren, bevor eine Partition erstellt wurde. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Ein Server soll w√∂chentlich einen Integrit√§tscheck der Systemfestplatte (C:) durchf√ºhren und eventuelle Fehler automatisch beheben. Der Report soll nicht am Bildschirm angezeigt, sondern in eine Log-Datei geschrieben werden. Welcher Befehl ist daf√ºr am besten geeignet? ‚öôÔ∏è",
            "options": [
                "chkdsk c: /f > nul",
                "chkdsk c: /r",
                "format c: /q",
                "diskpart detail disk > log.txt"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Der Befehl `chkdsk c: /f` pr√ºft das Laufwerk C: auf Fehler und behebt (`/f`) diese. Die Umleitung `> nul` unterdr√ºckt die Ausgabe auf der Konsole, was f√ºr automatisierte Skripts ideal ist, um den Bildschirm sauber zu halten. \n- **`/r`:** Sucht zus√§tzlich nach fehlerhaften Sektoren und stellt lesbare Informationen wieder her, was deutlich l√§nger dauert und f√ºr einen schnellen Check oft nicht n√∂tig ist. ‚ùå\n- **`format c:`:** W√ºrde die Systemfestplatte formatieren und das Betriebssystem l√∂schen.  –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞! ‚ùå\n- **`diskpart detail disk`:** Liefert nur Informationen √ºber den Datentr√§ger, f√ºhrt aber keine Fehlerpr√ºfung oder -korrektur durch. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Wahr oder Falsch: Der Befehl `clean` in `diskpart` ist eine sichere Methode, um sensible Daten unwiederbringlich zu l√∂schen, da er alle Sektoren der Festplatte √ºberschreibt. üîí",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. Der `clean`-Befehl l√∂scht lediglich die MBR- oder GPT-Partitionierungsinformationen vom Datentr√§ger. Die eigentlichen Daten bleiben physisch auf der Festplatte erhalten und k√∂nnen mit Datenrettungstools oft wiederhergestellt werden. Nur der Befehl `clean all` √ºberschreibt jeden Sektor mit Nullen und sorgt f√ºr ein sicheres L√∂schen (‚ÄûSecure Erase‚Äú). üí° Dies ist ein kritischer Unterschied im Kontext der Datensicherheit.",
            "difficulty": "experte",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "Vergleichen Sie die Befehle `del` und `rd`. Welches Szenario beschreibt den korrekten Einsatz der beiden Befehle? üóëÔ∏è",
            "options": [
                "`del` l√∂scht Verzeichnisse und `rd` l√∂scht Dateien.",
                "Beide k√∂nnen Dateien und leere Verzeichnisse l√∂schen.",
                "`del` l√∂scht eine oder mehrere Dateien, w√§hrend `rd` ein leeres Verzeichnis l√∂scht.",
                "`rd` l√∂scht ein Verzeichnis inklusive aller Unterverzeichnisse und Dateien, `del` nur einzelne Dateien."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die Trennung ist klar definiert: `del` (delete) ist f√ºr das L√∂schen von Dateien zust√§ndig. `rd` (remove directory) ist f√ºr das Entfernen von Verzeichnissen zust√§ndig. Standardm√§√üig kann `rd` nur leere Verzeichnisse l√∂schen. Um ein Verzeichnis samt Inhalt zu l√∂schen, ben√∂tigt man den Schalter `/s` (z.B. `rd /s meinverzeichnis`).\n- **Option A:** Ist genau umgekehrt. ‚ùå\n- **Option B:** `del` kann keine Verzeichnisse l√∂schen. ‚ùå\n- **Option D:** `rd` l√∂scht ohne den Schalter `/s` eben nicht den Inhalt mit. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie haben einen Ordner mit hunderten von Bilddateien (JPG) und Textdokumenten (TXT). Sie m√∂chten alle JPG-Dateien in einen Unterordner namens `Bilder` verschieben. Welcher Befehl ist am effizientesten? üìÇ",
            "options": [
                "copy *.jpg Bilder\\",
                "move *.jpg Bilder",
                "xcopy *.jpg Bilder\\ /s",
                "ren *.jpg *.bak"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `move`-Befehl ist f√ºr das Verschieben von Dateien und Verzeichnissen konzipiert. Er ist effizienter als `copy` gefolgt von `del`, da die Dateidaten nicht physisch kopiert, sondern nur der Verzeichniseintrag im Dateisystem ge√§ndert wird (solange es auf demselben Volume geschieht).\n- **`copy`:** W√ºrde die Dateien nur kopieren, die Originale blieben erhalten. ‚ùå\n- **`xcopy`:** Ist f√ºr das Kopieren von Verzeichnisstrukturen gedacht und hier unn√∂tig komplex. ‚ùå\n- **`ren`:** W√ºrde die Dateien nur umbenennen, nicht verschieben. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Ein Skript soll die Ausgabe eines langen Befehls erzeugen, aber der Benutzer soll diese Ausgabe nicht auf dem Bildschirm sehen, um die Konsole √ºbersichtlich zu halten. Welcher Befehlsteil erreicht dies? üôà",
            "options": [
                "| more",
                "> nul",
                "/p",
                "| clip"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die Umleitung `> nul` sendet die Standardausgabe (STDOUT) eines Befehls an das `nul`-Ger√§t, welches ein virtuelles Ger√§t ist, das alle empfangenen Daten verwirft. Dadurch wird die Ausgabe effektiv unterdr√ºckt. \n- **`| more`:** H√§lt die Ausgabe seitenweise an, zeigt sie aber an. ‚ùå\n- **`/p`:** Ist ein Schalter vieler Befehle (wie `dir`), um die Ausgabe zu pausieren, zeigt sie aber ebenfalls an. ‚ùå\n- **`| clip`:** Leitet die Ausgabe in die Zwischenablage um, nicht ins Nichts. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Welchen entscheidenden Vorteil bietet `PowerShell` gegen√ºber der klassischen `CMD.EXE`, der in den Unterlagen angedeutet wird? üöÄ",
            "options": [
                "PowerShell ist abw√§rtskompatibler zu MS-DOS.",
                "PowerShell-Befehle sind immer k√ºrzer und einfacher zu merken.",
                "PowerShell arbeitet mit Objekten statt mit reinem Text, was eine m√§chtigere Verarbeitung und Skripterstellung erm√∂glicht.",
                "CMD.EXE kann keine Netzwerkoperationen durchf√ºhren, PowerShell schon."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der fundamentale Unterschied und gr√∂√üte Vorteil von PowerShell ist die objektorientierte Pipeline. W√§hrend CMD Textzeilen von einem Befehl zum n√§chsten weitergibt, reicht PowerShell strukturierte .NET-Objekte weiter. Dies erlaubt eine wesentlich komplexere und zuverl√§ssigere Verarbeitung von Daten in Skripten. CMD kann durchaus Netzwerkbefehle wie `ping` oder `ipconfig` ausf√ºhren. PowerShell ist eine modernere, aber nicht zwangsl√§ufig abw√§rtskompatiblere oder immer k√ºrzere Alternative.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie befinden sich im Verzeichnis `C:\\Users\\Admin\\Documents`. Welcher einzelne Befehl bringt Sie direkt zum Wurzelverzeichnis von Laufwerk C:? üå≥",
            "options": [
                "cd ..",
                "cd /",
                "cd \\",
                "cd c:"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `cd \\` (change directory mit Backslash) wechselt immer in das Wurzelverzeichnis des aktuellen Laufwerks. \n- **`cd ..`:** Wechselt nur eine Ebene nach oben (zu `C:\\Users\\Admin`). ‚ùå\n- **`cd /`:** Der Slash `/` wird in CMD prim√§r f√ºr Schalter/Optionen verwendet, nicht f√ºr die Pfadnavigation wie in Linux. ‚ùå\n- **`cd c:`:** Zeigt nur den aktuellen Pfad auf Laufwerk C: an, wechselt aber nicht das Verzeichnis, wenn man sich bereits auf C: befindet. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Ein Kollege hat mit `diskpart` eine Partition gel√∂scht, aber der Speicherplatz wurde nicht wie erwartet dem benachbarten Volume hinzugef√ºgt. Welcher `diskpart`-Befehl ist notwendig, um den freien Speicherplatz einer vorhandenen Partition zuzuweisen? ‚ûï",
            "options": [
                "assign",
                "create",
                "merge",
                "extend"
            ],
            "correct": 3,
            "explain": "**Begr√ºndung:** Der `extend`-Befehl wird in `diskpart` verwendet, um ein Volume oder eine Partition in den n√§chsten zusammenh√§ngenden, nicht zugeordneten Speicherplatz auf demselben Datentr√§ger zu erweitern. Man muss zuerst das Volume ausw√§hlen (`select volume X`) und kann es dann mit `extend` vergr√∂√üern. \n- **`assign`:** Weist nur einen Laufwerksbuchstaben zu. ‚ùå\n- **`create`:** Erstellt eine neue Partition im freien Speicher. ‚ùå\n- **`merge`:** F√ºhrt untergeordnete virtuelle Datentr√§ger zusammen, was hier nicht relevant ist. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Welche Funktion haben die Platzhalter `*` und `?` in der CMD? W√§hlen Sie die pr√§ziseste Definition. üß©",
            "options": [
                "`*` steht f√ºr ein beliebiges Zeichen, `?` f√ºr eine beliebige Zeichenkette.",
                "`*` steht f√ºr eine beliebige Zeichenkette (auch keine), `?` steht f√ºr genau ein beliebiges Zeichen.",
                "`*` steht f√ºr Zahlen, `?` f√ºr Buchstaben.",
                "Beide stehen f√ºr eine beliebige Anzahl von beliebigen Zeichen."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Dies ist eine fundamentale Regel der Wildcard-Nutzung. Der Stern (`*`) ist der 'gierige' Platzhalter f√ºr null oder mehr beliebige Zeichen. Das Fragezeichen (`?`) ist der pr√§zise Platzhalter f√ºr exakt ein beliebiges Zeichen. Ein Beispiel: `datei?.txt` findet `datei1.txt` und `dateiA.txt`, aber nicht `datei10.txt` oder `datei.txt`. `datei*.txt` w√ºrde sie alle finden.",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie m√∂chten eine Textdatei namens `setup.txt` direkt in der Kommandozeile erstellen und den Text 'Installation_Start' hineinschreiben. Welcher Befehl und welche Aktion beenden den Schreibvorgang korrekt? ‚úçÔ∏è",
            "options": [
                "type > setup.txt, dann 'Installation_Start' tippen und mit ESC beenden.",
                "md setup.txt, dann 'Installation_Start' tippen und mit Enter beenden.",
                "copy con setup.txt, dann 'Installation_Start' tippen und mit Strg+Z gefolgt von Enter beenden.",
                "edit setup.txt, dann 'Installation_Start' tippen und mit F3 speichern."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `copy con` (copy from console) leitet die Konsoleneingabe in eine Datei um. Nach der Eingabe des Textes wird der Vorgang durch das Senden des 'End-of-File'-Zeichens (EOF) abgeschlossen, was in Windows durch die Tastenkombination `Strg+Z` und anschlie√üendes Dr√ºcken von `Enter` geschieht. \n- **Option A, B, D:** Sind syntaktisch falsche oder unpassende Befehle f√ºr diesen Zweck. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datei-Befehle"
        },
        {
            "question": "Sie geben den Befehl `help | more` ein. Was ist die genaue Funktion des Pipe-Symbols `|` in diesem Kontext? ‚õìÔ∏è",
            "options": [
                "Es leitet die Hilfe-Ausgabe in eine Datei namens 'more' um.",
                "Es startet den 'more'-Befehl parallel zum 'help'-Befehl.",
                "Es sorgt daf√ºr, dass die sehr lange Ausgabe des 'help'-Befehls seitenweise durch den 'more'-Befehl angezeigt wird.",
                "Es f√ºgt den Inhalt der Datei 'more' an die Hilfe-Ausgabe an."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Das Pipe-Symbol `|` ist ein Verkettungssymbol. Es nimmt die Standardausgabe (STDOUT) des Befehls links von der Pipe und verwendet sie als Standardeingabe (STDIN) f√ºr den Befehl rechts von der Pipe. Hier wird die komplette Liste aller Befehle von `help` an `more` weitergeleitet, welcher die Eingabe dann seitenweise anzeigt und auf eine Benutzereingabe wartet, um zur n√§chsten Seite zu bl√§ttern.",
            "difficulty": "fortgeschritten",
            "category": "Befehlssyntax"
        },
        {
            "question": "Ein Techniker m√∂chte die Volumebezeichnung eines USB-Sticks (Laufwerk E:) von 'TRANSCEND' auf 'BACKUP' √§ndern. Welcher Befehl ist daf√ºr direkt und ohne weitere Umwege vorgesehen? üè∑Ô∏è",
            "options": [
                "ren e: BACKUP",
                "label e: BACKUP",
                "vol e: BACKUP",
                "attrib e: +L BACKUP"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `label`-Befehl ist speziell daf√ºr vorgesehen, die Datentr√§gerbezeichnung (das Volume Label) eines Laufwerks zu erstellen, zu √§ndern oder zu l√∂schen. \n- **`ren`:** Dient zum Umbenennen von Dateien und Verzeichnissen, nicht von Laufwerken. ‚ùå\n- **`vol`:** Zeigt nur die aktuelle Bezeichnung an, kann sie aber nicht √§ndern. ‚ùå\n- **`attrib`:** Modifiziert Dateiattribute (wie schreibgesch√ºtzt, versteckt etc.), nicht die Volumebezeichnung. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Datentr√§ger-Befehle"
        },
        {
            "question": "Wahr oder Falsch: Der Befehl `cd Ordner1\\Ordner2` ist ein Beispiel f√ºr die Verwendung eines relativen Pfades. üõ§Ô∏è",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Wahr. Ein relativer Pfad geht vom aktuellen Verzeichnis aus. Wenn Sie sich z.B. in `C:\\Daten` befinden, w√ºrde `cd Ordner1\\Ordner2` versuchen, in das Verzeichnis `C:\\Daten\\Ordner1\\Ordner2` zu wechseln. Ein absoluter Pfad hingegen beginnt immer mit einem Laufwerksbuchstaben oder einem `\\` vom Wurzelverzeichnis aus (z.B. `cd C:\\Windows\\System32`). Dieses Verst√§ndnis ist fundamental f√ºr die Navigation und Skripterstellung.",
            "difficulty": "fortgeschritten",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "Sie m√ºssen in `diskpart` eine 500 MB gro√üe prim√§re Partition auf einem leeren Datentr√§ger erstellen. Welcher Befehl ist daf√ºr korrekt? üìè",
            "options": [
                "create partition primary size=500",
                "create primary partition 500mb",
                "create partition size=500mb primary",
                "create partition primary 500"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die korrekte Syntax f√ºr das Erstellen einer Partition mit einer bestimmten Gr√∂√üe in `diskpart` lautet `create partition [typ] size=[gr√∂√üe_in_mb]`. Der Parameter `size` erwartet die Gr√∂√üe in Megabyte (MB). \n- **Option B, C, D:** Verwenden eine falsche Syntax oder Reihenfolge der Parameter. Die Angabe 'mb' ist nicht Teil des Werts. ‚ùå",
            "difficulty": "experte",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "Was ist der historische und funktionale Hauptunterschied zwischen `CMD.EXE` und dem √§lteren `COMMAND.COM`? üèõÔ∏è",
            "options": [
                "`COMMAND.COM` war 32-Bit, `CMD.EXE` ist 16-Bit.",
                "`CMD.EXE` wurde mit Windows NT eingef√ºhrt und ist ein nativer 32/64-Bit-Prozess, w√§hrend `COMMAND.COM` ein 16-Bit-Interpreter aus der MS-DOS-√Ñra ist.",
                "`COMMAND.COM` unterst√ºtzte Batch-Skripte, `CMD.EXE` nicht.",
                "Es gibt keinen funktionalen Unterschied, nur der Name wurde ge√§ndert."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Dies ist ein wichtiger historischer Kontext. `COMMAND.COM` war der Kommandozeileninterpreter f√ºr MS-DOS und √§ltere Windows-Versionen (9x/Me). Es war eine 16-Bit-Anwendung mit vielen Einschr√§nkungen. `CMD.EXE` wurde als nativer 32-Bit-Interpreter (heute auch 64-Bit) f√ºr die Windows-NT-Linie (NT, 2000, XP, etc.) entwickelt und bot eine erweiterte Befehlssyntax und bessere Integration in das Betriebssystem. Beide unterst√ºtzen Batch-Skripte, aber `CMD.EXE` mit mehr Funktionen.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie vermuten, dass eine wichtige Systemdatei versteckt und schreibgesch√ºtzt ist. Welcher Befehl zeigt die Attribute der Datei `kernel32.dll` im System32-Ordner an? üëÅÔ∏è",
            "options": [
                "dir C:\\Windows\\System32\\kernel32.dll",
                "type C:\\Windows\\System32\\kernel32.dll",
                "attrib C:\\Windows\\System32\\kernel32.dll",
                "find \"kernel32.dll\" C:\\Windows\\System32"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der `attrib`-Befehl ist speziell daf√ºr da, die Attribute von Dateien oder Verzeichnissen anzuzeigen oder zu √§ndern. Dazu geh√∂ren A (Archiv), S (System), H (Hidden/Versteckt) und R (Read-only/Schreibgesch√ºtzt). \n- **`dir`:** Zeigt die Datei an, aber nicht immer alle Attribute auf einen Blick. ‚ùå\n- **`type`:** W√ºrde versuchen, den bin√§ren Inhalt der DLL-Datei als Text auszugeben, was zu unsinniger Ausgabe f√ºhrt. ‚ùå\n- **`find`:** Durchsucht den Inhalt von Dateien, nicht deren Attribute. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datei-Befehle"
        },
        {
            "question": "Um die gesamte Befehlshistorie der aktuellen CMD-Sitzung anzuzeigen, kann man `doskey /history` verwenden. Welcher Tastaturbefehl bietet eine √§hnliche, aber interaktivere Funktionalit√§t? ‚å®Ô∏è",
            "options": [
                "F7",
                "F3",
                "Pfeiltaste Oben (‚Üë)",
                "Tab-Taste"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die `F7`-Taste √∂ffnet in der CMD ein kleines Fenster, das eine nummerierte Liste der zuletzt eingegebenen Befehle anzeigt. Man kann dann mit den Pfeiltasten einen Befehl ausw√§hlen und mit `Enter` direkt ausf√ºhren. \n- **`F3`:** Wiederholt den letzten Befehl. ‚ùå\n- **`Pfeiltaste Oben`:** Bl√§ttert einzeln durch die vorherigen Befehle. ‚ùå\n- **`Tab-Taste`:** Wird zur automatischen Vervollst√§ndigung von Date- und Verzeichnisnamen verwendet. ‚ùå",
            "difficulty": "experte",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Ein Skript muss den vollst√§ndigen Pfad zu allen ausf√ºhrbaren Programmen (`.exe`) im Windows-Verzeichnis und allen seinen Unterverzeichnissen auflisten. Welcher `dir`-Befehl ist daf√ºr am besten geeignet? üó∫Ô∏è",
            "options": [
                "dir C:\\Windows\\*.exe",
                "dir C:\\Windows\\*.exe /s /b",
                "tree C:\\Windows /f",
                "find \".exe\" C:\\Windows"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `dir C:\\Windows\\*.exe /s /b` ist hier perfekt. `*.exe` filtert nach der Dateiendung. Der Schalter `/s` (subdirectories) durchsucht rekursiv alle Unterverzeichnisse. Der Schalter `/b` (bare format) gibt nur den reinen Pfad und Dateinamen aus, ohne Kopf- und Fu√üzeilen, was ideal f√ºr die Weiterverarbeitung in Skripten ist. \n- **Option A:** Durchsucht nur das `C:\\Windows`-Verzeichnis selbst, nicht die Unterordner. ‚ùå\n- **Option C:** `tree` zeigt die Verzeichnisstruktur an, was hier zu viel Information w√§re. ‚ùå\n- **Option D:** `find` durchsucht den *Inhalt* von Dateien, nicht die Dateinamen. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Sie m√ºssen eine gro√üe Anzahl von Dateien (ca. 150 GB) samt Unterverzeichnissen und NTFS-Berechtigungen auf einen neuen Server kopieren. Welcher Befehl ist daf√ºr robuster und besser geeignet als `copy` oder `xcopy`? üöö",
            "options": [
                "move",
                "diskpart",
                "robocopy",
                "format"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `robocopy` (Robust File Copy) ist das Mittel der Wahl f√ºr gro√üe und komplexe Kopiervorg√§nge. Es wurde speziell f√ºr solche Szenarien entwickelt und bietet Features wie das Kopieren von NTFS-Berechtigungen, Wiederaufnahme bei Netzwerkunterbrechungen, Spiegelungsmodi und umfangreiches Logging. `xcopy` ist zwar m√§chtiger als `copy`, aber `robocopy` ist der moderne Standard f√ºr administrative Aufgaben. Der Befehl wird im Material als Alternative zu `xcopy` erw√§hnt und geh√∂rt zum Wissen eines Fachinformatikers.",
            "difficulty": "experte",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Welcher `diskpart`-Befehl wird verwendet, um einen Datentr√§ger, der als 'offline' markiert ist, wieder f√ºr das System verf√ºgbar zu machen? üîå",
            "options": [
                "active",
                "online",
                "rescan",
                "assign"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Wenn ein Datentr√§ger oder ein Volume in `diskpart` (oder der Datentr√§gerverwaltung) als 'offline' angezeigt wird, kann das System nicht darauf zugreifen. Der Befehl `online` (nachdem das Objekt mit `select` ausgew√§hlt wurde) schaltet es wieder in den Online-Zustand und macht es f√ºr das Betriebssystem sichtbar und nutzbar. \n- **`active`:** Markiert eine Partition als bootf√§hig. ‚ùå\n- **`rescan`:** Sucht nach neuen, an den Computer angeschlossenen Datentr√§gern. ‚ùå\n- **`assign`:** Weist einen Laufwerksbuchstaben zu, was aber erst m√∂glich ist, wenn das Volume online ist. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        },
        {
            "question": "Was ist das Ergebnis des Befehls `prompt $T$G`? üïí",
            "options": [
                "Der Pfad gefolgt von einem '>'-Zeichen.",
                "Datum und Uhrzeit.",
                "Die aktuelle Uhrzeit gefolgt von einem '>'-Zeichen.",
                "Der Text '$T$G' wird als neuer Prompt gesetzt."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der `prompt`-Befehl √§ndert die Eingabeaufforderung. Dabei werden spezielle Metacodes verwendet. `$T` steht f√ºr die aktuelle Uhrzeit (Time) und `$G` steht f√ºr das 'gr√∂√üer als'-Zeichen (`>`). Der Befehl setzt den Prompt also z.B. auf `14:30:55,12>`. Dies kann n√ºtzlich sein, um Befehle in Skripten mit einem Zeitstempel zu versehen. `$P$G` ist der Standard-Prompt, der den Pfad anzeigt.",
            "difficulty": "experte",
            "category": "Allgemeine Befehle"
        },
        {
            "question": "Sie haben ein Verzeichnis `C:\\Logs` mit tausenden von Dateien. Sie m√∂chten schnell herausfinden, ob es eine Datei mit dem exakten Namen `error_2025-08-26.log` gibt. Welcher Befehl ist am schnellsten und ressourcenschonendsten? üí®",
            "options": [
                "dir C:\\Logs /s",
                "find \"error_2025-08-26.log\" C:\\Logs\\*",
                "dir C:\\Logs\\error_2025-08-26.log",
                "tree C:\\Logs"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der direkteste Weg ist, `dir` mit dem vollst√§ndigen Dateinamen aufzurufen. Wenn die Datei existiert, wird sie sofort aufgelistet. Wenn nicht, meldet `dir` 'Datei nicht gefunden'. Dies ist wesentlich schneller als andere Methoden. \n- **`dir /s`:** W√ºrde alle Unterverzeichnisse durchsuchen, was unn√∂tig ist. ‚ùå\n- **`find`:** Durchsucht den *Inhalt* der Dateien nach dem String, nicht die Dateinamen. Das w√ºrde extrem lange dauern und nicht das gew√ºnschte Ergebnis liefern. ‚ùå\n- **`tree`:** Zeigt die gesamte Verzeichnisstruktur an, was bei tausenden Dateien sehr un√ºbersichtlich und langsam ist. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Wahr oder Falsch: Die Eingabe von `help > befehle.txt` und `help /?` f√ºhrt zum exakt gleichen Ergebnis. ü§î",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. `help > befehle.txt` leitet die *Ausgabe* des `help`-Befehls (also die Liste aller verf√ºgbaren Befehle) in die Datei `befehle.txt` um. Der Befehl `help /?` hingegen zeigt die *Hilfe zum `help`-Befehl selbst* an, also eine Beschreibung, wie der `help`-Befehl funktioniert. Das sind zwei v√∂llig unterschiedliche Aktionen.",
            "difficulty": "fortgeschritten",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "In der Befehlssyntax-Hilfe (z.B. bei `dir /?`) sind einige Parameter in eckigen Klammern `[ ]` aufgef√ºhrt. Was bedeutet diese Konvention? üìñ",
            "options": [
                "Diese Parameter sind veraltet und sollten nicht mehr verwendet werden.",
                "Diese Parameter sind obligatorisch und m√ºssen immer angegeben werden.",
                "Diese Parameter sind optional und k√∂nnen weggelassen werden.",
                "Diese Parameter funktionieren nur im Administratormodus."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die eckigen Klammern `[ ]` sind eine Standardkonvention in der Dokumentation von Kommandozeilenprogrammen, um optionale Parameter, Schalter oder Argumente zu kennzeichnen. Elemente ohne Klammern sind in der Regel erforderlich. Dieses Wissen ist entscheidend, um die Hilfe-Texte der CMD korrekt interpretieren zu k√∂nnen.",
            "difficulty": "einsteiger",
            "category": "Befehlssyntax"
        },
        {
            "question": "Ein USB-Stick wurde f√§lschlicherweise mit `diskpart` und dem `clean`-Befehl bereinigt. Der Benutzer m√∂chte nun versuchen, die Daten wiederherzustellen. Was ist der wichtigste erste Schritt, den er unternehmen sollte, um die Chancen auf eine erfolgreiche Wiederherstellung zu maximieren? üöë",
            "options": [
                "Sofort eine neue Partition erstellen und formatieren, um wieder auf den Stick zugreifen zu k√∂nnen.",
                "Den `chkdsk /r`-Befehl ausf√ºhren, um die Dateistruktur zu reparieren.",
                "Den Stick sofort vom Computer trennen und keine weiteren Schreibvorg√§nge durchf√ºhren.",
                "Den Befehl `diskpart convert mbr` ausf√ºhren."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Nach einem `clean`-Befehl sind die Daten physisch noch vorhanden, aber der 'Wegweiser' (die Partitionstabelle) zu ihnen wurde gel√∂scht. Jeder weitere Schreibvorgang (wie das Erstellen einer neuen Partition, Formatieren, `chkdsk`) birgt die Gefahr, die alten Daten physisch zu √ºberschreiben und sie damit endg√ºltig zu zerst√∂ren. Der wichtigste Schritt ist daher, alle Schreibzugriffe zu verhindern und spezialisierte Datenrettungssoftware zu verwenden, die den Datentr√§ger Sektor f√ºr Sektor scannen kann.",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Welcher Befehl erstellt ein neues Verzeichnis namens `Test Data` im aktuellen Ordner? üóÇÔ∏è",
            "options": [
                "md Test Data",
                "md \"Test Data\"",
                "create Test Data",
                "dir \"Test Data\""
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Da der Verzeichnisname ein Leerzeichen enth√§lt, muss er in Anf√ºhrungszeichen `\" \"` eingeschlossen werden. Ohne Anf√ºhrungszeichen w√ºrde der `md` (make directory)-Befehl versuchen, zwei separate Verzeichnisse namens `Test` und `Data` zu erstellen. \n- **Option A:** W√ºrde zwei Ordner erstellen. ‚ùå\n- **Option C:** Der Befehl `create` existiert in diesem Kontext in der CMD nicht. ‚ùå\n- **Option D:** `dir` zeigt den Inhalt an, erstellt aber nichts. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "Sie m√∂chten alle Textdateien (`.txt`) im aktuellen Verzeichnis umbenennen, sodass sie stattdessen die Endung `.bak` haben. Welcher Befehl erledigt das f√ºr alle Dateien auf einmal? üîÑ",
            "options": [
                "move *.txt *.bak",
                "copy *.txt *.bak",
                "ren *.txt *.bak",
                "attrib *.txt -r"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `ren` (rename) ist f√ºr das Umbenennen von Dateien zust√§ndig. Er unterst√ºtzt die Verwendung von Wildcards (`*` und `?`), um Operationen auf mehrere Dateien gleichzeitig anzuwenden. Der Befehl `ren *.txt *.bak` findet alle Dateien, die auf `.txt` enden, und ersetzt die Endung durch `.bak`, w√§hrend der Dateiname erhalten bleibt.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "Vergleichen Sie die Befehle `date` und `time`. Was ist eine Gemeinsamkeit in ihrer Standardfunktionalit√§t in der CMD? üï∞Ô∏è",
            "options": [
                "Beide zeigen nur Informationen an und erlauben keine √Ñnderungen.",
                "Beide erfordern Administratorrechte, um ausgef√ºhrt zu werden.",
                "Beide zeigen den aktuellen Wert an und bieten direkt im Anschluss die M√∂glichkeit, einen neuen Wert einzugeben.",
                "Beide k√∂nnen ihre Ausgabe nur im `YYYY-MM-DD` bzw. `HH:MM:SS` Format darstellen."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Wenn `date` oder `time` ohne Parameter aufgerufen wird, zeigen sie zun√§chst den aktuellen Systemwert an. Direkt in der n√§chsten Zeile erscheint eine Eingabeaufforderung, in der der Benutzer ein neues Datum bzw. eine neue Uhrzeit eingeben kann. Dr√ºckt man einfach `Enter`, wird keine √Ñnderung vorgenommen. Diese interaktive Funktionalit√§t ist eine charakteristische Gemeinsamkeit der beiden Befehle.",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie f√ºhren den Befehl `tree /f` in einem Ordner aus. Was unterscheidet die Ausgabe von einem einfachen `tree`-Befehl? üå≤",
            "options": [
                "Die Ausgabe wird in eine Datei namens 'f' geschrieben.",
                "Es werden nur die Verzeichnisse des ersten Levels angezeigt.",
                "Die Ausgabe wird alphabetisch sortiert.",
                "Zus√§tzlich zur Verzeichnisstruktur werden auch die Dateien in jedem Verzeichnis aufgelistet."
            ],
            "correct": 3,
            "explain": "**Begr√ºndung:** Der `tree`-Befehl zeigt die Ordnerstruktur eines Pfades grafisch an. Der Schalter `/f` (files) erweitert diese Funktionalit√§t und sorgt daf√ºr, dass nicht nur die Verzeichnisse, sondern auch alle darin enthaltenen Dateien aufgelistet werden, was einen vollst√§ndigen √úberblick √ºber die Hierarchie gibt.",
            "difficulty": "fortgeschritten",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "Ein Benutzer m√∂chte ein Skript erstellen, das automatisch ein Backup-Verzeichnis erstellt. Das Verzeichnis soll nach dem aktuellen Datum benannt werden, z.B. 'Backup_2025-08-26'. Welche CMD-Funktion ist unerl√§sslich, um dies zu erreichen? üóìÔ∏è",
            "options": [
                "Die `date`-Variable, zug√§nglich √ºber `%DATE%`.",
                "Der `format`-Befehl mit einem Datumsparameter.",
                "Der `set`-Befehl allein.",
                "Der `doskey`-Befehl zur Makroerstellung."
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die CMD stellt Umgebungsvariablen bereit, die dynamische Systeminformationen enthalten. `%DATE%` ist eine solche Variable, die das aktuelle Systemdatum enth√§lt. In einem Skript k√∂nnte man also einen Befehl wie `md Backup_%DATE%` verwenden, um einen Ordner mit dem tagesaktuellen Datum im Namen zu erstellen. Dies ist eine grundlegende, aber extrem m√§chtige Technik f√ºr die Automatisierung.",
            "difficulty": "experte",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Welcher `diskpart`-Befehl liefert detaillierte Informationen √ºber das aktuell ausgew√§hlte Objekt, z.B. den Typ, die Gr√∂√üe und den Status einer Partition? ‚ÑπÔ∏è",
            "options": [
                "list",
                "help",
                "detail",
                "attributes"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Nachdem ein Objekt mit `select` in den Fokus genommen wurde (z.B. `select partition 1`), liefert der Befehl `detail` spezifische Informationen genau zu diesem Objekt. `detail disk` zeigt z.B. Festplattendetails, `detail partition` Partitionsdetails und `detail volume` Volumedetails. \n- **`list`:** Zeigt eine √úbersicht aller Objekte eines Typs, aber keine Details zu einem einzelnen. ‚ùå\n- **`help`:** Zeigt Hilfe zu Befehlen an. ‚ùå\n- **`attributes`:** Dient zum Anzeigen und √Ñndern von Attributen, nicht zur allgemeinen Detailansicht. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        },
        {
            "question": "Wie kann man in der CMD schnell den Bildschirm von allen vorherigen Befehlen und Ausgaben bereinigen? üßº",
            "options": [
                "clear",
                "clean",
                "cls",
                "exit"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `cls` (clear screen) ist der Standardbefehl in der Windows-Kommandozeile, um den gesamten Inhalt des Konsolenfensters zu l√∂schen und den Cursor in die obere linke Ecke zu setzen. \n- **`clear`:** Ist der entsprechende Befehl in Linux/Unix-Shells, funktioniert in CMD aber nicht. ‚ùå\n- **`clean`:** Ist ein `diskpart`-Befehl mit einer v√∂llig anderen (und gef√§hrlichen) Funktion. ‚ùå\n- **`exit`:** Schlie√üt das CMD-Fenster. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Allgemeine Befehle"
        },
        {
            "question": "Sie m√ºssen eine Partition in `diskpart` als 'inaktiv' markieren. Welcher Befehl wird nach der Auswahl der Partition daf√ºr verwendet? ‚õî",
            "options": [
                "deactivate",
                "inactive",
                "remove active",
                "setid inactive"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `inactive` ist das direkte Gegenst√ºck zum `active`-Befehl. Nachdem eine Partition ausgew√§hlt wurde (z.B. `select partition 1`), markiert der Befehl `inactive` diese als nicht mehr bootf√§hig. Dies ist eine wichtige Funktion bei der Verwaltung von Multi-Boot-Systemen.",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        },
        {
            "question": "üÜò Ein Kollege ruft Sie an und fragt nach Hilfe zu einem CMD-Befehl, den er nicht kennt. Welcher Befehl zeigt ihm alle verf√ºgbaren Befehle und deren Beschreibungen an?",
            "options": [
                "help",
                "/?",
                "commands",
                "list"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `/?` ist der universelle Hilfebefehl in CMD üìã. Er kann sowohl alleine verwendet werden, um eine Liste aller Befehle zu erhalten, als auch hinter einem spezifischen Befehl (z.B. `dir /?`), um detaillierte Informationen zu diesem Befehl anzuzeigen. Dies ist besonders n√ºtzlich f√ºr IT-Support-Szenarien, da man schnell die richtige Syntax und Parameter eines Befehls nachschlagen kann. Die anderen Optionen sind keine g√ºltigen CMD-Befehle in diesem Kontext.",
            "difficulty": "einsteiger",
            "category": "Grundlagen CMD"
        },
        {
            "question": "‚ö° Sie m√ºssen in einem Batch-Script drei Befehle nacheinander ausf√ºhren, aber nur wenn der vorherige erfolgreich war. Welche Syntax verwenden Sie zwischen den Befehlen?",
            "options": [
                "&",
                "&&",
                "||",
                "|"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Operator `&&` f√ºhrt den nachfolgenden Befehl nur aus, wenn der vorherige Befehl erfolgreich war (Exit-Code 0) ‚úÖ. Dies ist kritisch f√ºr Batch-Scripts in produktiven Umgebungen, da Fehler nicht propagiert werden. Der einfache `&` w√ºrde alle Befehle unabh√§ngig vom Erfolg ausf√ºhren, `||` f√ºhrt nur bei Fehlern aus, und `|` ist f√ºr Pipes gedacht. In der Praxis verhindert `&&` Folgesch√§den durch fehlerhafte Befehle.",
            "difficulty": "fortgeschritten",
            "category": "Batch-Scripting"
        },
        {
            "question": "üé® Ein Benutzer mit Sehschw√§che ben√∂tigt bessere Kontraste in der Eingabeaufforderung. Mit welchem Befehl k√∂nnen Sie die Farben des Textes und Hintergrunds anpassen?",
            "options": [
                "theme",
                "color",
                "display",
                "contrast"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `color` Befehl erm√∂glicht es, sowohl Text- als auch Hintergrundfarben zu √§ndern üåà. Die Syntax ist `color [Hintergrund][Text]` mit hexadezimalen Werten (0-F). Beispiel: `color 0A` setzt schwarzen Hintergrund mit gr√ºnem Text. Dies ist besonders wichtig f√ºr Barrierefreiheit und kann die Produktivit√§t bei langen Terminal-Sessions erheblich steigern. Moderne IT-Umgebungen sollten Accessibility-Anforderungen ber√ºcksichtigen.",
            "difficulty": "einsteiger",
            "category": "Benutzerfreundlichkeit"
        },
        {
            "question": "üìã Sie erstellen ein Monitoring-Script, das Systemdaten in eine Datei speichern soll, aber auch gleichzeitig in die Zwischenablage kopieren muss. Welcher Befehl hilft dabei?",
            "options": [
                "copy",
                "clip",
                "clipboard",
                "paste"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `clip` Befehl kopiert die Ausgabe eines beliebigen Befehls direkt in die Windows-Zwischenablage üìé. Beispiel: `systeminfo | clip` kopiert alle Systeminformationen in die Zwischenablage. Dies ist extrem n√ºtzlich f√ºr IT-Dokumentation, Support-Tickets oder beim Teilen von Systeminformationen. In Kombination mit Pipes (`|`) k√∂nnen komplexe Datenverarbeitungsketten erstellt werden, die sowohl in Dateien als auch in die Zwischenablage ausgeben.",
            "difficulty": "fortgeschritten",
            "category": "Datenverarbeitung"
        },
        {
            "question": "üìú Bei der Fehleranalyse m√ºssen Sie nachvollziehen, welche Befehle ein Kollege in der aktuellen CMD-Session verwendet hat. Welcher Befehl zeigt den Verlauf an?",
            "options": [
                "history",
                "doskey /history", 
                "cmdhistory",
                "log"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `doskey /history` zeigt alle Befehle der aktuellen Session an üìö. Doskey ist ein m√§chtiges Tool f√ºr Befehlsverwaltung, das auch Makros und Aliase unterst√ºtzt. Dies ist essentiell f√ºr Debugging, Compliance-Audits und Nachverfolgung von System√§nderungen. In kritischen Umgebungen kann der Befehlsverlauf bei der Root-Cause-Analyse von Problemen entscheidend sein. Professionelle Administratoren nutzen dies zur Dokumentation ihrer Arbeitsschritte.",
            "difficulty": "fortgeschritten",
            "category": "System-Administration"
        },
        {
            "question": "üîç Ihr Server l√§uft langsam und Sie vermuten einen problematischen Prozess. Mit welchem Befehl erhalten Sie eine √úbersicht aller laufenden Prozesse inklusive ihrer IDs?",
            "options": [
                "ps",
                "processes",
                "tasklist",
                "jobs"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `tasklist` zeigt alle laufenden Anwendungen, Dienste und deren Prozess-IDs (PIDs) an üñ•Ô∏è. Dies ist das Windows-√Ñquivalent zu `ps` unter Unix/Linux. Der Befehl unterst√ºtzt Filter wie `/fo table` f√ºr bessere Formatierung oder `/svc` f√ºr Service-Details. In produktiven Umgebungen ist dies essentiell f√ºr Performance-Monitoring, Ressourcen-Management und Identifikation problematischer Prozesse vor deren Beendigung.",
            "difficulty": "einsteiger",
            "category": "Prozess-Management"
        },
        {
            "question": "‚öîÔ∏è Sie haben einen h√§ngenden Prozess mit der PID 1234 identifiziert, der 80% CPU verbraucht. Welcher Befehl beendet diesen Prozess sofort?",
            "options": [
                "kill 1234",
                "end 1234",
                "taskkill /PID 1234",
                "stop 1234"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `taskkill /PID 1234` beendet den Prozess mit der angegebenen Prozess-ID üíÄ. Der Parameter `/F` kann hinzugef√ºgt werden f√ºr forciertes Beenden. Dies ist kritisch bei h√§ngenden Prozessen, die Systemressourcen blockieren. In produktiven Umgebungen sollte man vorsichtig sein, da das unsaubere Beenden von Prozessen Datenverlust verursachen kann. Alternative Syntax: `/IM prozessname.exe` f√ºr Beendigung nach Namen.",
            "difficulty": "fortgeschritten",
            "category": "Prozess-Management"
        },
        {
            "question": "üóÇÔ∏è Ein Benutzer kann keine .PDF-Dateien √∂ffnen, da die Dateizuordnung besch√§digt ist. Mit welchem Befehl k√∂nnen Sie die aktuellen Dateizuordnungen anzeigen und √§ndern?",
            "options": [
                "filetype",
                "assoc",
                "extension",
                "ftype"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `assoc` zeigt und √§ndert die Zuordnung zwischen Dateierweiterungen und Dateitypen üìÑ. Beispiel: `assoc .pdf` zeigt die aktuelle Zuordnung f√ºr PDF-Dateien. Mit `assoc .pdf=AcroExch.Document` wird die Zuordnung ge√§ndert. Dies ist essentiell f√ºr IT-Support bei Problemen mit Standard-Anwendungen. In Unternehmensumgebungen ist die korrekte Dateizuordnung kritisch f√ºr Produktivit√§t und Workflow-Integration.",
            "difficulty": "fortgeschritten",
            "category": "Dateisystem-Management"
        },
        {
            "question": "üîß Bei Hardware-Problemen m√ºssen Sie √ºberpr√ºfen, ob alle Treiber korrekt installiert sind. Welcher Befehl listet alle installierten Treiber auf?",
            "options": [
                "drivers",
                "driverquery",
                "hwinfo",
                "devinfo"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `driverquery` zeigt eine detaillierte Liste aller installierten Treiber mit Informationen wie Name, Typ, Datum und Version an üöó. Parameter wie `/fo csv` erm√∂glichen Export in verschiedene Formate f√ºr weitere Analyse. Dies ist unverzichtbar bei Hardware-Troubleshooting, Compliance-Audits und Systemdokumentation. In kritischen Umgebungen hilft es bei der Identifikation veralteter oder problematischer Treiber vor System-Updates.",
            "difficulty": "experte",
            "category": "Hardware-Diagnose"
        },
        {
            "question": "üåê Ein Netzwerkadministrator ben√∂tigt die IP-Konfiguration aller Netzwerkadapter f√ºr die Dokumentation. Welcher Befehl liefert diese Informationen am vollst√§ndigsten?",
            "options": [
                "netconfig",
                "ipinfo", 
                "ipconfig",
                "netinfo"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `ipconfig` zeigt detaillierte IP-Informationen f√ºr alle TCP/IP-Adapter an üåç. Parameter: `/all` f√ºr vollst√§ndige Details, `/release` und `/renew` f√ºr DHCP-Verwaltung, `/flushdns` f√ºr DNS-Cache-Bereinigung. Dies ist das zentrale Tool f√ºr Netzwerk-Troubleshooting und -Dokumentation. In Unternehmensumgebungen essentiell f√ºr IP-Management, DHCP-Problembehebung und Netzwerk-Compliance.",
            "difficulty": "einsteiger",
            "category": "Netzwerk-Administration"
        },
        {
            "question": "üì° Sie vermuten Verbindungsprobleme zu einem Server (192.168.1.100). Mit welchem Befehl testen Sie die Erreichbarkeit auf IP-Ebene?",
            "options": [
                "test 192.168.1.100",
                "connect 192.168.1.100",
                "ping 192.168.1.100",
                "reach 192.168.1.100"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `ping 192.168.1.100` sendet ICMP Echo-Request-Pakete zum Testen der IP-Konnektivit√§t üì∂. Zeigt Antwortzeiten, Paketverluste und TTL-Werte. Parameter wie `-t` f√ºr kontinuierliches Pingen oder `-n 10` f√ºr bestimmte Anzahl. Dies ist der erste Schritt bei Netzwerk-Troubleshooting. Hilft bei der Unterscheidung zwischen Routing-, DNS- oder Anwendungsproblemen. Unverzichtbar f√ºr Netzwerk-Monitoring und Performance-Analyse.",
            "difficulty": "einsteiger",
            "category": "Netzwerk-Diagnose"
        },
        {
            "question": "üîå Bei verd√§chtiger Netzwerkaktivit√§t m√ºssen Sie alle aktiven Netzwerkverbindungen und lauschende Ports analysieren. Welcher Befehl liefert diese Informationen?",
            "options": [
                "connections",
                "ports",
                "netstat",
                "sockstat"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `netstat` zeigt alle offenen Netzwerkverbindungen, lauschende Ports und Routing-Tabellen an üîç. Parameter: `-a` f√ºr alle Verbindungen, `-n` f√ºr numerische Adressen, `-b` f√ºr Anwendungsnamen. Essentiell f√ºr Security-Audits, Malware-Erkennung und Performance-Analyse. In Sicherheitsumgebungen hilft es bei der Identifikation unautorisierten Netzwerktraffics und potentieller Backdoors.",
            "difficulty": "experte",
            "category": "Netzwerk-Security"
        },
        {
            "question": "üíª F√ºr ein Hardware-Audit ben√∂tigen Sie vollst√§ndige Systeminformationen inklusive Prozessor, RAM und Mainboard-Details. Welcher Befehl liefert diese umfassenden Daten?",
            "options": [
                "hwinfo",
                "sysinfo",
                "systeminfo",
                "pcinfo"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `systeminfo` liefert umfassende Windows-Konfigurationsinformationen wie Hardware-Details, OS-Version, Patches, Netzwerk-Karten und Boot-Zeit üñ•Ô∏è. Unterst√ºtzt auch Remote-Computer mit `/s computername`. Ideal f√ºr Asset-Management, Compliance-Berichte und Systemdokumentation. In Enterprise-Umgebungen unverzichtbar f√ºr Inventarisierung, Update-Planning und Hardware-Lifecycle-Management.",
            "difficulty": "einsteiger",
            "category": "System-Information"
        },
        {
            "question": "üîã Ein Laptop hat Akku-Probleme und Sie m√ºssen die Energieeinstellungen analysieren und optimieren. Welcher CMD-Befehl erm√∂glicht erweiterte Energieverwaltung?",
            "options": [
                "battery",
                "power",
                "powercfg",
                "energy"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `powercfg` ist das m√§chtigste Tool f√ºr Windows-Energieverwaltung ‚ö°. Parameter: `/batteryreport` f√ºr Akkuanalyse, `/energy` f√ºr Energieeffizienz-Bericht, `/hibernate on/off` f√ºr Ruhezustand. Kann Energieschemas erstellen und modifizieren. Kritisch f√ºr Laptop-Optimierung, Server-Effizienz und Green-IT-Initiativen. Hilft bei der Identifikation energiefressender Hardware und Software.",
            "difficulty": "experte",
            "category": "Energieverwaltung"
        },
        {
            "question": "üõ°Ô∏è Nach einem Systemabsturz vermuten Sie besch√§digte Systemdateien. Welcher Befehl √ºberpr√ºft und repariert kritische Windows-Systemdateien?",
            "options": [
                "fixsystem",
                "sfc",
                "repair",
                "checkfiles"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `sfc` (System File Checker) √ºberpr√ºft die Integrit√§t aller gesch√ºtzten Systemdateien und repariert besch√§digte Dateien üîß. Syntax: `sfc /scannow` f√ºr vollst√§ndige √úberpr√ºfung. Verwendet Windows Resource Protection (WRP) und das Component Store. Essentiell nach Malware-Befall, Abst√ºrzen oder fehlgeschlagenen Updates. Sollte im abgesicherten Modus oder mit Administrator-Rechten ausgef√ºhrt werden.",
            "difficulty": "fortgeschritten",
            "category": "System-Reparatur"
        },
        {
            "question": "üíΩ Ein Server zeigt Speicherfehler und Sie m√ºssen die Festplatte auf Bad Sectors und Dateisystemfehler √ºberpr√ºfen. Welcher Befehl f√ºhrt diese Diagnose durch?",
            "options": [
                "diskcheck",
                "scandisk",
                "chkdsk",
                "fsck"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `chkdsk` (Check Disk) erkennt und repariert Festplattenfehler, Bad Sectors und Dateisystem-Inkonsistenzen üíø. Parameter: `/f` f√ºr automatische Reparatur, `/r` f√ºr Bad-Sector-Recovery. Muss oft nach Neustart ausgef√ºhrt werden f√ºr Systemlaufwerke. Kritisch f√ºr Datenintegrit√§t, Performance-Optimierung und Fr√ºhwarnung vor Festplattenausfall. In produktiven Umgebungen sollte es regelm√§√üig geplant werden.",
            "difficulty": "fortgeschritten",
            "category": "Speicher-Diagnose"
        },
        {
            "question": "üóÉÔ∏è Sie m√ºssen Registry-Einstellungen f√ºr eine Anwendung manuell korrigieren, da der normale Installer versagt hat. Welcher Befehl √∂ffnet den Registry-Editor?",
            "options": [
                "registry",
                "regedt32",
                "regedit",
                "regmod"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `regedit` √∂ffnet den Windows Registry-Editor f√ºr manuelle Bearbeitung der Systemregistrierung üìä. Extrem m√§chtig aber gef√§hrlich - falsche √Ñnderungen k√∂nnen Windows unbrauchbar machen. Sollte nur von erfahrenen Administratoren verwendet werden. Vor √Ñnderungen immer Backup erstellen. Alternative: `reg` Befehl f√ºr Kommandozeilen-Registry-Operationen. In Unternehmensumgebungen oft durch Group Policies ersetzt.",
            "difficulty": "experte",
            "category": "Registry-Management"
        },
        {
            "question": "‚è∞ Sie m√ºssen ein automatisches Backup-Script erstellen, das jeden Tag um 2:00 Uhr l√§uft. Welcher Befehl erm√∂glicht die Verwaltung geplanter Aufgaben?",
            "options": [
                "schedule",
                "cron",
                "schtasks",
                "taskman"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `schtasks` erstellt, l√∂scht und verwaltet geplante Aufgaben in Windows ‚è∞. Beispiel: `schtasks /create /tn \"Backup\" /tr \"backup.bat\" /sc daily /st 02:00`. Ersetzt das veraltete `at` Kommando. Parameter f√ºr Trigger, Benutzerkontext und Bedingungen. Essentiell f√ºr Automatisierung, Wartungsaufgaben und Monitoring. In Serverumgebungen kritisch f√ºr regelm√§√üige Backups, Updates und Systemwartung.",
            "difficulty": "experte",
            "category": "Task-Automation"
        },
        {
            "question": "üóëÔ∏è Der Computer l√§uft langsam und Sie vermuten, dass tempor√§re Dateien die Ursache sind. Welcher Befehl l√∂scht alle tempor√§ren Dateien des aktuellen Benutzers?",
            "options": [
                "cleantmp",
                "deltmp", 
                "del /q /f /s %temp%\\*",
                "remove temp"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `del /q /f /s %temp%\\*` l√∂scht alle Dateien im tempor√§ren Verzeichnis des Benutzers üßπ. Parameter: `/q` f√ºr quiet (keine Best√§tigung), `/f` f√ºr forcierte L√∂schung schreibgesch√ºtzter Dateien, `/s` f√ºr Unterverzeichnisse. %temp% ist eine Umgebungsvariable f√ºr das Temp-Verzeichnis. Wichtig f√ºr System-Optimierung, Speicherplatz-Freigabe und Privacy. Sollte regelm√§√üig in Wartungsroutinen eingesetzt werden.",
            "difficulty": "fortgeschritten",
            "category": "System-Wartung"
        },
        {
            "question": "üö™ Nach Abschluss aller Wartungsarbeiten m√∂chten Sie die CMD-Session sauber beenden und zur normalen Desktop-Arbeit zur√ºckkehren. Welcher Befehl schlie√üt die Eingabeaufforderung?",
            "options": [
                "quit",
                "close",
                "exit",
                "end"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `exit` beendet die aktuelle CMD-Session ordnungsgem√§√ü und schlie√üt das Eingabeaufforderungs-Fenster üö™. In Batch-Scripts kann ein Exit-Code √ºbergeben werden (z.B. `exit /b 0` f√ºr erfolgreiche Beendigung). Dies ist wichtig f√ºr saubere Script-Beendigung und Ressourcen-Freigabe. In automatisierten Umgebungen signalisiert der Exit-Code anderen Prozessen den Ausf√ºhrungsstatus. Professionelle Scripts sollten immer mit entsprechenden Exit-Codes enden.",
            "difficulty": "einsteiger",
            "category": "Session-Management"
        },{
      "question": " Szenario: Ein Admin m√∂chte den Ordner `C:\\Daten` inklusive aller Unterordner, auch der leeren, auf Laufwerk `G:` sichern. Welcher `xcopy`-Befehl ist daf√ºr am besten geeignet? üìÇ",
      "options": [
        "xcopy C:\\Daten G:\\Daten /s",
        "xcopy C:\\Daten G:\\Daten /e",
        "copy C:\\Daten G:\\Daten /s",
        "xcopy C:\\Daten\\*.* G:\\Daten /e"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der Schalter `/e` ist entscheidend, da er `xcopy` anweist, alle Unterverzeichnisse zu kopieren, **einschlie√ülich der leeren**. Der Schalter `/s` kopiert nur Unterverzeichnisse, die nicht leer sind. Der `copy`-Befehl kann keine Verzeichnisstrukturen kopieren. Die Verwendung von `*.*` w√ºrde nur die Dateien im Stammverzeichnis von `Daten` als Quelle nehmen, nicht den Ordner selbst. ‚öôÔ∏è",
      "difficulty": "einsteiger",
      "category": "Kopierbefehle"
    },
    {
      "question": "Szenario: Nach dem Ausf√ºhren von `xcopy F:\\projekt G:\\backup` stellt der Benutzer fest, dass auf `G:` zwar der *Inhalt* von `projekt` liegt, aber der Ordner `projekt` selbst fehlt. Was ist die korrekte Syntax, um die gesamte Struktur, einschlie√ülich des `projekt`-Ordners, zu kopieren?  Strukturelles Problem! üèóÔ∏è",
      "options": [
        "xcopy F:\\projekt\\*.* G:\\backup\\projekt /s /e",
        "xcopy F:\\projekt G:\\backup\\projekt\\ /s /e",
        "xcopy F:\\projekt G:\\backup /s /e /root",
        "xcopy F:\\projekt G:\\ /s /e"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** `xcopy` kopiert standardm√§√üig den *Inhalt* der Quelle ins Ziel. Um den Quellordner selbst im Ziel zu erstellen, muss er im Zielpfad explizit angegeben werden (`G:\\backup\\projekt`). Der abschlie√üende Backslash (`\\`) signalisiert `xcopy` eindeutig, dass das Ziel ein Verzeichnis ist, und unterdr√ºckt die Nachfrage 'Datei oder Verzeichnis?'. üí°",
      "difficulty": "fortgeschritten",
      "category": "Befehlssyntax"
    },
    {
      "question": "Vergleichende Analyse: Was ist der prim√§re funktionale Unterschied zwischen dem `copy`- und dem `xcopy`-Befehl in der Windows-Kommandozeile? ü§î",
      "options": [
        "`xcopy` ist schneller, aber `copy` kann mehr Dateitypen verarbeiten.",
        "`copy` kann nur einzelne Dateien kopieren, w√§hrend `xcopy` ganze Verzeichnisb√§ume kopieren kann.",
        "`xcopy` ist veraltet und wurde durch `copy /s` ersetzt.",
        "`copy` kann √ºber das Netzwerk kopieren, `xcopy` nicht."
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der Hauptunterschied liegt im Umfang. `copy` ist f√ºr das Kopieren von Dateien konzipiert. `xcopy` (Extended Copy) wurde entwickelt, um ganze Verzeichnisstrukturen rekursiv zu kopieren, was es zu einem m√§chtigen Werkzeug f√ºr Backups und das Duplizieren von Ordnern macht. üå≥",
      "difficulty": "einsteiger",
      "category": "Grundlagen der Kommandozeile"
    },
    {
      "question": "Berechnungsaufgabe: Ein Verzeichnis `C:\\source` enth√§lt 3 Dateien. Das Unterverzeichnis `C:\\source\\A` enth√§lt 2 Dateien und das Unterverzeichnis `C:\\source\\B` ist leer. Wie viele Dateien werden mit dem Befehl `xcopy C:\\source D:\\dest /s` kopiert? üßÆ",
      "options": [
        "0 Dateien",
        "3 Dateien",
        "5 Dateien",
        "Alle Dateien und das leere Verzeichnis B."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Der Befehl kopiert die 3 Dateien aus `C:\\source` und die 2 Dateien aus `C:\\source\\A`. Das Verzeichnis `C:\\source\\B` wird ignoriert, da der Schalter `/s` nur **nicht-leere** Verzeichnisse ber√ºcksichtigt. Insgesamt werden also 3 + 2 = 5 Dateien kopiert. üìÑ",
      "difficulty": "fortgeschritten",
      "category": "Befehlsparameter"
    },
    {
      "question": "Logisches R√§tsel: Ein Skript f√ºhrt den Befehl `xcopy F:\\daten\\ G:\\backup\\daten /e` aus. Unmittelbar danach wird `rd G:\\backup\\daten /s /q` ausgef√ºhrt. Was ist der Zustand des Verzeichnisses `G:\\backup\\daten` nach beiden Befehlen? üîÑ",
      "options": [
        "Es ist leer, aber vorhanden.",
        "Es enth√§lt die urspr√ºngliche Sicherung.",
        "Es existiert nicht mehr.",
        "Es enth√§lt nur noch die leeren Unterverzeichnisse."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Der erste Befehl (`xcopy`) erstellt eine vollst√§ndige Kopie. Der zweite Befehl, `rd` (Remove Directory) mit dem Schalter `/s`, l√∂scht das angegebene Verzeichnis und **alle** darin enthaltenen Unterverzeichnisse und Dateien. Der Schalter `/q` (Quiet) unterdr√ºckt die Best√§tigungsabfrage. Das Verzeichnis wird also komplett und ohne R√ºckfrage entfernt. üí®",
      "difficulty": "einsteiger",
      "category": "Befehlsketten"
    },
    {
      "question": "Wahr/Falsch: Der Befehl `robocopy` ist ein √§lterer und einfacherer Befehl als `xcopy` und wird daher f√ºr simple Aufgaben bevorzugt. üìú",
      "options": [
        "Wahr",
        "Falsch"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Falsch. `robocopy` (Robust File Copy) ist der neuere und wesentlich leistungsf√§higere Nachfolger von `xcopy`. Es bietet Features wie Spiegelung (`/mir`), Wiederholungslogik bei Netzwerkfehlern, Kopieren von Berechtigungen und eine deutlich bessere Performance bei gro√üen Kopiervorg√§ngen. `xcopy` ist f√ºr einfache Aufgaben ausreichend, aber `robocopy` ist das professionelle Werkzeug. üöÄ",
      "difficulty": "fortgeschritten",
      "category": "Tool-Vergleich"
    },
    {
      "question": "Szenario: Ein Admin muss ein Benutzerprofil von `C:\\Users\\Max` nach `D:\\Backup\\Max` kopieren. Es sollen alle Dateien, Unterordner (auch leere) sowie versteckte und Systemdateien mitgenommen werden. Welcher Befehl ist daf√ºr am robustesten? üïµÔ∏è",
      "options": [
        "xcopy C:\\Users\\Max D:\\Backup\\Max /e /h /k",
        "xcopy C:\\Users\\Max D:\\Backup\\Max /s /h",
        "robocopy C:\\Users\\Max D:\\Backup\\Max /e /copyall",
        "robocopy C:\\Users\\Max D:\\Backup\\Max /s"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** `robocopy` ist hier die bessere Wahl. Der Schalter `/e` kopiert alle Unterordner (auch leere). Der entscheidende Schalter ist `/copyall`, der eine Abk√ºrzung f√ºr `/copy:DATSOU` ist und **D**aten, **A**ttribute, **T**ime Stamps, **S**icherheit (NTFS ACLs), **O**wner-Infos und A**u**diting-Infos kopiert. `xcopy` mit `/h` kopiert zwar versteckte Dateien, aber nicht so umfassend wie `robocopy` mit `/copyall`. üõ°Ô∏è",
      "difficulty": "experte",
      "category": "Datensicherung"
    },
    {
      "question": "Vergleichende Analyse: Worin liegt der Hauptunterschied im Verhalten der Schalter `/s` und `/e` bei `xcopy`? ‚öñÔ∏è",
      "options": [
        "`/s` steht f√ºr 'silent', `/e` f√ºr 'error reporting'.",
        "`/s` kopiert nur Systemdateien, `/e` alle Dateien.",
        "`/s` kopiert Unterverzeichnisse, die nicht leer sind, `/e` kopiert alle Unterverzeichnisse.",
        "`/s` ist f√ºr das Quellverzeichnis, `/e` f√ºr das Zielverzeichnis."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Dies ist ein zentraler Unterschied. `/s` (Subdirectories) ist n√ºtzlich, um eine Struktur zu kopieren, aber irrelevante, leere Ordner wegzulassen. `/e` (Empty) ist erforderlich, wenn eine exakte 1:1-Kopie der Verzeichnisstruktur erstellt werden soll, inklusive aller Platzhalter- oder Log-Ordner, die initial leer sein k√∂nnten. üåø",
      "difficulty": "fortgeschritten",
      "category": "Befehlsparameter"
    },
    {
      "question": "Berechnungsaufgabe: Was ist die minimale Anzahl an Schaltern, die `xcopy` ben√∂tigt, um eine Verzeichnisstruktur inklusive leerer Ordner zu kopieren? ÔøΩ",
      "options": [
        "0",
        "1",
        "2",
        "3"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der einzige zwingend erforderliche Schalter, um auch leere Verzeichnisse zu erfassen, ist `/e`. Obwohl oft mit `/s` kombiniert (was `/e` implizit erweitert), funktioniert `/e` auch allein und erf√ºllt die Anforderung. Ein Befehl wie `xcopy C:\\A D:\\B /e` ist also g√ºltig. üí°",
      "difficulty": "einsteiger",
      "category": "Befehlssyntax"
    },
    {
      "question": "Szenario: Ein Admin f√ºhrt `xcopy C:\\daten G:\\backup /e` aus und wird gefragt: 'Gibt G:\\backup einen Dateinamen oder einen Verzeichnisnamen an (F = Datei, V = Verzeichnis)?'. Wie h√§tte der Befehl formuliert werden m√ºssen, um diese Abfrage zu verhindern? ü§´",
      "options": [
        "xcopy C:\\daten G:\\backup /e /y",
        "xcopy C:\\daten\\ G:\\backup /e",
        "xcopy C:\\daten G:\\backup\\ /e",
        "xcopy C:\\daten G:\\backup /e /q"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Die Abfrage erscheint, wenn das Zielverzeichnis nicht existiert und `xcopy` unsicher ist, ob der Zielname f√ºr eine Datei oder ein Verzeichnis steht. Durch Hinzuf√ºgen eines Backslash (`\\`) am Ende des Zielpfades (`G:\\backup\\`) wird dem Befehl eindeutig mitgeteilt, dass es sich um ein Verzeichnis handelt. Die Abfrage wird somit √ºbersprungen. ‚úÖ",
      "difficulty": "fortgeschritten",
      "category": "Befehlssyntax"
    },
    {
        "question": "Logisches R√§tsel: Ein Befehl `xcopy C:\\quelle\\*.* D:\\ziel /s` wird ausgef√ºhrt. Was passiert mit leeren Unterverzeichnissen innerhalb von `C:\\quelle`? üß©",
        "options": [
          "Sie werden kopiert, da `*.*` alle Inhalte meint.",
          "Sie werden nicht kopiert.",
          "Es kommt zu einer Fehlermeldung.",
          "Nur die leeren Verzeichnisse werden kopiert."
        ],
        "correct": 1,
        "explain": "**Begr√ºndung:** Der Schalter `/s` kopiert nur Verzeichnisse, die Dateien enthalten. Obwohl `*.*` auf alle Dateien abzielt, √§ndert dies nichts am Verhalten des `/s`-Schalters bez√ºglich der Verzeichnisse selbst. Leere Ordner werden ignoriert. Um sie zu kopieren, w√§re der Schalter `/e` erforderlich. üö´",
        "difficulty": "fortgeschritten",
        "category": "Logische Analyse"
    },
    {
        "question": "Berechnungsaufgabe: Ein Skript soll das tempor√§re Verzeichnis `C:\\Temp` mit all seinen Inhalten ohne jegliche Benutzerinteraktion l√∂schen. Welche Kombination von Schaltern f√ºr den `rd`-Befehl ist korrekt? üóëÔ∏è",
        "options": [
          "rd C:\\Temp /q",
          "rd C:\\Temp /s",
          "rd C:\\Temp /s /q",
          "del C:\\Temp /s /q"
        ],
        "correct": 2,
        "explain": "**Begr√ºndung:** `rd` (oder `rmdir`) ist der Befehl zum L√∂schen von Verzeichnissen. Der Schalter `/s` wird ben√∂tigt, um ein Verzeichnis mit Inhalt (Dateien und Unterverzeichnisse) zu l√∂schen. Der Schalter `/q` (Quiet) unterdr√ºckt die Best√§tigungsaufforderung 'Sind Sie sicher?'. Die Kombination `/s /q` ist daher der Standard f√ºr die automatisierte, unbeaufsichtigte L√∂schung von Verzeichnissen. `del` l√∂scht nur Dateien, keine Verzeichnisse. üî•",
        "difficulty": "fortgeschritten",
        "category": "Dateisystem-Management"
    },
    {
        "question": "Vergleichende Analyse: Warum wird `robocopy` gegen√ºber `xcopy` f√ºr kritische Kopiervorg√§nge √ºber instabile Netzwerkverbindungen bevorzugt? üåê",
        "options": [
          "`xcopy` hat eine eingebaute Datenkompression.",
          "`robocopy` hat eine automatische Wiederholungslogik und eine einstellbare Wartezeit zwischen den Versuchen.",
          "`xcopy` kann die Bandbreite besser ausnutzen.",
          "`robocopy` ist nur auf Server-Betriebssystemen verf√ºgbar."
        ],
        "correct": 2,
        "explain": "**Begr√ºndung:** Die Robustheit von `robocopy` zeigt sich hier deutlich. Standardm√§√üig versucht es bei einem Fehler (z.B. kurzzeitiger Netzwerkausfall) 1 Million Mal im Abstand von 30 Sekunden, die Datei zu kopieren. Diese Werte (`/r:n` und `/w:n`) sind konfigurierbar. `xcopy` bricht bei einem Fehler einfach ab. Diese Ausfallsicherheit macht `robocopy` f√ºr professionelle Eins√§tze unverzichtbar. ‚è≥",
        "difficulty": "experte",
        "category": "Netzwerk-Operationen"
    },
    {
        "question": "Szenario: Im Rahmen einer differentiellen Backup-Strategie sollen mit `xcopy` nur die Dateien kopiert werden, die seit dem letzten Backup (gekennzeichnet durch das Archiv-Attribut) ge√§ndert wurden. Welcher Schalter wird daf√ºr verwendet? üíæ",
        "options": [
          "xcopy ... /d",
          "xcopy ... /u",
          "xcopy ... /a",
          "xcopy ... /m"
        ],
        "correct": 3,
        "explain": "**Begr√ºndung:** Der Schalter `/a` kopiert nur Dateien, bei denen das Archiv-Attribut gesetzt ist, **ohne es zu √§ndern**. Der Schalter `/m` tut dasselbe, **setzt aber das Archiv-Attribut der Quelldatei zur√ºck**. F√ºr ein echtes differentielles/inkrementelles Backup-Schema ist `/m` oft die bessere Wahl, da so markiert wird, dass die Datei gesichert wurde. `/a` ist n√ºtzlich, um den Status zu pr√ºfen, ohne ihn zu ver√§ndern. üìà",
        "difficulty": "experte",
        "category": "Backup-Strategien"
    },
    {
        "question": "Logisches R√§tsel: Ein Admin f√ºhrt `xcopy C:\\A D:\\B /e` aus. Danach wird eine neue Datei in `C:\\A` hinzugef√ºgt. Nun wird der Befehl `xcopy C:\\A D:\\B /d /e` ausgef√ºhrt (ohne Datum). Was passiert? üï∞Ô∏è",
        "options": [
          "Alle Dateien werden erneut kopiert.",
          "Nur die neue Datei wird kopiert.",
          "Es wird ein Fehler angezeigt, da ein Datum fehlt.",
          "Nichts wird kopiert."
        ],
        "correct": 1,
        "explain": "**Begr√ºndung:** Der Schalter `/d` (ohne Angabe eines Datums) weist `xcopy` an, nur die Dateien zu kopieren, deren Quelldatum neuer ist als das Zieldatum. Da die bereits kopierten Dateien identische Zeitstempel haben, werden sie √ºbersprungen. Nur die neu hinzugef√ºgte Datei in `C:\\A` ist neuer als eine nicht vorhandene Datei in `D:\\B` und wird daher kopiert. Dies ist die Grundlage f√ºr einfache Synchronisierungsaufgaben. ‚úçÔ∏è",
        "difficulty": "experte",
        "category": "Synchronisation"
    },
    {
        "question": "Wahr/Falsch: Der Befehl `tree /f` zeigt nur die Verzeichnisstruktur an, aber keine der darin enthaltenen Dateien. üå≥",
        "options": [
          "Wahr",
          "Falsch"
        ],
        "correct": 1,
        "explain": "**Begr√ºndung:** Falsch. Der `tree`-Befehl allein zeigt nur die Ordnerstruktur. Der Schalter `/f` (Files) erweitert die Anzeige und listet zus√§tzlich die Dateien in jedem Verzeichnis auf. Dies ist sehr n√ºtzlich, um sich einen schnellen √úberblick √ºber den gesamten Inhalt einer Struktur zu verschaffen. üìÑ",
        "difficulty": "einsteiger",
        "category": "Grundlagen der Kommandozeile"
    },
    {
        "question": "Szenario: Ein Skript soll ein Verzeichnis `logs` auf einem Server bereinigen. Der Befehl `del D:\\logs` wird verwendet, schl√§gt aber fehl. Warum? ‚ùå",
        "options": [
          "Der `del`-Befehl ben√∂tigt den `/s`-Schalter.",
          "Der `del`-Befehl kann keine Verzeichnisse l√∂schen, nur Dateien.",
          "Der Pfad muss in Anf√ºhrungszeichen gesetzt werden.",
          "Der Befehl `del` ist veraltet; `erase` muss verwendet werden."
        ],
        "correct": 2,
        "explain": "**Begr√ºndung:** Der `del`-Befehl (oder `erase`) ist ausschlie√ülich zum L√∂schen von **Dateien** vorgesehen. Um ein Verzeichnis zu l√∂schen, muss der `rd`-Befehl (`rmdir`) verwendet werden. Wenn das Verzeichnis `logs` Dateien enth√§lt, w√§re der korrekte Befehl `rd D:\\logs /s /q`. ‚òùÔ∏è",
        "difficulty": "fortgeschritten",
        "category": "Dateisystem-Management"
    },
    {
        "question": "Vergleichende Analyse: `xcopy /d:27-08-2025` vs. `robocopy /maxage:20250827`. Was ist ein wesentlicher Unterschied in der Logik dieser beiden datumsbasierten Filter? üóìÔ∏è",
        "options": [
          "`xcopy` kopiert Dateien, die an oder nach dem Datum ge√§ndert wurden; `robocopy` kopiert Dateien, die √§lter sind als das Datum.",
          "`robocopy` ist genauer, da es die Uhrzeit ber√ºcksichtigt.",
          "`xcopy` kann nur amerikanische Datumsformate verarbeiten.",
          "Es gibt keinen logischen Unterschied, nur die Syntax ist anders."
        ],
        "correct": 0,
        "explain": "**Begr√ºndung:** Die Logik ist genau entgegengesetzt und entscheidend f√ºr den Anwendungsfall. `xcopy /d:[datum]` ist f√ºr Backups gedacht und kopiert alles, was **neu oder neuer** ist. `robocopy /maxage:[datum/tage]` ist f√ºr Aufr√§um- oder Archivierungsaufgaben gedacht und w√§hlt Dateien aus, die **√§lter** sind als das angegebene Datum (oder die Anzahl der Tage), um sie z.B. zu verschieben oder zu l√∂schen. üßπ",
        "difficulty": "experte",
        "category": "Backup-Strategien"
    },
    {
        "question": "Szenario: Ein Admin m√∂chte eine Ordnerstruktur von einem alten auf einen neuen Server spiegeln. Auf dem alten Server wurden auch Dateien gel√∂scht. Diese sollen auf dem neuen Server ebenfalls verschwinden. Welcher Befehl ist daf√ºr ideal?  –∑–µ—Ä–∫–∞–ª–æ (Spiegel) ü™û",
        "options": [
          "xcopy \\\\alt\\share \\\\neu\\share /e /d",
          "robocopy \\\\alt\\share \\\\neu\\share /e",
          "robocopy \\\\alt\\share \\\\neu\\share /mir",
          "xcopy \\\\alt\\share \\\\neu\\share /s /y"
        ],
        "correct": 2,
        "explain": "**Begr√ºndung:** Der Schalter `/mir` (Mirror) von `robocopy` ist genau f√ºr diesen Zweck konzipiert. Er ist eine Kombination aus `/e` (alle Unterverzeichnisse kopieren) und `/purge` (Dateien/Verzeichnisse im Ziel l√∂schen, die in der Quelle nicht mehr existieren). Dadurch wird das Ziel zu einem exakten Abbild der Quelle. `xcopy` hat keine vergleichbare Funktionalit√§t zum L√∂schen von √ºberz√§hligen Dateien im Ziel. ‚ö†Ô∏è **Achtung:** `/mir` kann bei falscher Anwendung Daten l√∂schen! ‚ö†Ô∏è",
        "difficulty": "fortgeschritten",
        "category": "Synchronisation"
    },
    {
        "question": "Berechnungsaufgabe: Der Befehl `xcopy C:\\A D:\\B\\ /e` wird ausgef√ºhrt. Das Verzeichnis `C:\\A` ist komplett leer. Wie viele Verzeichnisse existieren nach dem Befehl auf Laufwerk D, die durch diesen Befehl erstellt wurden (vorausgesetzt D:\\ war leer)? üìÅ",
        "options": [
          "0",
          "1",
          "2",
          "Es tritt ein Fehler auf."
        ],
        "correct": 1,
        "explain": "**Begr√ºndung:** Der Befehl weist `xcopy` an, den Inhalt von `C:\\A` in ein Verzeichnis namens `B` auf Laufwerk `D:` zu kopieren. Da `xcopy` das Zielverzeichnis erstellt, wenn es nicht existiert, wird genau **ein** Verzeichnis (`D:\\B`) angelegt. Da die Quelle `C:\\A` keine Unterverzeichnisse hat, werden auch keine weiteren Verzeichnisse innerhalb von `D:\\B` erstellt. üí°",
        "difficulty": "fortgeschritten",
        "category": "Befehlssyntax"
    },{
            "question": "üóìÔ∏è Ein Administrator f√ºhrt sonntags ein Voll-Backup durch. Am Mittwoch und am Freitag l√§uft jeweils ein differenzielles Backup. Was ist der genaue Inhalt des Backups, das am Freitag erstellt wird?",
            "options": [
                "Nur die √Ñnderungen, die zwischen Mittwoch und Freitag stattgefunden haben.",
                "Alle √Ñnderungen, die seit dem Voll-Backup am Sonntag stattgefunden haben.",
                "Alle Daten des Systems, genau wie beim Voll-Backup.",
                "Die Inhalte des Mittwoch-Backups plus die √Ñnderungen bis Freitag."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Ein **differenzielles Backup** sichert immer alle √Ñnderungen seit dem *letzten Voll-Backup*. üìÇ Das bedeutet, das Backup vom Freitag enth√§lt alle √Ñnderungen von Sonntag bis Freitag. Das Backup vom Mittwoch ist darin vollst√§ndig enthalten. Dies beschleunigt die Wiederherstellung, da nur das Voll-Backup und das letzte differenzielle Backup ben√∂tigt werden, ben√∂tigt aber mit der Zeit mehr Speicherplatz als inkrementelle Backups. üí°",
            "difficulty": "einsteiger",
            "category": "Backup-Strategien"
        },
        {
            "question": "üñ•Ô∏è Sie m√ºssen mit `xcopy` ein Verzeichnis `C:\\Daten` nach `E:\\Backup\\Daten-Backup` kopieren. Welcher Befehl stellt sicher, dass das Ziel als Verzeichnis behandelt wird und auch leere Unterverzeichnisse kopiert werden?",
            "options": [
                "xcopy C:\\Daten E:\\Backup\\Daten-Backup /e",
                "xcopy C:\\Daten E:\\Backup\\Daten-Backup\\ /e",
                "xcopy C:\\Daten E:\\Backup\\Daten-Backup /s",
                "robocopy C:\\Daten E:\\Backup\\Daten-Backup /e"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Backslash `\\` am Ende des Zielpfades (`E:\\Backup\\Daten-Backup\\`) ist ein entscheidender Hinweis f√ºr `xcopy`, dass das Ziel ein Verzeichnis ist. Ohne diesen Backslash w√ºrde `xcopy` nachfragen, ob es sich um eine Datei oder ein Verzeichnis handelt. üìÅ Der Schalter `/e` sorgt daf√ºr, dass alle Unterverzeichnisse, auch leere, mitkopiert werden. `/s` w√ºrde leere Verzeichnisse ignorieren. Option D verwendet `robocopy`, was die Frage nach `xcopy` nicht beantwortet.",
            "difficulty": "einsteiger",
            "category": "xcopy-Befehl"
        },
        {
            "question": "üîÑ Was ist der prim√§re Vorteil einer **inkrementellen** Backup-Strategie gegen√ºber einer **differenziellen**?",
            "options": [
                "Die Wiederherstellung von Daten ist deutlich schneller.",
                "Es wird insgesamt weniger Speicherplatz f√ºr die einzelnen Backups ben√∂tigt.",
                "Es ist keine Voll-Backup-Basis notwendig.",
                "Die einzelnen Backup-Vorg√§nge dauern l√§nger, sind aber sicherer."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Hauptvorteil inkrementeller Backups ist der geringere Speicherbedarf. üíæ Jedes inkrementelle Backup sichert nur die √Ñnderungen seit dem *letzten Backup* (egal ob voll oder inkrementell). Ein differenzielles Backup sichert immer alle √Ñnderungen seit dem *letzten Voll-Backup*, wodurch die Backup-Dateien mit der Zeit anwachsen. Der Nachteil der inkrementellen Methode ist die langsamere und komplexere Wiederherstellung, da das Voll-Backup und *alle* nachfolgenden inkrementellen Backups in der richtigen Reihenfolge ben√∂tigt werden. ‚õìÔ∏è",
            "difficulty": "fortgeschritten",
            "category": "Backup-Strategien"
        },
        {
            "question": "‚öôÔ∏è Ein Admin m√∂chte alle Dateien sichern, die in den letzten 2 Tagen ge√§ndert wurden. Welcher `robocopy`-Befehl ist daf√ºr am besten geeignet und am flexibelsten f√ºr automatisierte Skripte?",
            "options": [
                "robocopy Quelle Ziel /d:08-01-2021",
                "robocopy Quelle Ziel /maxage:2",
                "xcopy Quelle Ziel /d:08-01-2021",
                "robocopy Quelle Ziel /minage:2"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `robocopy` mit dem Parameter `/maxage:2` ist ideal f√ºr diese Aufgabe. `maxage` steht f√ºr 'maximales Alter' und kopiert alle Dateien, deren letztes √Ñnderungsdatum nicht √§lter als 2 Tage ist. üóìÔ∏è Dies ist flexibler als ein festes Datum (`/d:` bei `xcopy`), da das Skript jeden Tag ohne Anpassung des Datums laufen kann. `/minage:2` w√ºrde das Gegenteil tun und nur Dateien kopieren, die *√§lter* als 2 Tage sind.",
            "difficulty": "fortgeschritten",
            "category": "robocopy-Befehl"
        },
        {
            "question": "üìâ Ein Server hat 100 GB Daten. Am Sonntag wird ein Voll-Backup erstellt. Von Montag bis Freitag √§ndern sich t√§glich 5 GB an Daten. Wie viel Speicherplatz belegt das **differenzielle** Backup, das am Freitagabend erstellt wird?",
            "options": [
                "5 GB",
                "10 GB",
                "25 GB",
                "125 GB"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Bei einem differenziellen Backup werden alle √Ñnderungen seit dem letzten Voll-Backup gesichert. üìà\n- Montag: 5 GB ge√§ndert\n- Dienstag: +5 GB ge√§ndert (insgesamt 10 GB seit Sonntag)\n- Mittwoch: +5 GB ge√§ndert (insgesamt 15 GB seit Sonntag)\n- Donnerstag: +5 GB ge√§ndert (insgesamt 20 GB seit Sonntag)\n- Freitag: +5 GB ge√§ndert (insgesamt **25 GB** seit Sonntag)\nDas Backup vom Freitag enth√§lt also alle √Ñnderungen der gesamten Woche.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "üìà Nehmen wir das gleiche Szenario: 100 GB Daten, Voll-Backup am Sonntag, 5 GB t√§gliche √Ñnderungen. Wie viel Speicherplatz belegt das **inkrementelle** Backup, das am Freitagabend erstellt wird?",
            "options": [
                "5 GB",
                "15 GB",
                "25 GB",
                "20 GB"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Ein inkrementelles Backup sichert nur die √Ñnderungen seit dem *letzten* Backup. ‚û°Ô∏è Da am Donnerstag bereits ein Backup lief (das die √Ñnderungen vom Donnerstag sicherte), sichert das Backup am Freitag nur die √Ñnderungen, die am Freitag selbst stattgefunden haben. Das sind genau **5 GB**.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "üîç Ein `xcopy`-Befehl enth√§lt den Schalter `/c`. Was ist die genaue Funktion dieses Schalters w√§hrend des Kopiervorgangs?",
            "options": [
                "Er √ºberpr√ºft (`check`) jede kopierte Datei auf Korrektheit.",
                "Er komprimiert (`compress`) die Dateien w√§hrend der √úbertragung.",
                "Er setzt den Kopiervorgang fort, auch wenn Fehler auftreten (`continue`).",
                "Er erstellt (`create`) das Zielverzeichnis, falls es nicht existiert."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Schalter `/c` steht f√ºr 'continue'. Er weist `xcopy` an, den Kopiervorgang auch dann fortzusetzen, wenn einzelne Dateien nicht gelesen oder geschrieben werden k√∂nnen (z.B. wegen fehlender Berechtigungen oder Lesefehlern). üõ°Ô∏è Dies ist in Backup-Skripten extrem wichtig, um sicherzustellen, dass der gesamte Prozess nicht wegen einer einzelnen fehlerhaften Datei abbricht. Die √úberpr√ºfung (`/v`) und das Erstellen von Verzeichnissen sind andere Funktionen.",
            "difficulty": "einsteiger",
            "category": "xcopy-Befehl"
        },
        {
            "question": "üß© Ein Systemcrash ereignet sich am Samstag. Sie haben ein Voll-Backup von Sonntag und **inkrementelle** Backups von Dienstag, Mittwoch und Freitag. In welcher Reihenfolge m√ºssen Sie die Backups zur vollst√§ndigen Wiederherstellung einspielen?",
            "options": [
                "Voll-Backup -> Freitag -> Mittwoch -> Dienstag",
                "Nur Voll-Backup und das Freitags-Backup",
                "Voll-Backup -> Dienstag -> Mittwoch -> Freitag",
                "Freitag -> Mittwoch -> Dienstag -> Voll-Backup"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Bei einer inkrementellen Sicherung baut jedes Backup auf dem vorherigen auf. üî¢ F√ºr eine vollst√§ndige Wiederherstellung muss die Kette l√ºckenlos und in chronologischer Reihenfolge wiederhergestellt werden. Zuerst wird die Basis (das **Voll-Backup** vom Sonntag) eingespielt, danach jedes einzelne inkrementelle Backup in der Reihenfolge seiner Erstellung (**Dienstag, dann Mittwoch, dann Freitag**). Das Auslassen eines Backups w√ºrde zu Datenverlust f√ºhren.",
            "difficulty": "fortgeschritten",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "‚öñÔ∏è Wahr oder Falsch: Der Befehl `xcopy Quelle Ziel /a` kopiert nur Dateien mit gesetztem Archiv-Attribut und setzt dieses Attribut nach dem Kopiervorgang zur√ºck.",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. Der Schalter `/a` kopiert zwar nur Dateien, bei denen das Archiv-Attribut gesetzt ist, aber er **ver√§ndert dieses Attribut nicht**. üïµÔ∏è‚Äç‚ôÇÔ∏è Der Schalter, der das Attribut nach dem Kopieren zur√ºcksetzt (l√∂scht), ist `/m`. Dieser feine Unterschied ist entscheidend f√ºr die Implementierung von Backup-Strategien. `/m` wird typischerweise f√ºr inkrementelle Backups verwendet, um zu markieren, dass eine Datei gesichert wurde, w√§hrend `/a` f√ºr differenzielle Backups n√ºtzlich sein kann, ohne den Status zu ver√§ndern.",
            "difficulty": "experte",
            "category": "Wahr/Falsch mit komplexer Begr√ºndung"
        },
        {
            "question": "üÜö Worin liegt der entscheidende Vorteil von `robocopy` gegen√ºber `xcopy`, wenn es um das Kopieren in ein nicht existentes Zielverzeichnis geht?",
            "options": [
                "robocopy ist schneller bei der Verzeichniserstellung.",
                "xcopy kann keine neuen Verzeichnisse erstellen.",
                "robocopy erstellt das Zielverzeichnis automatisch, ohne Nachfrage oder spezielle Schalter.",
                "xcopy ben√∂tigt den /i-Schalter, den robocopy nicht hat."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `robocopy` ist explizit f√ºr das Kopieren von Verzeichnisstrukturen konzipiert. Es erkennt automatisch, dass das Ziel ein Verzeichnis ist und erstellt die gesamte notwendige Pfadstruktur ohne weitere Interaktion. ‚úÖ `xcopy` hingegen w√ºrde nachfragen, ob das Ziel eine Datei oder ein Verzeichnis ist, es sei denn, man gibt dies explizit durch einen Backslash am Ende des Pfades an oder verwendet den `/i`-Schalter. Diese Automatik macht `robocopy` f√ºr Skripte deutlich robuster.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "üí° Ein automatisiertes Skript soll t√§glich alle Dateien sichern, die das Archiv-Attribut gesetzt haben. Welcher Befehl ist daf√ºr am besten geeignet, um eine **echte inkrementelle Sicherung** zu realisieren?",
            "options": [
                "xcopy Quelle Ziel /a /e",
                "robocopy Quelle Ziel /a /e",
                "xcopy Quelle Ziel /m /e",
                "robocopy Quelle Ziel /e"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** F√ºr eine echte inkrementelle Sicherung auf Basis des Archiv-Attributs ist `xcopy /m` (oder `robocopy /m`) die korrekte Wahl. Der Schalter `/m` kopiert nur Dateien mit gesetztem Archiv-Attribut und **l√∂scht dieses Attribut nach dem erfolgreichen Kopiervorgang**. üö© Dadurch wird sichergestellt, dass die Datei beim n√§chsten Lauf des Skripts nicht erneut kopiert wird, es sei denn, sie wurde in der Zwischenzeit wieder ver√§ndert (wodurch das Betriebssystem das Attribut neu setzt). `/a` w√ºrde die Datei bei jedem Lauf erneut kopieren.",
            "difficulty": "experte",
            "category": "Datensicherungspraxis"
        },
        {
            "question": "üóÇÔ∏è Welchen gemeinsamen Zweck haben der Schalter `/e` bei `xcopy` und `robocopy`?",
            "options": [
                "Fehler zu ignorieren (Error handling).",
                "Dateien zu exkludieren (Exclude).",
                "Leere Verzeichnisse mitzukopieren (Empty directories).",
                "Existierende Dateien zu √ºberschreiben (Existing files)."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** In beiden Befehlen steht `/e` f√ºr 'empty' und erweitert die Funktionalit√§t des Kopierens von Unterverzeichnissen. Es stellt sicher, dass **alle Unterverzeichnisse, einschlie√ülich der leeren**, in die Zieldestination √ºbernommen werden. üå≥ Dies ist wichtig, um eine exakte Kopie einer Verzeichnisstruktur zu erhalten, da oft auch leere Ordner eine funktionale Bedeutung haben.",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "üî• Ein Admin stellt fest, dass sein differenzielles Backup vom Mittwoch besch√§digt und unbrauchbar ist. Am Freitag l√§uft das n√§chste planm√§√üige differenzielle Backup. Kann er am Samstag eine vollst√§ndige Wiederherstellung durchf√ºhren?",
            "options": [
                "Nein, weil die Kette durch das defekte Backup unterbrochen ist.",
                "Ja, weil nur das Voll-Backup und das letzte funktionierende differenzielle Backup ben√∂tigt werden.",
                "Ja, aber nur die Daten bis Dienstag k√∂nnen wiederhergestellt werden.",
                "Nein, es muss sofort ein neues Voll-Backup erstellt werden."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Ja, das ist einer der gro√üen Vorteile der differenziellen Strategie. Jedes differenzielle Backup enth√§lt *alle* √Ñnderungen seit dem letzten Voll-Backup. ‚úÖ Das bedeutet, das funktionierende Backup vom Freitag enth√§lt auch alle √Ñnderungen, die im defekten Mittwoch-Backup enthalten gewesen w√§ren. Zur Wiederherstellung ben√∂tigt man also nur das **Voll-Backup vom Sonntag** und das **funktionierende differenzielle Backup vom Freitag**. Das defekte Backup vom Mittwoch ist irrelevant.",
            "difficulty": "experte",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "‚è≥ Eine Datei wurde vor 5 Tagen erstellt und zuletzt vor 2 Tagen ge√§ndert. Ein `robocopy`-Skript mit dem Parameter `/maxage:3` wird heute ausgef√ºhrt. Wird die Datei kopiert?",
            "options": [
                "Nein, weil die Datei √§lter als 3 Tage ist.",
                "Ja, weil das letzte √Ñnderungsdatum innerhalb des 3-Tage-Fensters liegt.",
                "Nein, weil /maxage sich auf das Erstellungsdatum bezieht.",
                "Ja, aber nur, wenn auch der /a Schalter gesetzt ist."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Parameter `/maxage` von `robocopy` bezieht sich auf das Datum der **letzten √Ñnderung**, nicht auf das Erstellungsdatum. ‚úçÔ∏è Da die Datei vor 2 Tagen zuletzt ge√§ndert wurde, ist sie 'j√ºnger' als die im Befehl angegebene Grenze von 3 Tagen. Daher wird die Datei kopiert. Das urspr√ºngliche Erstellungsdatum ist f√ºr diesen Parameter irrelevant.",
            "difficulty": "experte",
            "category": "robocopy-Befehl"
        },
        {
            "question": "‚ö†Ô∏è Laut dem Text bietet `robocopy` einen entscheidenden Vorteil f√ºr die Nachverfolgung von Backup-Vorg√§ngen, insbesondere wenn diese unbeaufsichtigt (z.B. am Wochenende) laufen. Welcher Vorteil ist das?",
            "options": [
                "Es sendet automatisch eine E-Mail-Benachrichtigung.",
                "Es ist von Natur aus fehlerfrei.",
                "Es kann eine detaillierte Log-Datei erstellen.",
                "Es √ºberpr√ºft die Datenintegrit√§t mit Checksummen."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Text hebt hervor, dass `robocopy` die M√∂glichkeit bietet, eine **Log-Datei** zu erstellen. üìù Mit Schaltern wie `/log:datei.log` kann der gesamte Kopiervorgang, inklusive aller Erfolgsmeldungen, Fehler und einer Zusammenfassung, in eine Textdatei geschrieben werden. Dies erm√∂glicht es Administratoren, am Montagmorgen zu √ºberpr√ºfen, ob der Wochenend-Backup-Job erfolgreich war, ohne die gesamte Konsolenausgabe durchsuchen zu m√ºssen.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "ü§î Warum ist der Befehl `xcopy Quelle Ziel /d:mm-tt-jjjj /e /c /v` eine Implementierung einer **differenziellen** und nicht einer inkrementellen Sicherung?",
            "options": [
                "Weil der Schalter /v eine vollst√§ndige √úberpr√ºfung durchf√ºhrt.",
                "Weil das Datum fest ist und sich nicht auf das letzte Backup bezieht.",
                "Weil der Schalter /c Fehler ignoriert, was typisch f√ºr differenzielle Backups ist.",
                "Weil der Schalter /a fehlt."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der entscheidende Punkt ist der Schalter `/d:mm-tt-jjjj`. Er weist `xcopy` an, alle Dateien zu kopieren, die an oder nach diesem **festen Datum** ge√§ndert wurden. üìå Wenn dieses Datum das Datum des letzten Voll-Backups ist, werden bei jedem Lauf alle seitdem ge√§nderten Dateien kopiert ‚Äì die genaue Definition eines differenziellen Backups. F√ºr ein inkrementelles Backup m√ºsste der Zustand (z.B. √ºber das Archiv-Attribut mit `/m`) nach jedem Lauf ver√§ndert werden, um nur die √Ñnderungen seit dem *letzten* Lauf zu sichern.",
            "difficulty": "experte",
            "category": "Datensicherungspraxis"
        },
        {
            "question": "üíæ Ein Unternehmen sichert 1 TB an Daten. Ein Voll-Backup wird sonntags erstellt. Von Montag bis Freitag fallen t√§glich 20 GB an neuen/ge√§nderten Daten an. Wie viel Speicherplatz wird **insgesamt** f√ºr die Sicherungen von Montag bis Freitag bei einer **inkrementellen** Strategie ben√∂tigt?",
            "options": [
                "20 GB",
                "100 GB",
                "300 GB",
                "1.1 TB"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Bei einer inkrementellen Strategie wird jeden Tag nur der Zuwachs seit dem Vortag gesichert. ‚ûï\n- Montag: 20 GB\n- Dienstag: 20 GB\n- Mittwoch: 20 GB\n- Donnerstag: 20 GB\n- Freitag: 20 GB\nDie Gesamtmenge des ben√∂tigten Speichers f√ºr die Wochentags-Backups ist die Summe der einzelnen Teile: 5 Tage * 20 GB/Tag = **100 GB**.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "üíΩ Im selben Szenario (1 TB Daten, 20 GB t√§gliche √Ñnderung), wie viel Speicherplatz wird **insgesamt** f√ºr die Sicherungen von Montag bis Freitag bei einer **differenziellen** Strategie ben√∂tigt?",
            "options": [
                "100 GB",
                "200 GB",
                "300 GB",
                "400 GB"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Bei einer differenziellen Strategie w√§chst die Gr√∂√üe des t√§glichen Backups an. üìà\n- Montag: 20 GB\n- Dienstag: 40 GB (√Ñnderungen von Mo+Di)\n- Mittwoch: 60 GB (Mo+Di+Mi)\n- Donnerstag: 80 GB (Mo-Do)\n- Freitag: 100 GB (Mo-Fr)\nDie Gesamtmenge des belegten Speichers ist die Summe dieser einzelnen Backups: 20 + 40 + 60 + 80 + 100 = **300 GB**.",
            "difficulty": "experte",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "üöÄ Welche Backup-Methode bietet typischerweise die **schnellsten einzelnen Backup-Vorg√§nge** w√§hrend der Woche, aber die **langsamste und komplexeste Wiederherstellung**?",
            "options": [
                "Voll-Backup",
                "Differenzielles Backup",
                "Inkrementelles Backup",
                "Spiegelung (Mirroring)"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Das **inkrementelle Backup** ist w√§hrend der Woche am schnellsten, da t√§glich nur die geringste Datenmenge (die √Ñnderungen seit dem Vortag) gesichert werden muss. üí® Die Wiederherstellung ist jedoch am langsamsten und fehleranf√§lligsten, da zuerst das Voll-Backup und dann jedes einzelne inkrementelle Backup in der korrekten Reihenfolge eingespielt werden muss. Ein Fehler in dieser Kette kompromittiert die gesamte Wiederherstellung. üê¢",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "üìú Wahr oder Falsch: `robocopy` ist, genau wie `xcopy`, eine 32-Bit-Anwendung, die sich im Verzeichnis `C:\\Windows\\System32` befindet und direkt in der CMD aufgerufen werden kann.",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Wahr. Der Text erw√§hnt explizit, dass `robocopy.exe` sich, wie `xcopy.exe`, im System32-Verzeichnis befindet. ‚úÖ Obwohl moderne Windows-Versionen 64-Bit sind, werden viele dieser klassischen Kommandozeilen-Tools aus Kompatibilit√§tsgr√ºnden weiterhin als 32-Bit- (oder inzwischen auch als 64-Bit-) Anwendungen ausgeliefert und sind √ºber den System-PATH direkt in jeder Kommandozeile verf√ºgbar.",
            "difficulty": "einsteiger",
            "category": "Wahr/Falsch mit komplexer Begr√ºndung"
        }
    ]
}
