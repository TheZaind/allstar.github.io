{
    "questions": [
        {
            "question": "Ein Junior-Administrator soll ein Verzeichnis aller `.log`-Dateien auf Laufwerk `D:` erstellen und in der Datei `audit.txt` speichern. Er f√ºhrt den Befehl `dir d:\\*.log > audit.txt` aus. Am n√§chsten Tag soll er die neuen Log-Dateien an die bestehende `audit.txt` anh√§ngen. Welchen Befehl muss er verwenden, um die alten Eintr√§ge nicht zu √ºberschreiben? üìú",
            "options": [
                "dir d:\\*.log > audit.txt",
                "dir d:\\*.log | audit.txt",
                "dir d:\\*.log >> audit.txt",
                "dir d:\\*.log + audit.txt"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Operator `>>` wird als Anh√§ngesymbol verwendet. Er leitet die Ausgabe eines Befehls in eine Datei um und f√ºgt sie am Ende der Datei an, ohne den vorhandenen Inhalt zu l√∂schen. \n- **`>` (Umleitungssymbol):** W√ºrde die `audit.txt` komplett √ºberschreiben. ‚ùå\n- **`|` (Pipe):** Verkettet Befehle, indem es die Ausgabe des ersten Befehls als Eingabe f√ºr den zweiten verwendet, was hier nicht zielf√ºhrend ist. ‚ùå\n- **`+` (Zusammenf√ºhrungssymbol):** Wird prim√§r beim `copy`-Befehl verwendet, um Dateien zu kombinieren, nicht zur Umleitung von Befehlsausgaben. ‚ùå\nüí° Dieses Wissen ist entscheidend f√ºr das Logging und die Protokollierung in Skripten.",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Sie m√∂chten einen neuen 64 GB USB-Stick f√ºr die Windows-Installation vorbereiten. Der Stick muss eine einzelne, aktive prim√§re Partition enthalten, die mit NTFS formatiert ist. Welche `diskpart`-Befehlssequenz ist korrekt und vollst√§ndig? üõ†Ô∏è",
            "options": [
                "select disk 1, create partition primary, active, format fs=ntfs, assign",
                "list disk, select disk 1, clean, create partition primary, active, format fs=ntfs quick, assign",
                "list disk, select disk 1, clean, create partition, format, assign letter=e",
                "select disk 1, format fs=ntfs quick, active, assign"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die korrekte Reihenfolge ist entscheidend. Zuerst muss der Datentr√§ger mit `list disk` identifiziert und mit `select disk X` ausgew√§hlt werden. `clean` entfernt alle vorhandenen Partitionierungsinformationen. Danach wird mit `create partition primary` eine prim√§re Partition erstellt, mit `active` als bootf√§hig markiert, mit `format fs=ntfs quick` schnell formatiert und schlie√ülich mit `assign` ein Laufwerksbuchstabe zugewiesen. \n- **Option A:** Vergisst `list disk` und `clean`, was zu Fehlern f√ºhren kann, wenn der Stick nicht leer ist. ‚ùå\n- **Option C:** Ist zu unpr√§zise (`create partition` ohne 'primary', `format` ohne Dateisystem). ‚ùå\n- **Option D:** Versucht zu formatieren, bevor eine Partition erstellt wurde. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Ein Server soll w√∂chentlich einen Integrit√§tscheck der Systemfestplatte (C:) durchf√ºhren und eventuelle Fehler automatisch beheben. Der Report soll nicht am Bildschirm angezeigt, sondern in eine Log-Datei geschrieben werden. Welcher Befehl ist daf√ºr am besten geeignet? ‚öôÔ∏è",
            "options": [
                "chkdsk c: /f > nul",
                "chkdsk c: /r",
                "format c: /q",
                "diskpart detail disk > log.txt"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Der Befehl `chkdsk c: /f` pr√ºft das Laufwerk C: auf Fehler und behebt (`/f`) diese. Die Umleitung `> nul` unterdr√ºckt die Ausgabe auf der Konsole, was f√ºr automatisierte Skripts ideal ist, um den Bildschirm sauber zu halten. \n- **`/r`:** Sucht zus√§tzlich nach fehlerhaften Sektoren und stellt lesbare Informationen wieder her, was deutlich l√§nger dauert und f√ºr einen schnellen Check oft nicht n√∂tig ist. ‚ùå\n- **`format c:`:** W√ºrde die Systemfestplatte formatieren und das Betriebssystem l√∂schen.  –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞! ‚ùå\n- **`diskpart detail disk`:** Liefert nur Informationen √ºber den Datentr√§ger, f√ºhrt aber keine Fehlerpr√ºfung oder -korrektur durch. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Wahr oder Falsch: Der Befehl `clean` in `diskpart` ist eine sichere Methode, um sensible Daten unwiederbringlich zu l√∂schen, da er alle Sektoren der Festplatte √ºberschreibt. üîí",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. Der `clean`-Befehl l√∂scht lediglich die MBR- oder GPT-Partitionierungsinformationen vom Datentr√§ger. Die eigentlichen Daten bleiben physisch auf der Festplatte erhalten und k√∂nnen mit Datenrettungstools oft wiederhergestellt werden. Nur der Befehl `clean all` √ºberschreibt jeden Sektor mit Nullen und sorgt f√ºr ein sicheres L√∂schen (‚ÄûSecure Erase‚Äú). üí° Dies ist ein kritischer Unterschied im Kontext der Datensicherheit.",
            "difficulty": "experte",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "Vergleichen Sie die Befehle `del` und `rd`. Welches Szenario beschreibt den korrekten Einsatz der beiden Befehle? üóëÔ∏è",
            "options": [
                "`del` l√∂scht Verzeichnisse und `rd` l√∂scht Dateien.",
                "Beide k√∂nnen Dateien und leere Verzeichnisse l√∂schen.",
                "`del` l√∂scht eine oder mehrere Dateien, w√§hrend `rd` ein leeres Verzeichnis l√∂scht.",
                "`rd` l√∂scht ein Verzeichnis inklusive aller Unterverzeichnisse und Dateien, `del` nur einzelne Dateien."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die Trennung ist klar definiert: `del` (delete) ist f√ºr das L√∂schen von Dateien zust√§ndig. `rd` (remove directory) ist f√ºr das Entfernen von Verzeichnissen zust√§ndig. Standardm√§√üig kann `rd` nur leere Verzeichnisse l√∂schen. Um ein Verzeichnis samt Inhalt zu l√∂schen, ben√∂tigt man den Schalter `/s` (z.B. `rd /s meinverzeichnis`).\n- **Option A:** Ist genau umgekehrt. ‚ùå\n- **Option B:** `del` kann keine Verzeichnisse l√∂schen. ‚ùå\n- **Option D:** `rd` l√∂scht ohne den Schalter `/s` eben nicht den Inhalt mit. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie haben einen Ordner mit hunderten von Bilddateien (JPG) und Textdokumenten (TXT). Sie m√∂chten alle JPG-Dateien in einen Unterordner namens `Bilder` verschieben. Welcher Befehl ist am effizientesten? üìÇ",
            "options": [
                "copy *.jpg Bilder\\",
                "move *.jpg Bilder",
                "xcopy *.jpg Bilder\\ /s",
                "ren *.jpg *.bak"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `move`-Befehl ist f√ºr das Verschieben von Dateien und Verzeichnissen konzipiert. Er ist effizienter als `copy` gefolgt von `del`, da die Dateidaten nicht physisch kopiert, sondern nur der Verzeichniseintrag im Dateisystem ge√§ndert wird (solange es auf demselben Volume geschieht).\n- **`copy`:** W√ºrde die Dateien nur kopieren, die Originale blieben erhalten. ‚ùå\n- **`xcopy`:** Ist f√ºr das Kopieren von Verzeichnisstrukturen gedacht und hier unn√∂tig komplex. ‚ùå\n- **`ren`:** W√ºrde die Dateien nur umbenennen, nicht verschieben. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Ein Skript soll die Ausgabe eines langen Befehls erzeugen, aber der Benutzer soll diese Ausgabe nicht auf dem Bildschirm sehen, um die Konsole √ºbersichtlich zu halten. Welcher Befehlsteil erreicht dies? üôà",
            "options": [
                "| more",
                "> nul",
                "/p",
                "| clip"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die Umleitung `> nul` sendet die Standardausgabe (STDOUT) eines Befehls an das `nul`-Ger√§t, welches ein virtuelles Ger√§t ist, das alle empfangenen Daten verwirft. Dadurch wird die Ausgabe effektiv unterdr√ºckt. \n- **`| more`:** H√§lt die Ausgabe seitenweise an, zeigt sie aber an. ‚ùå\n- **`/p`:** Ist ein Schalter vieler Befehle (wie `dir`), um die Ausgabe zu pausieren, zeigt sie aber ebenfalls an. ‚ùå\n- **`| clip`:** Leitet die Ausgabe in die Zwischenablage um, nicht ins Nichts. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Welchen entscheidenden Vorteil bietet `PowerShell` gegen√ºber der klassischen `CMD.EXE`, der in den Unterlagen angedeutet wird? üöÄ",
            "options": [
                "PowerShell ist abw√§rtskompatibler zu MS-DOS.",
                "PowerShell-Befehle sind immer k√ºrzer und einfacher zu merken.",
                "PowerShell arbeitet mit Objekten statt mit reinem Text, was eine m√§chtigere Verarbeitung und Skripterstellung erm√∂glicht.",
                "CMD.EXE kann keine Netzwerkoperationen durchf√ºhren, PowerShell schon."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der fundamentale Unterschied und gr√∂√üte Vorteil von PowerShell ist die objektorientierte Pipeline. W√§hrend CMD Textzeilen von einem Befehl zum n√§chsten weitergibt, reicht PowerShell strukturierte .NET-Objekte weiter. Dies erlaubt eine wesentlich komplexere und zuverl√§ssigere Verarbeitung von Daten in Skripten. CMD kann durchaus Netzwerkbefehle wie `ping` oder `ipconfig` ausf√ºhren. PowerShell ist eine modernere, aber nicht zwangsl√§ufig abw√§rtskompatiblere oder immer k√ºrzere Alternative.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie befinden sich im Verzeichnis `C:\\Users\\Admin\\Documents`. Welcher einzelne Befehl bringt Sie direkt zum Wurzelverzeichnis von Laufwerk C:? üå≥",
            "options": [
                "cd ..",
                "cd /",
                "cd \\",
                "cd c:"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `cd \\` (change directory mit Backslash) wechselt immer in das Wurzelverzeichnis des aktuellen Laufwerks. \n- **`cd ..`:** Wechselt nur eine Ebene nach oben (zu `C:\\Users\\Admin`). ‚ùå\n- **`cd /`:** Der Slash `/` wird in CMD prim√§r f√ºr Schalter/Optionen verwendet, nicht f√ºr die Pfadnavigation wie in Linux. ‚ùå\n- **`cd c:`:** Zeigt nur den aktuellen Pfad auf Laufwerk C: an, wechselt aber nicht das Verzeichnis, wenn man sich bereits auf C: befindet. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Ein Kollege hat mit `diskpart` eine Partition gel√∂scht, aber der Speicherplatz wurde nicht wie erwartet dem benachbarten Volume hinzugef√ºgt. Welcher `diskpart`-Befehl ist notwendig, um den freien Speicherplatz einer vorhandenen Partition zuzuweisen? ‚ûï",
            "options": [
                "assign",
                "create",
                "merge",
                "extend"
            ],
            "correct": 3,
            "explain": "**Begr√ºndung:** Der `extend`-Befehl wird in `diskpart` verwendet, um ein Volume oder eine Partition in den n√§chsten zusammenh√§ngenden, nicht zugeordneten Speicherplatz auf demselben Datentr√§ger zu erweitern. Man muss zuerst das Volume ausw√§hlen (`select volume X`) und kann es dann mit `extend` vergr√∂√üern. \n- **`assign`:** Weist nur einen Laufwerksbuchstaben zu. ‚ùå\n- **`create`:** Erstellt eine neue Partition im freien Speicher. ‚ùå\n- **`merge`:** F√ºhrt untergeordnete virtuelle Datentr√§ger zusammen, was hier nicht relevant ist. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Welche Funktion haben die Platzhalter `*` und `?` in der CMD? W√§hlen Sie die pr√§ziseste Definition. üß©",
            "options": [
                "`*` steht f√ºr ein beliebiges Zeichen, `?` f√ºr eine beliebige Zeichenkette.",
                "`*` steht f√ºr eine beliebige Zeichenkette (auch keine), `?` steht f√ºr genau ein beliebiges Zeichen.",
                "`*` steht f√ºr Zahlen, `?` f√ºr Buchstaben.",
                "Beide stehen f√ºr eine beliebige Anzahl von beliebigen Zeichen."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Dies ist eine fundamentale Regel der Wildcard-Nutzung. Der Stern (`*`) ist der 'gierige' Platzhalter f√ºr null oder mehr beliebige Zeichen. Das Fragezeichen (`?`) ist der pr√§zise Platzhalter f√ºr exakt ein beliebiges Zeichen. Ein Beispiel: `datei?.txt` findet `datei1.txt` und `dateiA.txt`, aber nicht `datei10.txt` oder `datei.txt`. `datei*.txt` w√ºrde sie alle finden.",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie m√∂chten eine Textdatei namens `setup.txt` direkt in der Kommandozeile erstellen und den Text 'Installation_Start' hineinschreiben. Welcher Befehl und welche Aktion beenden den Schreibvorgang korrekt? ‚úçÔ∏è",
            "options": [
                "type > setup.txt, dann 'Installation_Start' tippen und mit ESC beenden.",
                "md setup.txt, dann 'Installation_Start' tippen und mit Enter beenden.",
                "copy con setup.txt, dann 'Installation_Start' tippen und mit Strg+Z gefolgt von Enter beenden.",
                "edit setup.txt, dann 'Installation_Start' tippen und mit F3 speichern."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `copy con` (copy from console) leitet die Konsoleneingabe in eine Datei um. Nach der Eingabe des Textes wird der Vorgang durch das Senden des 'End-of-File'-Zeichens (EOF) abgeschlossen, was in Windows durch die Tastenkombination `Strg+Z` und anschlie√üendes Dr√ºcken von `Enter` geschieht. \n- **Option A, B, D:** Sind syntaktisch falsche oder unpassende Befehle f√ºr diesen Zweck. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datei-Befehle"
        },
        {
            "question": "Sie geben den Befehl `help | more` ein. Was ist die genaue Funktion des Pipe-Symbols `|` in diesem Kontext? ‚õìÔ∏è",
            "options": [
                "Es leitet die Hilfe-Ausgabe in eine Datei namens 'more' um.",
                "Es startet den 'more'-Befehl parallel zum 'help'-Befehl.",
                "Es sorgt daf√ºr, dass die sehr lange Ausgabe des 'help'-Befehls seitenweise durch den 'more'-Befehl angezeigt wird.",
                "Es f√ºgt den Inhalt der Datei 'more' an die Hilfe-Ausgabe an."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Das Pipe-Symbol `|` ist ein Verkettungssymbol. Es nimmt die Standardausgabe (STDOUT) des Befehls links von der Pipe und verwendet sie als Standardeingabe (STDIN) f√ºr den Befehl rechts von der Pipe. Hier wird die komplette Liste aller Befehle von `help` an `more` weitergeleitet, welcher die Eingabe dann seitenweise anzeigt und auf eine Benutzereingabe wartet, um zur n√§chsten Seite zu bl√§ttern.",
            "difficulty": "fortgeschritten",
            "category": "Befehlssyntax"
        },
        {
            "question": "Ein Techniker m√∂chte die Volumebezeichnung eines USB-Sticks (Laufwerk E:) von 'TRANSCEND' auf 'BACKUP' √§ndern. Welcher Befehl ist daf√ºr direkt und ohne weitere Umwege vorgesehen? üè∑Ô∏è",
            "options": [
                "ren e: BACKUP",
                "label e: BACKUP",
                "vol e: BACKUP",
                "attrib e: +L BACKUP"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `label`-Befehl ist speziell daf√ºr vorgesehen, die Datentr√§gerbezeichnung (das Volume Label) eines Laufwerks zu erstellen, zu √§ndern oder zu l√∂schen. \n- **`ren`:** Dient zum Umbenennen von Dateien und Verzeichnissen, nicht von Laufwerken. ‚ùå\n- **`vol`:** Zeigt nur die aktuelle Bezeichnung an, kann sie aber nicht √§ndern. ‚ùå\n- **`attrib`:** Modifiziert Dateiattribute (wie schreibgesch√ºtzt, versteckt etc.), nicht die Volumebezeichnung. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Datentr√§ger-Befehle"
        },
        {
            "question": "Wahr oder Falsch: Der Befehl `cd Ordner1\\Ordner2` ist ein Beispiel f√ºr die Verwendung eines relativen Pfades. üõ§Ô∏è",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Wahr. Ein relativer Pfad geht vom aktuellen Verzeichnis aus. Wenn Sie sich z.B. in `C:\\Daten` befinden, w√ºrde `cd Ordner1\\Ordner2` versuchen, in das Verzeichnis `C:\\Daten\\Ordner1\\Ordner2` zu wechseln. Ein absoluter Pfad hingegen beginnt immer mit einem Laufwerksbuchstaben oder einem `\\` vom Wurzelverzeichnis aus (z.B. `cd C:\\Windows\\System32`). Dieses Verst√§ndnis ist fundamental f√ºr die Navigation und Skripterstellung.",
            "difficulty": "fortgeschritten",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "Sie m√ºssen in `diskpart` eine 500 MB gro√üe prim√§re Partition auf einem leeren Datentr√§ger erstellen. Welcher Befehl ist daf√ºr korrekt? üìè",
            "options": [
                "create partition primary size=500",
                "create primary partition 500mb",
                "create partition size=500mb primary",
                "create partition primary 500"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die korrekte Syntax f√ºr das Erstellen einer Partition mit einer bestimmten Gr√∂√üe in `diskpart` lautet `create partition [typ] size=[gr√∂√üe_in_mb]`. Der Parameter `size` erwartet die Gr√∂√üe in Megabyte (MB). \n- **Option B, C, D:** Verwenden eine falsche Syntax oder Reihenfolge der Parameter. Die Angabe 'mb' ist nicht Teil des Werts. ‚ùå",
            "difficulty": "experte",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "Was ist der historische und funktionale Hauptunterschied zwischen `CMD.EXE` und dem √§lteren `COMMAND.COM`? üèõÔ∏è",
            "options": [
                "`COMMAND.COM` war 32-Bit, `CMD.EXE` ist 16-Bit.",
                "`CMD.EXE` wurde mit Windows NT eingef√ºhrt und ist ein nativer 32/64-Bit-Prozess, w√§hrend `COMMAND.COM` ein 16-Bit-Interpreter aus der MS-DOS-√Ñra ist.",
                "`COMMAND.COM` unterst√ºtzte Batch-Skripte, `CMD.EXE` nicht.",
                "Es gibt keinen funktionalen Unterschied, nur der Name wurde ge√§ndert."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Dies ist ein wichtiger historischer Kontext. `COMMAND.COM` war der Kommandozeileninterpreter f√ºr MS-DOS und √§ltere Windows-Versionen (9x/Me). Es war eine 16-Bit-Anwendung mit vielen Einschr√§nkungen. `CMD.EXE` wurde als nativer 32-Bit-Interpreter (heute auch 64-Bit) f√ºr die Windows-NT-Linie (NT, 2000, XP, etc.) entwickelt und bot eine erweiterte Befehlssyntax und bessere Integration in das Betriebssystem. Beide unterst√ºtzen Batch-Skripte, aber `CMD.EXE` mit mehr Funktionen.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie vermuten, dass eine wichtige Systemdatei versteckt und schreibgesch√ºtzt ist. Welcher Befehl zeigt die Attribute der Datei `kernel32.dll` im System32-Ordner an? üëÅÔ∏è",
            "options": [
                "dir C:\\Windows\\System32\\kernel32.dll",
                "type C:\\Windows\\System32\\kernel32.dll",
                "attrib C:\\Windows\\System32\\kernel32.dll",
                "find \"kernel32.dll\" C:\\Windows\\System32"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der `attrib`-Befehl ist speziell daf√ºr da, die Attribute von Dateien oder Verzeichnissen anzuzeigen oder zu √§ndern. Dazu geh√∂ren A (Archiv), S (System), H (Hidden/Versteckt) und R (Read-only/Schreibgesch√ºtzt). \n- **`dir`:** Zeigt die Datei an, aber nicht immer alle Attribute auf einen Blick. ‚ùå\n- **`type`:** W√ºrde versuchen, den bin√§ren Inhalt der DLL-Datei als Text auszugeben, was zu unsinniger Ausgabe f√ºhrt. ‚ùå\n- **`find`:** Durchsucht den Inhalt von Dateien, nicht deren Attribute. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datei-Befehle"
        },
        {
            "question": "Um die gesamte Befehlshistorie der aktuellen CMD-Sitzung anzuzeigen, kann man `doskey /history` verwenden. Welcher Tastaturbefehl bietet eine √§hnliche, aber interaktivere Funktionalit√§t? ‚å®Ô∏è",
            "options": [
                "F7",
                "F3",
                "Pfeiltaste Oben (‚Üë)",
                "Tab-Taste"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die `F7`-Taste √∂ffnet in der CMD ein kleines Fenster, das eine nummerierte Liste der zuletzt eingegebenen Befehle anzeigt. Man kann dann mit den Pfeiltasten einen Befehl ausw√§hlen und mit `Enter` direkt ausf√ºhren. \n- **`F3`:** Wiederholt den letzten Befehl. ‚ùå\n- **`Pfeiltaste Oben`:** Bl√§ttert einzeln durch die vorherigen Befehle. ‚ùå\n- **`Tab-Taste`:** Wird zur automatischen Vervollst√§ndigung von Date- und Verzeichnisnamen verwendet. ‚ùå",
            "difficulty": "experte",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Ein Skript muss den vollst√§ndigen Pfad zu allen ausf√ºhrbaren Programmen (`.exe`) im Windows-Verzeichnis und allen seinen Unterverzeichnissen auflisten. Welcher `dir`-Befehl ist daf√ºr am besten geeignet? üó∫Ô∏è",
            "options": [
                "dir C:\\Windows\\*.exe",
                "dir C:\\Windows\\*.exe /s /b",
                "tree C:\\Windows /f",
                "find \".exe\" C:\\Windows"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `dir C:\\Windows\\*.exe /s /b` ist hier perfekt. `*.exe` filtert nach der Dateiendung. Der Schalter `/s` (subdirectories) durchsucht rekursiv alle Unterverzeichnisse. Der Schalter `/b` (bare format) gibt nur den reinen Pfad und Dateinamen aus, ohne Kopf- und Fu√üzeilen, was ideal f√ºr die Weiterverarbeitung in Skripten ist. \n- **Option A:** Durchsucht nur das `C:\\Windows`-Verzeichnis selbst, nicht die Unterordner. ‚ùå\n- **Option C:** `tree` zeigt die Verzeichnisstruktur an, was hier zu viel Information w√§re. ‚ùå\n- **Option D:** `find` durchsucht den *Inhalt* von Dateien, nicht die Dateinamen. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Sie m√ºssen eine gro√üe Anzahl von Dateien (ca. 150 GB) samt Unterverzeichnissen und NTFS-Berechtigungen auf einen neuen Server kopieren. Welcher Befehl ist daf√ºr robuster und besser geeignet als `copy` oder `xcopy`? üöö",
            "options": [
                "move",
                "diskpart",
                "robocopy",
                "format"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `robocopy` (Robust File Copy) ist das Mittel der Wahl f√ºr gro√üe und komplexe Kopiervorg√§nge. Es wurde speziell f√ºr solche Szenarien entwickelt und bietet Features wie das Kopieren von NTFS-Berechtigungen, Wiederaufnahme bei Netzwerkunterbrechungen, Spiegelungsmodi und umfangreiches Logging. `xcopy` ist zwar m√§chtiger als `copy`, aber `robocopy` ist der moderne Standard f√ºr administrative Aufgaben. Der Befehl wird im Material als Alternative zu `xcopy` erw√§hnt und geh√∂rt zum Wissen eines Fachinformatikers.",
            "difficulty": "experte",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Welcher `diskpart`-Befehl wird verwendet, um einen Datentr√§ger, der als 'offline' markiert ist, wieder f√ºr das System verf√ºgbar zu machen? üîå",
            "options": [
                "active",
                "online",
                "rescan",
                "assign"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Wenn ein Datentr√§ger oder ein Volume in `diskpart` (oder der Datentr√§gerverwaltung) als 'offline' angezeigt wird, kann das System nicht darauf zugreifen. Der Befehl `online` (nachdem das Objekt mit `select` ausgew√§hlt wurde) schaltet es wieder in den Online-Zustand und macht es f√ºr das Betriebssystem sichtbar und nutzbar. \n- **`active`:** Markiert eine Partition als bootf√§hig. ‚ùå\n- **`rescan`:** Sucht nach neuen, an den Computer angeschlossenen Datentr√§gern. ‚ùå\n- **`assign`:** Weist einen Laufwerksbuchstaben zu, was aber erst m√∂glich ist, wenn das Volume online ist. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        },
        {
            "question": "Was ist das Ergebnis des Befehls `prompt $T$G`? üïí",
            "options": [
                "Der Pfad gefolgt von einem '>'-Zeichen.",
                "Datum und Uhrzeit.",
                "Die aktuelle Uhrzeit gefolgt von einem '>'-Zeichen.",
                "Der Text '$T$G' wird als neuer Prompt gesetzt."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der `prompt`-Befehl √§ndert die Eingabeaufforderung. Dabei werden spezielle Metacodes verwendet. `$T` steht f√ºr die aktuelle Uhrzeit (Time) und `$G` steht f√ºr das 'gr√∂√üer als'-Zeichen (`>`). Der Befehl setzt den Prompt also z.B. auf `14:30:55,12>`. Dies kann n√ºtzlich sein, um Befehle in Skripten mit einem Zeitstempel zu versehen. `$P$G` ist der Standard-Prompt, der den Pfad anzeigt.",
            "difficulty": "experte",
            "category": "Allgemeine Befehle"
        },
        {
            "question": "Sie haben ein Verzeichnis `C:\\Logs` mit tausenden von Dateien. Sie m√∂chten schnell herausfinden, ob es eine Datei mit dem exakten Namen `error_2025-08-26.log` gibt. Welcher Befehl ist am schnellsten und ressourcenschonendsten? üí®",
            "options": [
                "dir C:\\Logs /s",
                "find \"error_2025-08-26.log\" C:\\Logs\\*",
                "dir C:\\Logs\\error_2025-08-26.log",
                "tree C:\\Logs"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der direkteste Weg ist, `dir` mit dem vollst√§ndigen Dateinamen aufzurufen. Wenn die Datei existiert, wird sie sofort aufgelistet. Wenn nicht, meldet `dir` 'Datei nicht gefunden'. Dies ist wesentlich schneller als andere Methoden. \n- **`dir /s`:** W√ºrde alle Unterverzeichnisse durchsuchen, was unn√∂tig ist. ‚ùå\n- **`find`:** Durchsucht den *Inhalt* der Dateien nach dem String, nicht die Dateinamen. Das w√ºrde extrem lange dauern und nicht das gew√ºnschte Ergebnis liefern. ‚ùå\n- **`tree`:** Zeigt die gesamte Verzeichnisstruktur an, was bei tausenden Dateien sehr un√ºbersichtlich und langsam ist. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Wahr oder Falsch: Die Eingabe von `help > befehle.txt` und `help /?` f√ºhrt zum exakt gleichen Ergebnis. ü§î",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. `help > befehle.txt` leitet die *Ausgabe* des `help`-Befehls (also die Liste aller verf√ºgbaren Befehle) in die Datei `befehle.txt` um. Der Befehl `help /?` hingegen zeigt die *Hilfe zum `help`-Befehl selbst* an, also eine Beschreibung, wie der `help`-Befehl funktioniert. Das sind zwei v√∂llig unterschiedliche Aktionen.",
            "difficulty": "fortgeschritten",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "In der Befehlssyntax-Hilfe (z.B. bei `dir /?`) sind einige Parameter in eckigen Klammern `[ ]` aufgef√ºhrt. Was bedeutet diese Konvention? üìñ",
            "options": [
                "Diese Parameter sind veraltet und sollten nicht mehr verwendet werden.",
                "Diese Parameter sind obligatorisch und m√ºssen immer angegeben werden.",
                "Diese Parameter sind optional und k√∂nnen weggelassen werden.",
                "Diese Parameter funktionieren nur im Administratormodus."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die eckigen Klammern `[ ]` sind eine Standardkonvention in der Dokumentation von Kommandozeilenprogrammen, um optionale Parameter, Schalter oder Argumente zu kennzeichnen. Elemente ohne Klammern sind in der Regel erforderlich. Dieses Wissen ist entscheidend, um die Hilfe-Texte der CMD korrekt interpretieren zu k√∂nnen.",
            "difficulty": "einsteiger",
            "category": "Befehlssyntax"
        },
        {
            "question": "Ein USB-Stick wurde f√§lschlicherweise mit `diskpart` und dem `clean`-Befehl bereinigt. Der Benutzer m√∂chte nun versuchen, die Daten wiederherzustellen. Was ist der wichtigste erste Schritt, den er unternehmen sollte, um die Chancen auf eine erfolgreiche Wiederherstellung zu maximieren? üöë",
            "options": [
                "Sofort eine neue Partition erstellen und formatieren, um wieder auf den Stick zugreifen zu k√∂nnen.",
                "Den `chkdsk /r`-Befehl ausf√ºhren, um die Dateistruktur zu reparieren.",
                "Den Stick sofort vom Computer trennen und keine weiteren Schreibvorg√§nge durchf√ºhren.",
                "Den Befehl `diskpart convert mbr` ausf√ºhren."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Nach einem `clean`-Befehl sind die Daten physisch noch vorhanden, aber der 'Wegweiser' (die Partitionstabelle) zu ihnen wurde gel√∂scht. Jeder weitere Schreibvorgang (wie das Erstellen einer neuen Partition, Formatieren, `chkdsk`) birgt die Gefahr, die alten Daten physisch zu √ºberschreiben und sie damit endg√ºltig zu zerst√∂ren. Der wichtigste Schritt ist daher, alle Schreibzugriffe zu verhindern und spezialisierte Datenrettungssoftware zu verwenden, die den Datentr√§ger Sektor f√ºr Sektor scannen kann.",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Welcher Befehl erstellt ein neues Verzeichnis namens `Test Data` im aktuellen Ordner? üóÇÔ∏è",
            "options": [
                "md Test Data",
                "md \"Test Data\"",
                "create Test Data",
                "dir \"Test Data\""
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Da der Verzeichnisname ein Leerzeichen enth√§lt, muss er in Anf√ºhrungszeichen `\" \"` eingeschlossen werden. Ohne Anf√ºhrungszeichen w√ºrde der `md` (make directory)-Befehl versuchen, zwei separate Verzeichnisse namens `Test` und `Data` zu erstellen. \n- **Option A:** W√ºrde zwei Ordner erstellen. ‚ùå\n- **Option C:** Der Befehl `create` existiert in diesem Kontext in der CMD nicht. ‚ùå\n- **Option D:** `dir` zeigt den Inhalt an, erstellt aber nichts. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "Sie m√∂chten alle Textdateien (`.txt`) im aktuellen Verzeichnis umbenennen, sodass sie stattdessen die Endung `.bak` haben. Welcher Befehl erledigt das f√ºr alle Dateien auf einmal? üîÑ",
            "options": [
                "move *.txt *.bak",
                "copy *.txt *.bak",
                "ren *.txt *.bak",
                "attrib *.txt -r"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `ren` (rename) ist f√ºr das Umbenennen von Dateien zust√§ndig. Er unterst√ºtzt die Verwendung von Wildcards (`*` und `?`), um Operationen auf mehrere Dateien gleichzeitig anzuwenden. Der Befehl `ren *.txt *.bak` findet alle Dateien, die auf `.txt` enden, und ersetzt die Endung durch `.bak`, w√§hrend der Dateiname erhalten bleibt.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "Vergleichen Sie die Befehle `date` und `time`. Was ist eine Gemeinsamkeit in ihrer Standardfunktionalit√§t in der CMD? üï∞Ô∏è",
            "options": [
                "Beide zeigen nur Informationen an und erlauben keine √Ñnderungen.",
                "Beide erfordern Administratorrechte, um ausgef√ºhrt zu werden.",
                "Beide zeigen den aktuellen Wert an und bieten direkt im Anschluss die M√∂glichkeit, einen neuen Wert einzugeben.",
                "Beide k√∂nnen ihre Ausgabe nur im `YYYY-MM-DD` bzw. `HH:MM:SS` Format darstellen."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Wenn `date` oder `time` ohne Parameter aufgerufen wird, zeigen sie zun√§chst den aktuellen Systemwert an. Direkt in der n√§chsten Zeile erscheint eine Eingabeaufforderung, in der der Benutzer ein neues Datum bzw. eine neue Uhrzeit eingeben kann. Dr√ºckt man einfach `Enter`, wird keine √Ñnderung vorgenommen. Diese interaktive Funktionalit√§t ist eine charakteristische Gemeinsamkeit der beiden Befehle.",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie f√ºhren den Befehl `tree /f` in einem Ordner aus. Was unterscheidet die Ausgabe von einem einfachen `tree`-Befehl? üå≤",
            "options": [
                "Die Ausgabe wird in eine Datei namens 'f' geschrieben.",
                "Es werden nur die Verzeichnisse des ersten Levels angezeigt.",
                "Die Ausgabe wird alphabetisch sortiert.",
                "Zus√§tzlich zur Verzeichnisstruktur werden auch die Dateien in jedem Verzeichnis aufgelistet."
            ],
            "correct": 3,
            "explain": "**Begr√ºndung:** Der `tree`-Befehl zeigt die Ordnerstruktur eines Pfades grafisch an. Der Schalter `/f` (files) erweitert diese Funktionalit√§t und sorgt daf√ºr, dass nicht nur die Verzeichnisse, sondern auch alle darin enthaltenen Dateien aufgelistet werden, was einen vollst√§ndigen √úberblick √ºber die Hierarchie gibt.",
            "difficulty": "fortgeschritten",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "Ein Benutzer m√∂chte ein Skript erstellen, das automatisch ein Backup-Verzeichnis erstellt. Das Verzeichnis soll nach dem aktuellen Datum benannt werden, z.B. 'Backup_2025-08-26'. Welche CMD-Funktion ist unerl√§sslich, um dies zu erreichen? üóìÔ∏è",
            "options": [
                "Die `date`-Variable, zug√§nglich √ºber `%DATE%`.",
                "Der `format`-Befehl mit einem Datumsparameter.",
                "Der `set`-Befehl allein.",
                "Der `doskey`-Befehl zur Makroerstellung."
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die CMD stellt Umgebungsvariablen bereit, die dynamische Systeminformationen enthalten. `%DATE%` ist eine solche Variable, die das aktuelle Systemdatum enth√§lt. In einem Skript k√∂nnte man also einen Befehl wie `md Backup_%DATE%` verwenden, um einen Ordner mit dem tagesaktuellen Datum im Namen zu erstellen. Dies ist eine grundlegende, aber extrem m√§chtige Technik f√ºr die Automatisierung.",
            "difficulty": "experte",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Welcher `diskpart`-Befehl liefert detaillierte Informationen √ºber das aktuell ausgew√§hlte Objekt, z.B. den Typ, die Gr√∂√üe und den Status einer Partition? ‚ÑπÔ∏è",
            "options": [
                "list",
                "help",
                "detail",
                "attributes"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Nachdem ein Objekt mit `select` in den Fokus genommen wurde (z.B. `select partition 1`), liefert der Befehl `detail` spezifische Informationen genau zu diesem Objekt. `detail disk` zeigt z.B. Festplattendetails, `detail partition` Partitionsdetails und `detail volume` Volumedetails. \n- **`list`:** Zeigt eine √úbersicht aller Objekte eines Typs, aber keine Details zu einem einzelnen. ‚ùå\n- **`help`:** Zeigt Hilfe zu Befehlen an. ‚ùå\n- **`attributes`:** Dient zum Anzeigen und √Ñndern von Attributen, nicht zur allgemeinen Detailansicht. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        },
        {
            "question": "Wie kann man in der CMD schnell den Bildschirm von allen vorherigen Befehlen und Ausgaben bereinigen? üßº",
            "options": [
                "clear",
                "clean",
                "cls",
                "exit"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `cls` (clear screen) ist der Standardbefehl in der Windows-Kommandozeile, um den gesamten Inhalt des Konsolenfensters zu l√∂schen und den Cursor in die obere linke Ecke zu setzen. \n- **`clear`:** Ist der entsprechende Befehl in Linux/Unix-Shells, funktioniert in CMD aber nicht. ‚ùå\n- **`clean`:** Ist ein `diskpart`-Befehl mit einer v√∂llig anderen (und gef√§hrlichen) Funktion. ‚ùå\n- **`exit`:** Schlie√üt das CMD-Fenster. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Allgemeine Befehle"
        },
        {
            "question": "Sie m√ºssen eine Partition in `diskpart` als 'inaktiv' markieren. Welcher Befehl wird nach der Auswahl der Partition daf√ºr verwendet? ‚õî",
            "options": [
                "deactivate",
                "inactive",
                "remove active",
                "setid inactive"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `inactive` ist das direkte Gegenst√ºck zum `active`-Befehl. Nachdem eine Partition ausgew√§hlt wurde (z.B. `select partition 1`), markiert der Befehl `inactive` diese als nicht mehr bootf√§hig. Dies ist eine wichtige Funktion bei der Verwaltung von Multi-Boot-Systemen.",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        },
        {
            "question": "üÜò Ein Kollege ruft Sie an und fragt nach Hilfe zu einem CMD-Befehl, den er nicht kennt. Welcher Befehl zeigt ihm alle verf√ºgbaren Befehle und deren Beschreibungen an?",
            "options": [
                "help",
                "/?",
                "commands",
                "list"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `/?` ist der universelle Hilfebefehl in CMD üìã. Er kann sowohl alleine verwendet werden, um eine Liste aller Befehle zu erhalten, als auch hinter einem spezifischen Befehl (z.B. `dir /?`), um detaillierte Informationen zu diesem Befehl anzuzeigen. Dies ist besonders n√ºtzlich f√ºr IT-Support-Szenarien, da man schnell die richtige Syntax und Parameter eines Befehls nachschlagen kann. Die anderen Optionen sind keine g√ºltigen CMD-Befehle in diesem Kontext.",
            "difficulty": "einsteiger",
            "category": "Grundlagen CMD"
        },
        {
            "question": "‚ö° Sie m√ºssen in einem Batch-Script drei Befehle nacheinander ausf√ºhren, aber nur wenn der vorherige erfolgreich war. Welche Syntax verwenden Sie zwischen den Befehlen?",
            "options": [
                "&",
                "&&",
                "||",
                "|"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Operator `&&` f√ºhrt den nachfolgenden Befehl nur aus, wenn der vorherige Befehl erfolgreich war (Exit-Code 0) ‚úÖ. Dies ist kritisch f√ºr Batch-Scripts in produktiven Umgebungen, da Fehler nicht propagiert werden. Der einfache `&` w√ºrde alle Befehle unabh√§ngig vom Erfolg ausf√ºhren, `||` f√ºhrt nur bei Fehlern aus, und `|` ist f√ºr Pipes gedacht. In der Praxis verhindert `&&` Folgesch√§den durch fehlerhafte Befehle.",
            "difficulty": "fortgeschritten",
            "category": "Batch-Scripting"
        },
        {
            "question": "üé® Ein Benutzer mit Sehschw√§che ben√∂tigt bessere Kontraste in der Eingabeaufforderung. Mit welchem Befehl k√∂nnen Sie die Farben des Textes und Hintergrunds anpassen?",
            "options": [
                "theme",
                "color",
                "display",
                "contrast"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `color` Befehl erm√∂glicht es, sowohl Text- als auch Hintergrundfarben zu √§ndern üåà. Die Syntax ist `color [Hintergrund][Text]` mit hexadezimalen Werten (0-F). Beispiel: `color 0A` setzt schwarzen Hintergrund mit gr√ºnem Text. Dies ist besonders wichtig f√ºr Barrierefreiheit und kann die Produktivit√§t bei langen Terminal-Sessions erheblich steigern. Moderne IT-Umgebungen sollten Accessibility-Anforderungen ber√ºcksichtigen.",
            "difficulty": "einsteiger",
            "category": "Benutzerfreundlichkeit"
        },
        {
            "question": "üìã Sie erstellen ein Monitoring-Script, das Systemdaten in eine Datei speichern soll, aber auch gleichzeitig in die Zwischenablage kopieren muss. Welcher Befehl hilft dabei?",
            "options": [
                "copy",
                "clip",
                "clipboard",
                "paste"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `clip` Befehl kopiert die Ausgabe eines beliebigen Befehls direkt in die Windows-Zwischenablage üìé. Beispiel: `systeminfo | clip` kopiert alle Systeminformationen in die Zwischenablage. Dies ist extrem n√ºtzlich f√ºr IT-Dokumentation, Support-Tickets oder beim Teilen von Systeminformationen. In Kombination mit Pipes (`|`) k√∂nnen komplexe Datenverarbeitungsketten erstellt werden, die sowohl in Dateien als auch in die Zwischenablage ausgeben.",
            "difficulty": "fortgeschritten",
            "category": "Datenverarbeitung"
        },
        {
            "question": "üìú Bei der Fehleranalyse m√ºssen Sie nachvollziehen, welche Befehle ein Kollege in der aktuellen CMD-Session verwendet hat. Welcher Befehl zeigt den Verlauf an?",
            "options": [
                "history",
                "doskey /history", 
                "cmdhistory",
                "log"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `doskey /history` zeigt alle Befehle der aktuellen Session an üìö. Doskey ist ein m√§chtiges Tool f√ºr Befehlsverwaltung, das auch Makros und Aliase unterst√ºtzt. Dies ist essentiell f√ºr Debugging, Compliance-Audits und Nachverfolgung von System√§nderungen. In kritischen Umgebungen kann der Befehlsverlauf bei der Root-Cause-Analyse von Problemen entscheidend sein. Professionelle Administratoren nutzen dies zur Dokumentation ihrer Arbeitsschritte.",
            "difficulty": "fortgeschritten",
            "category": "System-Administration"
        },
        {
            "question": "üîç Ihr Server l√§uft langsam und Sie vermuten einen problematischen Prozess. Mit welchem Befehl erhalten Sie eine √úbersicht aller laufenden Prozesse inklusive ihrer IDs?",
            "options": [
                "ps",
                "processes",
                "tasklist",
                "jobs"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `tasklist` zeigt alle laufenden Anwendungen, Dienste und deren Prozess-IDs (PIDs) an üñ•Ô∏è. Dies ist das Windows-√Ñquivalent zu `ps` unter Unix/Linux. Der Befehl unterst√ºtzt Filter wie `/fo table` f√ºr bessere Formatierung oder `/svc` f√ºr Service-Details. In produktiven Umgebungen ist dies essentiell f√ºr Performance-Monitoring, Ressourcen-Management und Identifikation problematischer Prozesse vor deren Beendigung.",
            "difficulty": "einsteiger",
            "category": "Prozess-Management"
        },
        {
            "question": "‚öîÔ∏è Sie haben einen h√§ngenden Prozess mit der PID 1234 identifiziert, der 80% CPU verbraucht. Welcher Befehl beendet diesen Prozess sofort?",
            "options": [
                "kill 1234",
                "end 1234",
                "taskkill /PID 1234",
                "stop 1234"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `taskkill /PID 1234` beendet den Prozess mit der angegebenen Prozess-ID üíÄ. Der Parameter `/F` kann hinzugef√ºgt werden f√ºr forciertes Beenden. Dies ist kritisch bei h√§ngenden Prozessen, die Systemressourcen blockieren. In produktiven Umgebungen sollte man vorsichtig sein, da das unsaubere Beenden von Prozessen Datenverlust verursachen kann. Alternative Syntax: `/IM prozessname.exe` f√ºr Beendigung nach Namen.",
            "difficulty": "fortgeschritten",
            "category": "Prozess-Management"
        },
        {
            "question": "üóÇÔ∏è Ein Benutzer kann keine .PDF-Dateien √∂ffnen, da die Dateizuordnung besch√§digt ist. Mit welchem Befehl k√∂nnen Sie die aktuellen Dateizuordnungen anzeigen und √§ndern?",
            "options": [
                "filetype",
                "assoc",
                "extension",
                "ftype"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `assoc` zeigt und √§ndert die Zuordnung zwischen Dateierweiterungen und Dateitypen üìÑ. Beispiel: `assoc .pdf` zeigt die aktuelle Zuordnung f√ºr PDF-Dateien. Mit `assoc .pdf=AcroExch.Document` wird die Zuordnung ge√§ndert. Dies ist essentiell f√ºr IT-Support bei Problemen mit Standard-Anwendungen. In Unternehmensumgebungen ist die korrekte Dateizuordnung kritisch f√ºr Produktivit√§t und Workflow-Integration.",
            "difficulty": "fortgeschritten",
            "category": "Dateisystem-Management"
        },
        {
            "question": "üîß Bei Hardware-Problemen m√ºssen Sie √ºberpr√ºfen, ob alle Treiber korrekt installiert sind. Welcher Befehl listet alle installierten Treiber auf?",
            "options": [
                "drivers",
                "driverquery",
                "hwinfo",
                "devinfo"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `driverquery` zeigt eine detaillierte Liste aller installierten Treiber mit Informationen wie Name, Typ, Datum und Version an üöó. Parameter wie `/fo csv` erm√∂glichen Export in verschiedene Formate f√ºr weitere Analyse. Dies ist unverzichtbar bei Hardware-Troubleshooting, Compliance-Audits und Systemdokumentation. In kritischen Umgebungen hilft es bei der Identifikation veralteter oder problematischer Treiber vor System-Updates.",
            "difficulty": "experte",
            "category": "Hardware-Diagnose"
        },
        {
            "question": "üåê Ein Netzwerkadministrator ben√∂tigt die IP-Konfiguration aller Netzwerkadapter f√ºr die Dokumentation. Welcher Befehl liefert diese Informationen am vollst√§ndigsten?",
            "options": [
                "netconfig",
                "ipinfo", 
                "ipconfig",
                "netinfo"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `ipconfig` zeigt detaillierte IP-Informationen f√ºr alle TCP/IP-Adapter an üåç. Parameter: `/all` f√ºr vollst√§ndige Details, `/release` und `/renew` f√ºr DHCP-Verwaltung, `/flushdns` f√ºr DNS-Cache-Bereinigung. Dies ist das zentrale Tool f√ºr Netzwerk-Troubleshooting und -Dokumentation. In Unternehmensumgebungen essentiell f√ºr IP-Management, DHCP-Problembehebung und Netzwerk-Compliance.",
            "difficulty": "einsteiger",
            "category": "Netzwerk-Administration"
        },
        {
            "question": "üì° Sie vermuten Verbindungsprobleme zu einem Server (192.168.1.100). Mit welchem Befehl testen Sie die Erreichbarkeit auf IP-Ebene?",
            "options": [
                "test 192.168.1.100",
                "connect 192.168.1.100",
                "ping 192.168.1.100",
                "reach 192.168.1.100"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `ping 192.168.1.100` sendet ICMP Echo-Request-Pakete zum Testen der IP-Konnektivit√§t üì∂. Zeigt Antwortzeiten, Paketverluste und TTL-Werte. Parameter wie `-t` f√ºr kontinuierliches Pingen oder `-n 10` f√ºr bestimmte Anzahl. Dies ist der erste Schritt bei Netzwerk-Troubleshooting. Hilft bei der Unterscheidung zwischen Routing-, DNS- oder Anwendungsproblemen. Unverzichtbar f√ºr Netzwerk-Monitoring und Performance-Analyse.",
            "difficulty": "einsteiger",
            "category": "Netzwerk-Diagnose"
        },
        {
            "question": "üîå Bei verd√§chtiger Netzwerkaktivit√§t m√ºssen Sie alle aktiven Netzwerkverbindungen und lauschende Ports analysieren. Welcher Befehl liefert diese Informationen?",
            "options": [
                "connections",
                "ports",
                "netstat",
                "sockstat"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `netstat` zeigt alle offenen Netzwerkverbindungen, lauschende Ports und Routing-Tabellen an üîç. Parameter: `-a` f√ºr alle Verbindungen, `-n` f√ºr numerische Adressen, `-b` f√ºr Anwendungsnamen. Essentiell f√ºr Security-Audits, Malware-Erkennung und Performance-Analyse. In Sicherheitsumgebungen hilft es bei der Identifikation unautorisierten Netzwerktraffics und potentieller Backdoors.",
            "difficulty": "experte",
            "category": "Netzwerk-Security"
        },
        {
            "question": "üíª F√ºr ein Hardware-Audit ben√∂tigen Sie vollst√§ndige Systeminformationen inklusive Prozessor, RAM und Mainboard-Details. Welcher Befehl liefert diese umfassenden Daten?",
            "options": [
                "hwinfo",
                "sysinfo",
                "systeminfo",
                "pcinfo"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `systeminfo` liefert umfassende Windows-Konfigurationsinformationen wie Hardware-Details, OS-Version, Patches, Netzwerk-Karten und Boot-Zeit üñ•Ô∏è. Unterst√ºtzt auch Remote-Computer mit `/s computername`. Ideal f√ºr Asset-Management, Compliance-Berichte und Systemdokumentation. In Enterprise-Umgebungen unverzichtbar f√ºr Inventarisierung, Update-Planning und Hardware-Lifecycle-Management.",
            "difficulty": "einsteiger",
            "category": "System-Information"
        },
        {
            "question": "üîã Ein Laptop hat Akku-Probleme und Sie m√ºssen die Energieeinstellungen analysieren und optimieren. Welcher CMD-Befehl erm√∂glicht erweiterte Energieverwaltung?",
            "options": [
                "battery",
                "power",
                "powercfg",
                "energy"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `powercfg` ist das m√§chtigste Tool f√ºr Windows-Energieverwaltung ‚ö°. Parameter: `/batteryreport` f√ºr Akkuanalyse, `/energy` f√ºr Energieeffizienz-Bericht, `/hibernate on/off` f√ºr Ruhezustand. Kann Energieschemas erstellen und modifizieren. Kritisch f√ºr Laptop-Optimierung, Server-Effizienz und Green-IT-Initiativen. Hilft bei der Identifikation energiefressender Hardware und Software.",
            "difficulty": "experte",
            "category": "Energieverwaltung"
        },
        {
            "question": "üõ°Ô∏è Nach einem Systemabsturz vermuten Sie besch√§digte Systemdateien. Welcher Befehl √ºberpr√ºft und repariert kritische Windows-Systemdateien?",
            "options": [
                "fixsystem",
                "sfc",
                "repair",
                "checkfiles"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `sfc` (System File Checker) √ºberpr√ºft die Integrit√§t aller gesch√ºtzten Systemdateien und repariert besch√§digte Dateien üîß. Syntax: `sfc /scannow` f√ºr vollst√§ndige √úberpr√ºfung. Verwendet Windows Resource Protection (WRP) und das Component Store. Essentiell nach Malware-Befall, Abst√ºrzen oder fehlgeschlagenen Updates. Sollte im abgesicherten Modus oder mit Administrator-Rechten ausgef√ºhrt werden.",
            "difficulty": "fortgeschritten",
            "category": "System-Reparatur"
        },
        {
            "question": "üíΩ Ein Server zeigt Speicherfehler und Sie m√ºssen die Festplatte auf Bad Sectors und Dateisystemfehler √ºberpr√ºfen. Welcher Befehl f√ºhrt diese Diagnose durch?",
            "options": [
                "diskcheck",
                "scandisk",
                "chkdsk",
                "fsck"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `chkdsk` (Check Disk) erkennt und repariert Festplattenfehler, Bad Sectors und Dateisystem-Inkonsistenzen üíø. Parameter: `/f` f√ºr automatische Reparatur, `/r` f√ºr Bad-Sector-Recovery. Muss oft nach Neustart ausgef√ºhrt werden f√ºr Systemlaufwerke. Kritisch f√ºr Datenintegrit√§t, Performance-Optimierung und Fr√ºhwarnung vor Festplattenausfall. In produktiven Umgebungen sollte es regelm√§√üig geplant werden.",
            "difficulty": "fortgeschritten",
            "category": "Speicher-Diagnose"
        },
        {
            "question": "üóÉÔ∏è Sie m√ºssen Registry-Einstellungen f√ºr eine Anwendung manuell korrigieren, da der normale Installer versagt hat. Welcher Befehl √∂ffnet den Registry-Editor?",
            "options": [
                "registry",
                "regedt32",
                "regedit",
                "regmod"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `regedit` √∂ffnet den Windows Registry-Editor f√ºr manuelle Bearbeitung der Systemregistrierung üìä. Extrem m√§chtig aber gef√§hrlich - falsche √Ñnderungen k√∂nnen Windows unbrauchbar machen. Sollte nur von erfahrenen Administratoren verwendet werden. Vor √Ñnderungen immer Backup erstellen. Alternative: `reg` Befehl f√ºr Kommandozeilen-Registry-Operationen. In Unternehmensumgebungen oft durch Group Policies ersetzt.",
            "difficulty": "experte",
            "category": "Registry-Management"
        },
        {
            "question": "‚è∞ Sie m√ºssen ein automatisches Backup-Script erstellen, das jeden Tag um 2:00 Uhr l√§uft. Welcher Befehl erm√∂glicht die Verwaltung geplanter Aufgaben?",
            "options": [
                "schedule",
                "cron",
                "schtasks",
                "taskman"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `schtasks` erstellt, l√∂scht und verwaltet geplante Aufgaben in Windows ‚è∞. Beispiel: `schtasks /create /tn \"Backup\" /tr \"backup.bat\" /sc daily /st 02:00`. Ersetzt das veraltete `at` Kommando. Parameter f√ºr Trigger, Benutzerkontext und Bedingungen. Essentiell f√ºr Automatisierung, Wartungsaufgaben und Monitoring. In Serverumgebungen kritisch f√ºr regelm√§√üige Backups, Updates und Systemwartung.",
            "difficulty": "experte",
            "category": "Task-Automation"
        },
        {
            "question": "üóëÔ∏è Der Computer l√§uft langsam und Sie vermuten, dass tempor√§re Dateien die Ursache sind. Welcher Befehl l√∂scht alle tempor√§ren Dateien des aktuellen Benutzers?",
            "options": [
                "cleantmp",
                "deltmp", 
                "del /q /f /s %temp%\\*",
                "remove temp"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `del /q /f /s %temp%\\*` l√∂scht alle Dateien im tempor√§ren Verzeichnis des Benutzers üßπ. Parameter: `/q` f√ºr quiet (keine Best√§tigung), `/f` f√ºr forcierte L√∂schung schreibgesch√ºtzter Dateien, `/s` f√ºr Unterverzeichnisse. %temp% ist eine Umgebungsvariable f√ºr das Temp-Verzeichnis. Wichtig f√ºr System-Optimierung, Speicherplatz-Freigabe und Privacy. Sollte regelm√§√üig in Wartungsroutinen eingesetzt werden.",
            "difficulty": "fortgeschritten",
            "category": "System-Wartung"
        },
        {
            "question": "üö™ Nach Abschluss aller Wartungsarbeiten m√∂chten Sie die CMD-Session sauber beenden und zur normalen Desktop-Arbeit zur√ºckkehren. Welcher Befehl schlie√üt die Eingabeaufforderung?",
            "options": [
                "quit",
                "close",
                "exit",
                "end"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `exit` beendet die aktuelle CMD-Session ordnungsgem√§√ü und schlie√üt das Eingabeaufforderungs-Fenster üö™. In Batch-Scripts kann ein Exit-Code √ºbergeben werden (z.B. `exit /b 0` f√ºr erfolgreiche Beendigung). Dies ist wichtig f√ºr saubere Script-Beendigung und Ressourcen-Freigabe. In automatisierten Umgebungen signalisiert der Exit-Code anderen Prozessen den Ausf√ºhrungsstatus. Professionelle Scripts sollten immer mit entsprechenden Exit-Codes enden.",
            "difficulty": "einsteiger",
            "category": "Session-Management"
        },{
      "question": " Szenario: Ein Admin m√∂chte den Ordner `C:\\Daten` inklusive aller Unterordner, auch der leeren, auf Laufwerk `G:` sichern. Welcher `xcopy`-Befehl ist daf√ºr am besten geeignet? üìÇ",
      "options": [
        "xcopy C:\\Daten G:\\Daten /s",
        "xcopy C:\\Daten G:\\Daten /e",
        "copy C:\\Daten G:\\Daten /s",
        "xcopy C:\\Daten\\*.* G:\\Daten /e"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der Schalter `/e` ist entscheidend, da er `xcopy` anweist, alle Unterverzeichnisse zu kopieren, **einschlie√ülich der leeren**. Der Schalter `/s` kopiert nur Unterverzeichnisse, die nicht leer sind. Der `copy`-Befehl kann keine Verzeichnisstrukturen kopieren. Die Verwendung von `*.*` w√ºrde nur die Dateien im Stammverzeichnis von `Daten` als Quelle nehmen, nicht den Ordner selbst. ‚öôÔ∏è",
      "difficulty": "einsteiger",
      "category": "Kopierbefehle"
    },
    {
      "question": "Szenario: Nach dem Ausf√ºhren von `xcopy F:\\projekt G:\\backup` stellt der Benutzer fest, dass auf `G:` zwar der *Inhalt* von `projekt` liegt, aber der Ordner `projekt` selbst fehlt. Was ist die korrekte Syntax, um die gesamte Struktur, einschlie√ülich des `projekt`-Ordners, zu kopieren?  Strukturelles Problem! üèóÔ∏è",
      "options": [
        "xcopy F:\\projekt\\*.* G:\\backup\\projekt /s /e",
        "xcopy F:\\projekt G:\\backup\\projekt\\ /s /e",
        "xcopy F:\\projekt G:\\backup /s /e /root",
        "xcopy F:\\projekt G:\\ /s /e"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** `xcopy` kopiert standardm√§√üig den *Inhalt* der Quelle ins Ziel. Um den Quellordner selbst im Ziel zu erstellen, muss er im Zielpfad explizit angegeben werden (`G:\\backup\\projekt`). Der abschlie√üende Backslash (`\\`) signalisiert `xcopy` eindeutig, dass das Ziel ein Verzeichnis ist, und unterdr√ºckt die Nachfrage 'Datei oder Verzeichnis?'. üí°",
      "difficulty": "fortgeschritten",
      "category": "Befehlssyntax"
    },
    {
      "question": "Vergleichende Analyse: Was ist der prim√§re funktionale Unterschied zwischen dem `copy`- und dem `xcopy`-Befehl in der Windows-Kommandozeile? ü§î",
      "options": [
        "`xcopy` ist schneller, aber `copy` kann mehr Dateitypen verarbeiten.",
        "`copy` kann nur einzelne Dateien kopieren, w√§hrend `xcopy` ganze Verzeichnisb√§ume kopieren kann.",
        "`xcopy` ist veraltet und wurde durch `copy /s` ersetzt.",
        "`copy` kann √ºber das Netzwerk kopieren, `xcopy` nicht."
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der Hauptunterschied liegt im Umfang. `copy` ist f√ºr das Kopieren von Dateien konzipiert. `xcopy` (Extended Copy) wurde entwickelt, um ganze Verzeichnisstrukturen rekursiv zu kopieren, was es zu einem m√§chtigen Werkzeug f√ºr Backups und das Duplizieren von Ordnern macht. üå≥",
      "difficulty": "einsteiger",
      "category": "Grundlagen der Kommandozeile"
    },
    {
      "question": "Berechnungsaufgabe: Ein Verzeichnis `C:\\source` enth√§lt 3 Dateien. Das Unterverzeichnis `C:\\source\\A` enth√§lt 2 Dateien und das Unterverzeichnis `C:\\source\\B` ist leer. Wie viele Dateien werden mit dem Befehl `xcopy C:\\source D:\\dest /s` kopiert? üßÆ",
      "options": [
        "0 Dateien",
        "3 Dateien",
        "5 Dateien",
        "Alle Dateien und das leere Verzeichnis B."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Der Befehl kopiert die 3 Dateien aus `C:\\source` und die 2 Dateien aus `C:\\source\\A`. Das Verzeichnis `C:\\source\\B` wird ignoriert, da der Schalter `/s` nur **nicht-leere** Verzeichnisse ber√ºcksichtigt. Insgesamt werden also 3 + 2 = 5 Dateien kopiert. üìÑ",
      "difficulty": "fortgeschritten",
      "category": "Befehlsparameter"
    },
    {
      "question": "Logisches R√§tsel: Ein Skript f√ºhrt den Befehl `xcopy F:\\daten\\ G:\\backup\\daten /e` aus. Unmittelbar danach wird `rd G:\\backup\\daten /s /q` ausgef√ºhrt. Was ist der Zustand des Verzeichnisses `G:\\backup\\daten` nach beiden Befehlen? üîÑ",
      "options": [
        "Es ist leer, aber vorhanden.",
        "Es enth√§lt die urspr√ºngliche Sicherung.",
        "Es existiert nicht mehr.",
        "Es enth√§lt nur noch die leeren Unterverzeichnisse."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Der erste Befehl (`xcopy`) erstellt eine vollst√§ndige Kopie. Der zweite Befehl, `rd` (Remove Directory) mit dem Schalter `/s`, l√∂scht das angegebene Verzeichnis und **alle** darin enthaltenen Unterverzeichnisse und Dateien. Der Schalter `/q` (Quiet) unterdr√ºckt die Best√§tigungsabfrage. Das Verzeichnis wird also komplett und ohne R√ºckfrage entfernt. üí®",
      "difficulty": "einsteiger",
      "category": "Befehlsketten"
    },
    {
      "question": "Wahr/Falsch: Der Befehl `robocopy` ist ein √§lterer und einfacherer Befehl als `xcopy` und wird daher f√ºr simple Aufgaben bevorzugt. üìú",
      "options": [
        "Wahr",
        "Falsch"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Falsch. `robocopy` (Robust File Copy) ist der neuere und wesentlich leistungsf√§higere Nachfolger von `xcopy`. Es bietet Features wie Spiegelung (`/mir`), Wiederholungslogik bei Netzwerkfehlern, Kopieren von Berechtigungen und eine deutlich bessere Performance bei gro√üen Kopiervorg√§ngen. `xcopy` ist f√ºr einfache Aufgaben ausreichend, aber `robocopy` ist das professionelle Werkzeug. üöÄ",
      "difficulty": "fortgeschritten",
      "category": "Tool-Vergleich"
    },
    {
      "question": "Szenario: Ein Admin muss ein Benutzerprofil von `C:\\Users\\Max` nach `D:\\Backup\\Max` kopieren. Es sollen alle Dateien, Unterordner (auch leere) sowie versteckte und Systemdateien mitgenommen werden. Welcher Befehl ist daf√ºr am robustesten? üïµÔ∏è",
      "options": [
        "xcopy C:\\Users\\Max D:\\Backup\\Max /e /h /k",
        "xcopy C:\\Users\\Max D:\\Backup\\Max /s /h",
        "robocopy C:\\Users\\Max D:\\Backup\\Max /e /copyall",
        "robocopy C:\\Users\\Max D:\\Backup\\Max /s"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** `robocopy` ist hier die bessere Wahl. Der Schalter `/e` kopiert alle Unterordner (auch leere). Der entscheidende Schalter ist `/copyall`, der eine Abk√ºrzung f√ºr `/copy:DATSOU` ist und **D**aten, **A**ttribute, **T**ime Stamps, **S**icherheit (NTFS ACLs), **O**wner-Infos und A**u**diting-Infos kopiert. `xcopy` mit `/h` kopiert zwar versteckte Dateien, aber nicht so umfassend wie `robocopy` mit `/copyall`. üõ°Ô∏è",
      "difficulty": "experte",
      "category": "Datensicherung"
    },
    {
      "question": "Vergleichende Analyse: Worin liegt der Hauptunterschied im Verhalten der Schalter `/s` und `/e` bei `xcopy`? ‚öñÔ∏è",
      "options": [
        "`/s` steht f√ºr 'silent', `/e` f√ºr 'error reporting'.",
        "`/s` kopiert nur Systemdateien, `/e` alle Dateien.",
        "`/s` kopiert Unterverzeichnisse, die nicht leer sind, `/e` kopiert alle Unterverzeichnisse.",
        "`/s` ist f√ºr das Quellverzeichnis, `/e` f√ºr das Zielverzeichnis."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Dies ist ein zentraler Unterschied. `/s` (Subdirectories) ist n√ºtzlich, um eine Struktur zu kopieren, aber irrelevante, leere Ordner wegzulassen. `/e` (Empty) ist erforderlich, wenn eine exakte 1:1-Kopie der Verzeichnisstruktur erstellt werden soll, inklusive aller Platzhalter- oder Log-Ordner, die initial leer sein k√∂nnten. üåø",
      "difficulty": "fortgeschritten",
      "category": "Befehlsparameter"
    },
    {
      "question": "Berechnungsaufgabe: Was ist die minimale Anzahl an Schaltern, die `xcopy` ben√∂tigt, um eine Verzeichnisstruktur inklusive leerer Ordner zu kopieren? ÔøΩ",
      "options": [
        "0",
        "1",
        "2",
        "3"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der einzige zwingend erforderliche Schalter, um auch leere Verzeichnisse zu erfassen, ist `/e`. Obwohl oft mit `/s` kombiniert (was `/e` implizit erweitert), funktioniert `/e` auch allein und erf√ºllt die Anforderung. Ein Befehl wie `xcopy C:\\A D:\\B /e` ist also g√ºltig. üí°",
      "difficulty": "einsteiger",
      "category": "Befehlssyntax"
    },
    {
      "question": "Szenario: Ein Admin f√ºhrt `xcopy C:\\daten G:\\backup /e` aus und wird gefragt: 'Gibt G:\\backup einen Dateinamen oder einen Verzeichnisnamen an (F = Datei, V = Verzeichnis)?'. Wie h√§tte der Befehl formuliert werden m√ºssen, um diese Abfrage zu verhindern? ü§´",
      "options": [
        "xcopy C:\\daten G:\\backup /e /y",
        "xcopy C:\\daten\\ G:\\backup /e",
        "xcopy C:\\daten G:\\backup\\ /e",
        "xcopy C:\\daten G:\\backup /e /q"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Die Abfrage erscheint, wenn das Zielverzeichnis nicht existiert und `xcopy` unsicher ist, ob der Zielname f√ºr eine Datei oder ein Verzeichnis steht. Durch Hinzuf√ºgen eines Backslash (`\\`) am Ende des Zielpfades (`G:\\backup\\`) wird dem Befehl eindeutig mitgeteilt, dass es sich um ein Verzeichnis handelt. Die Abfrage wird somit √ºbersprungen. ‚úÖ",
      "difficulty": "fortgeschritten",
      "category": "Befehlssyntax"
    },
    {
        "question": "Logisches R√§tsel: Ein Befehl `xcopy C:\\quelle\\*.* D:\\ziel /s` wird ausgef√ºhrt. Was passiert mit leeren Unterverzeichnissen innerhalb von `C:\\quelle`? üß©",
        "options": [
          "Sie werden kopiert, da `*.*` alle Inhalte meint.",
          "Sie werden nicht kopiert.",
          "Es kommt zu einer Fehlermeldung.",
          "Nur die leeren Verzeichnisse werden kopiert."
        ],
        "correct": 1,
        "explain": "**Begr√ºndung:** Der Schalter `/s` kopiert nur Verzeichnisse, die Dateien enthalten. Obwohl `*.*` auf alle Dateien abzielt, √§ndert dies nichts am Verhalten des `/s`-Schalters bez√ºglich der Verzeichnisse selbst. Leere Ordner werden ignoriert. Um sie zu kopieren, w√§re der Schalter `/e` erforderlich. üö´",
        "difficulty": "fortgeschritten",
        "category": "Logische Analyse"
    },
    {
        "question": "Berechnungsaufgabe: Ein Skript soll das tempor√§re Verzeichnis `C:\\Temp` mit all seinen Inhalten ohne jegliche Benutzerinteraktion l√∂schen. Welche Kombination von Schaltern f√ºr den `rd`-Befehl ist korrekt? üóëÔ∏è",
        "options": [
          "rd C:\\Temp /q",
          "rd C:\\Temp /s",
          "rd C:\\Temp /s /q",
          "del C:\\Temp /s /q"
        ],
        "correct": 2,
        "explain": "**Begr√ºndung:** `rd` (oder `rmdir`) ist der Befehl zum L√∂schen von Verzeichnissen. Der Schalter `/s` wird ben√∂tigt, um ein Verzeichnis mit Inhalt (Dateien und Unterverzeichnisse) zu l√∂schen. Der Schalter `/q` (Quiet) unterdr√ºckt die Best√§tigungsaufforderung 'Sind Sie sicher?'. Die Kombination `/s /q` ist daher der Standard f√ºr die automatisierte, unbeaufsichtigte L√∂schung von Verzeichnissen. `del` l√∂scht nur Dateien, keine Verzeichnisse. üî•",
        "difficulty": "fortgeschritten",
        "category": "Dateisystem-Management"
    },
    {
        "question": "Vergleichende Analyse: Warum wird `robocopy` gegen√ºber `xcopy` f√ºr kritische Kopiervorg√§nge √ºber instabile Netzwerkverbindungen bevorzugt? üåê",
        "options": [
          "`xcopy` hat eine eingebaute Datenkompression.",
          "`robocopy` hat eine automatische Wiederholungslogik und eine einstellbare Wartezeit zwischen den Versuchen.",
          "`xcopy` kann die Bandbreite besser ausnutzen.",
          "`robocopy` ist nur auf Server-Betriebssystemen verf√ºgbar."
        ],
        "correct": 2,
        "explain": "**Begr√ºndung:** Die Robustheit von `robocopy` zeigt sich hier deutlich. Standardm√§√üig versucht es bei einem Fehler (z.B. kurzzeitiger Netzwerkausfall) 1 Million Mal im Abstand von 30 Sekunden, die Datei zu kopieren. Diese Werte (`/r:n` und `/w:n`) sind konfigurierbar. `xcopy` bricht bei einem Fehler einfach ab. Diese Ausfallsicherheit macht `robocopy` f√ºr professionelle Eins√§tze unverzichtbar. ‚è≥",
        "difficulty": "experte",
        "category": "Netzwerk-Operationen"
    },
    {
        "question": "Szenario: Im Rahmen einer differentiellen Backup-Strategie sollen mit `xcopy` nur die Dateien kopiert werden, die seit dem letzten Backup (gekennzeichnet durch das Archiv-Attribut) ge√§ndert wurden. Welcher Schalter wird daf√ºr verwendet? üíæ",
        "options": [
          "xcopy ... /d",
          "xcopy ... /u",
          "xcopy ... /a",
          "xcopy ... /m"
        ],
        "correct": 3,
        "explain": "**Begr√ºndung:** Der Schalter `/a` kopiert nur Dateien, bei denen das Archiv-Attribut gesetzt ist, **ohne es zu √§ndern**. Der Schalter `/m` tut dasselbe, **setzt aber das Archiv-Attribut der Quelldatei zur√ºck**. F√ºr ein echtes differentielles/inkrementelles Backup-Schema ist `/m` oft die bessere Wahl, da so markiert wird, dass die Datei gesichert wurde. `/a` ist n√ºtzlich, um den Status zu pr√ºfen, ohne ihn zu ver√§ndern. üìà",
        "difficulty": "experte",
        "category": "Backup-Strategien"
    },
    {
        "question": "Logisches R√§tsel: Ein Admin f√ºhrt `xcopy C:\\A D:\\B /e` aus. Danach wird eine neue Datei in `C:\\A` hinzugef√ºgt. Nun wird der Befehl `xcopy C:\\A D:\\B /d /e` ausgef√ºhrt (ohne Datum). Was passiert? üï∞Ô∏è",
        "options": [
          "Alle Dateien werden erneut kopiert.",
          "Nur die neue Datei wird kopiert.",
          "Es wird ein Fehler angezeigt, da ein Datum fehlt.",
          "Nichts wird kopiert."
        ],
        "correct": 1,
        "explain": "**Begr√ºndung:** Der Schalter `/d` (ohne Angabe eines Datums) weist `xcopy` an, nur die Dateien zu kopieren, deren Quelldatum neuer ist als das Zieldatum. Da die bereits kopierten Dateien identische Zeitstempel haben, werden sie √ºbersprungen. Nur die neu hinzugef√ºgte Datei in `C:\\A` ist neuer als eine nicht vorhandene Datei in `D:\\B` und wird daher kopiert. Dies ist die Grundlage f√ºr einfache Synchronisierungsaufgaben. ‚úçÔ∏è",
        "difficulty": "experte",
        "category": "Synchronisation"
    },
    {
        "question": "Wahr/Falsch: Der Befehl `tree /f` zeigt nur die Verzeichnisstruktur an, aber keine der darin enthaltenen Dateien. üå≥",
        "options": [
          "Wahr",
          "Falsch"
        ],
        "correct": 1,
        "explain": "**Begr√ºndung:** Falsch. Der `tree`-Befehl allein zeigt nur die Ordnerstruktur. Der Schalter `/f` (Files) erweitert die Anzeige und listet zus√§tzlich die Dateien in jedem Verzeichnis auf. Dies ist sehr n√ºtzlich, um sich einen schnellen √úberblick √ºber den gesamten Inhalt einer Struktur zu verschaffen. üìÑ",
        "difficulty": "einsteiger",
        "category": "Grundlagen der Kommandozeile"
    },
    {
        "question": "Szenario: Ein Skript soll ein Verzeichnis `logs` auf einem Server bereinigen. Der Befehl `del D:\\logs` wird verwendet, schl√§gt aber fehl. Warum? ‚ùå",
        "options": [
          "Der `del`-Befehl ben√∂tigt den `/s`-Schalter.",
          "Der `del`-Befehl kann keine Verzeichnisse l√∂schen, nur Dateien.",
          "Der Pfad muss in Anf√ºhrungszeichen gesetzt werden.",
          "Der Befehl `del` ist veraltet; `erase` muss verwendet werden."
        ],
        "correct": 2,
        "explain": "**Begr√ºndung:** Der `del`-Befehl (oder `erase`) ist ausschlie√ülich zum L√∂schen von **Dateien** vorgesehen. Um ein Verzeichnis zu l√∂schen, muss der `rd`-Befehl (`rmdir`) verwendet werden. Wenn das Verzeichnis `logs` Dateien enth√§lt, w√§re der korrekte Befehl `rd D:\\logs /s /q`. ‚òùÔ∏è",
        "difficulty": "fortgeschritten",
        "category": "Dateisystem-Management"
    },
    {
        "question": "Vergleichende Analyse: `xcopy /d:27-08-2025` vs. `robocopy /maxage:20250827`. Was ist ein wesentlicher Unterschied in der Logik dieser beiden datumsbasierten Filter? üóìÔ∏è",
        "options": [
          "`xcopy` kopiert Dateien, die an oder nach dem Datum ge√§ndert wurden; `robocopy` kopiert Dateien, die √§lter sind als das Datum.",
          "`robocopy` ist genauer, da es die Uhrzeit ber√ºcksichtigt.",
          "`xcopy` kann nur amerikanische Datumsformate verarbeiten.",
          "Es gibt keinen logischen Unterschied, nur die Syntax ist anders."
        ],
        "correct": 0,
        "explain": "**Begr√ºndung:** Die Logik ist genau entgegengesetzt und entscheidend f√ºr den Anwendungsfall. `xcopy /d:[datum]` ist f√ºr Backups gedacht und kopiert alles, was **neu oder neuer** ist. `robocopy /maxage:[datum/tage]` ist f√ºr Aufr√§um- oder Archivierungsaufgaben gedacht und w√§hlt Dateien aus, die **√§lter** sind als das angegebene Datum (oder die Anzahl der Tage), um sie z.B. zu verschieben oder zu l√∂schen. üßπ",
        "difficulty": "experte",
        "category": "Backup-Strategien"
    },
    {
        "question": "Szenario: Ein Admin m√∂chte eine Ordnerstruktur von einem alten auf einen neuen Server spiegeln. Auf dem alten Server wurden auch Dateien gel√∂scht. Diese sollen auf dem neuen Server ebenfalls verschwinden. Welcher Befehl ist daf√ºr ideal?  –∑–µ—Ä–∫–∞–ª–æ (Spiegel) ü™û",
        "options": [
          "xcopy \\\\alt\\share \\\\neu\\share /e /d",
          "robocopy \\\\alt\\share \\\\neu\\share /e",
          "robocopy \\\\alt\\share \\\\neu\\share /mir",
          "xcopy \\\\alt\\share \\\\neu\\share /s /y"
        ],
        "correct": 2,
        "explain": "**Begr√ºndung:** Der Schalter `/mir` (Mirror) von `robocopy` ist genau f√ºr diesen Zweck konzipiert. Er ist eine Kombination aus `/e` (alle Unterverzeichnisse kopieren) und `/purge` (Dateien/Verzeichnisse im Ziel l√∂schen, die in der Quelle nicht mehr existieren). Dadurch wird das Ziel zu einem exakten Abbild der Quelle. `xcopy` hat keine vergleichbare Funktionalit√§t zum L√∂schen von √ºberz√§hligen Dateien im Ziel. ‚ö†Ô∏è **Achtung:** `/mir` kann bei falscher Anwendung Daten l√∂schen! ‚ö†Ô∏è",
        "difficulty": "fortgeschritten",
        "category": "Synchronisation"
    },
    {
        "question": "Berechnungsaufgabe: Der Befehl `xcopy C:\\A D:\\B\\ /e` wird ausgef√ºhrt. Das Verzeichnis `C:\\A` ist komplett leer. Wie viele Verzeichnisse existieren nach dem Befehl auf Laufwerk D, die durch diesen Befehl erstellt wurden (vorausgesetzt D:\\ war leer)? üìÅ",
        "options": [
          "0",
          "1",
          "2",
          "Es tritt ein Fehler auf."
        ],
        "correct": 1,
        "explain": "**Begr√ºndung:** Der Befehl weist `xcopy` an, den Inhalt von `C:\\A` in ein Verzeichnis namens `B` auf Laufwerk `D:` zu kopieren. Da `xcopy` das Zielverzeichnis erstellt, wenn es nicht existiert, wird genau **ein** Verzeichnis (`D:\\B`) angelegt. Da die Quelle `C:\\A` keine Unterverzeichnisse hat, werden auch keine weiteren Verzeichnisse innerhalb von `D:\\B` erstellt. üí°",
        "difficulty": "fortgeschritten",
        "category": "Befehlssyntax"
    },{
            "question": "üóìÔ∏è Ein Administrator f√ºhrt sonntags ein Voll-Backup durch. Am Mittwoch und am Freitag l√§uft jeweils ein differenzielles Backup. Was ist der genaue Inhalt des Backups, das am Freitag erstellt wird?",
            "options": [
                "Nur die √Ñnderungen, die zwischen Mittwoch und Freitag stattgefunden haben.",
                "Alle √Ñnderungen, die seit dem Voll-Backup am Sonntag stattgefunden haben.",
                "Alle Daten des Systems, genau wie beim Voll-Backup.",
                "Die Inhalte des Mittwoch-Backups plus die √Ñnderungen bis Freitag."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Ein **differenzielles Backup** sichert immer alle √Ñnderungen seit dem *letzten Voll-Backup*. üìÇ Das bedeutet, das Backup vom Freitag enth√§lt alle √Ñnderungen von Sonntag bis Freitag. Das Backup vom Mittwoch ist darin vollst√§ndig enthalten. Dies beschleunigt die Wiederherstellung, da nur das Voll-Backup und das letzte differenzielle Backup ben√∂tigt werden, ben√∂tigt aber mit der Zeit mehr Speicherplatz als inkrementelle Backups. üí°",
            "difficulty": "einsteiger",
            "category": "Backup-Strategien"
        },
        {
            "question": "üñ•Ô∏è Sie m√ºssen mit `xcopy` ein Verzeichnis `C:\\Daten` nach `E:\\Backup\\Daten-Backup` kopieren. Welcher Befehl stellt sicher, dass das Ziel als Verzeichnis behandelt wird und auch leere Unterverzeichnisse kopiert werden?",
            "options": [
                "xcopy C:\\Daten E:\\Backup\\Daten-Backup /e",
                "xcopy C:\\Daten E:\\Backup\\Daten-Backup\\ /e",
                "xcopy C:\\Daten E:\\Backup\\Daten-Backup /s",
                "robocopy C:\\Daten E:\\Backup\\Daten-Backup /e"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Backslash `\\` am Ende des Zielpfades (`E:\\Backup\\Daten-Backup\\`) ist ein entscheidender Hinweis f√ºr `xcopy`, dass das Ziel ein Verzeichnis ist. Ohne diesen Backslash w√ºrde `xcopy` nachfragen, ob es sich um eine Datei oder ein Verzeichnis handelt. üìÅ Der Schalter `/e` sorgt daf√ºr, dass alle Unterverzeichnisse, auch leere, mitkopiert werden. `/s` w√ºrde leere Verzeichnisse ignorieren. Option D verwendet `robocopy`, was die Frage nach `xcopy` nicht beantwortet.",
            "difficulty": "einsteiger",
            "category": "xcopy-Befehl"
        },
        {
            "question": "üîÑ Was ist der prim√§re Vorteil einer **inkrementellen** Backup-Strategie gegen√ºber einer **differenziellen**?",
            "options": [
                "Die Wiederherstellung von Daten ist deutlich schneller.",
                "Es wird insgesamt weniger Speicherplatz f√ºr die einzelnen Backups ben√∂tigt.",
                "Es ist keine Voll-Backup-Basis notwendig.",
                "Die einzelnen Backup-Vorg√§nge dauern l√§nger, sind aber sicherer."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Hauptvorteil inkrementeller Backups ist der geringere Speicherbedarf. üíæ Jedes inkrementelle Backup sichert nur die √Ñnderungen seit dem *letzten Backup* (egal ob voll oder inkrementell). Ein differenzielles Backup sichert immer alle √Ñnderungen seit dem *letzten Voll-Backup*, wodurch die Backup-Dateien mit der Zeit anwachsen. Der Nachteil der inkrementellen Methode ist die langsamere und komplexere Wiederherstellung, da das Voll-Backup und *alle* nachfolgenden inkrementellen Backups in der richtigen Reihenfolge ben√∂tigt werden. ‚õìÔ∏è",
            "difficulty": "fortgeschritten",
            "category": "Backup-Strategien"
        },
        {
            "question": "‚öôÔ∏è Ein Admin m√∂chte alle Dateien sichern, die in den letzten 2 Tagen ge√§ndert wurden. Welcher `robocopy`-Befehl ist daf√ºr am besten geeignet und am flexibelsten f√ºr automatisierte Skripte?",
            "options": [
                "robocopy Quelle Ziel /d:08-01-2021",
                "robocopy Quelle Ziel /maxage:2",
                "xcopy Quelle Ziel /d:08-01-2021",
                "robocopy Quelle Ziel /minage:2"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `robocopy` mit dem Parameter `/maxage:2` ist ideal f√ºr diese Aufgabe. `maxage` steht f√ºr 'maximales Alter' und kopiert alle Dateien, deren letztes √Ñnderungsdatum nicht √§lter als 2 Tage ist. üóìÔ∏è Dies ist flexibler als ein festes Datum (`/d:` bei `xcopy`), da das Skript jeden Tag ohne Anpassung des Datums laufen kann. `/minage:2` w√ºrde das Gegenteil tun und nur Dateien kopieren, die *√§lter* als 2 Tage sind.",
            "difficulty": "fortgeschritten",
            "category": "robocopy-Befehl"
        },
        {
            "question": "üìâ Ein Server hat 100 GB Daten. Am Sonntag wird ein Voll-Backup erstellt. Von Montag bis Freitag √§ndern sich t√§glich 5 GB an Daten. Wie viel Speicherplatz belegt das **differenzielle** Backup, das am Freitagabend erstellt wird?",
            "options": [
                "5 GB",
                "10 GB",
                "25 GB",
                "125 GB"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Bei einem differenziellen Backup werden alle √Ñnderungen seit dem letzten Voll-Backup gesichert. üìà\n- Montag: 5 GB ge√§ndert\n- Dienstag: +5 GB ge√§ndert (insgesamt 10 GB seit Sonntag)\n- Mittwoch: +5 GB ge√§ndert (insgesamt 15 GB seit Sonntag)\n- Donnerstag: +5 GB ge√§ndert (insgesamt 20 GB seit Sonntag)\n- Freitag: +5 GB ge√§ndert (insgesamt **25 GB** seit Sonntag)\nDas Backup vom Freitag enth√§lt also alle √Ñnderungen der gesamten Woche.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "üìà Nehmen wir das gleiche Szenario: 100 GB Daten, Voll-Backup am Sonntag, 5 GB t√§gliche √Ñnderungen. Wie viel Speicherplatz belegt das **inkrementelle** Backup, das am Freitagabend erstellt wird?",
            "options": [
                "5 GB",
                "15 GB",
                "25 GB",
                "20 GB"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Ein inkrementelles Backup sichert nur die √Ñnderungen seit dem *letzten* Backup. ‚û°Ô∏è Da am Donnerstag bereits ein Backup lief (das die √Ñnderungen vom Donnerstag sicherte), sichert das Backup am Freitag nur die √Ñnderungen, die am Freitag selbst stattgefunden haben. Das sind genau **5 GB**.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "üîç Ein `xcopy`-Befehl enth√§lt den Schalter `/c`. Was ist die genaue Funktion dieses Schalters w√§hrend des Kopiervorgangs?",
            "options": [
                "Er √ºberpr√ºft (`check`) jede kopierte Datei auf Korrektheit.",
                "Er komprimiert (`compress`) die Dateien w√§hrend der √úbertragung.",
                "Er setzt den Kopiervorgang fort, auch wenn Fehler auftreten (`continue`).",
                "Er erstellt (`create`) das Zielverzeichnis, falls es nicht existiert."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Schalter `/c` steht f√ºr 'continue'. Er weist `xcopy` an, den Kopiervorgang auch dann fortzusetzen, wenn einzelne Dateien nicht gelesen oder geschrieben werden k√∂nnen (z.B. wegen fehlender Berechtigungen oder Lesefehlern). üõ°Ô∏è Dies ist in Backup-Skripten extrem wichtig, um sicherzustellen, dass der gesamte Prozess nicht wegen einer einzelnen fehlerhaften Datei abbricht. Die √úberpr√ºfung (`/v`) und das Erstellen von Verzeichnissen sind andere Funktionen.",
            "difficulty": "einsteiger",
            "category": "xcopy-Befehl"
        },
        {
            "question": "üß© Ein Systemcrash ereignet sich am Samstag. Sie haben ein Voll-Backup von Sonntag und **inkrementelle** Backups von Dienstag, Mittwoch und Freitag. In welcher Reihenfolge m√ºssen Sie die Backups zur vollst√§ndigen Wiederherstellung einspielen?",
            "options": [
                "Voll-Backup -> Freitag -> Mittwoch -> Dienstag",
                "Nur Voll-Backup und das Freitags-Backup",
                "Voll-Backup -> Dienstag -> Mittwoch -> Freitag",
                "Freitag -> Mittwoch -> Dienstag -> Voll-Backup"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Bei einer inkrementellen Sicherung baut jedes Backup auf dem vorherigen auf. üî¢ F√ºr eine vollst√§ndige Wiederherstellung muss die Kette l√ºckenlos und in chronologischer Reihenfolge wiederhergestellt werden. Zuerst wird die Basis (das **Voll-Backup** vom Sonntag) eingespielt, danach jedes einzelne inkrementelle Backup in der Reihenfolge seiner Erstellung (**Dienstag, dann Mittwoch, dann Freitag**). Das Auslassen eines Backups w√ºrde zu Datenverlust f√ºhren.",
            "difficulty": "fortgeschritten",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "‚öñÔ∏è Wahr oder Falsch: Der Befehl `xcopy Quelle Ziel /a` kopiert nur Dateien mit gesetztem Archiv-Attribut und setzt dieses Attribut nach dem Kopiervorgang zur√ºck.",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. Der Schalter `/a` kopiert zwar nur Dateien, bei denen das Archiv-Attribut gesetzt ist, aber er **ver√§ndert dieses Attribut nicht**. üïµÔ∏è‚Äç‚ôÇÔ∏è Der Schalter, der das Attribut nach dem Kopieren zur√ºcksetzt (l√∂scht), ist `/m`. Dieser feine Unterschied ist entscheidend f√ºr die Implementierung von Backup-Strategien. `/m` wird typischerweise f√ºr inkrementelle Backups verwendet, um zu markieren, dass eine Datei gesichert wurde, w√§hrend `/a` f√ºr differenzielle Backups n√ºtzlich sein kann, ohne den Status zu ver√§ndern.",
            "difficulty": "experte",
            "category": "Wahr/Falsch mit komplexer Begr√ºndung"
        },
        {
            "question": "üÜö Worin liegt der entscheidende Vorteil von `robocopy` gegen√ºber `xcopy`, wenn es um das Kopieren in ein nicht existentes Zielverzeichnis geht?",
            "options": [
                "robocopy ist schneller bei der Verzeichniserstellung.",
                "xcopy kann keine neuen Verzeichnisse erstellen.",
                "robocopy erstellt das Zielverzeichnis automatisch, ohne Nachfrage oder spezielle Schalter.",
                "xcopy ben√∂tigt den /i-Schalter, den robocopy nicht hat."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `robocopy` ist explizit f√ºr das Kopieren von Verzeichnisstrukturen konzipiert. Es erkennt automatisch, dass das Ziel ein Verzeichnis ist und erstellt die gesamte notwendige Pfadstruktur ohne weitere Interaktion. ‚úÖ `xcopy` hingegen w√ºrde nachfragen, ob das Ziel eine Datei oder ein Verzeichnis ist, es sei denn, man gibt dies explizit durch einen Backslash am Ende des Pfades an oder verwendet den `/i`-Schalter. Diese Automatik macht `robocopy` f√ºr Skripte deutlich robuster.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "üí° Ein automatisiertes Skript soll t√§glich alle Dateien sichern, die das Archiv-Attribut gesetzt haben. Welcher Befehl ist daf√ºr am besten geeignet, um eine **echte inkrementelle Sicherung** zu realisieren?",
            "options": [
                "xcopy Quelle Ziel /a /e",
                "robocopy Quelle Ziel /a /e",
                "xcopy Quelle Ziel /m /e",
                "robocopy Quelle Ziel /e"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** F√ºr eine echte inkrementelle Sicherung auf Basis des Archiv-Attributs ist `xcopy /m` (oder `robocopy /m`) die korrekte Wahl. Der Schalter `/m` kopiert nur Dateien mit gesetztem Archiv-Attribut und **l√∂scht dieses Attribut nach dem erfolgreichen Kopiervorgang**. üö© Dadurch wird sichergestellt, dass die Datei beim n√§chsten Lauf des Skripts nicht erneut kopiert wird, es sei denn, sie wurde in der Zwischenzeit wieder ver√§ndert (wodurch das Betriebssystem das Attribut neu setzt). `/a` w√ºrde die Datei bei jedem Lauf erneut kopieren.",
            "difficulty": "experte",
            "category": "Datensicherungspraxis"
        },
        {
            "question": "üóÇÔ∏è Welchen gemeinsamen Zweck haben der Schalter `/e` bei `xcopy` und `robocopy`?",
            "options": [
                "Fehler zu ignorieren (Error handling).",
                "Dateien zu exkludieren (Exclude).",
                "Leere Verzeichnisse mitzukopieren (Empty directories).",
                "Existierende Dateien zu √ºberschreiben (Existing files)."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** In beiden Befehlen steht `/e` f√ºr 'empty' und erweitert die Funktionalit√§t des Kopierens von Unterverzeichnissen. Es stellt sicher, dass **alle Unterverzeichnisse, einschlie√ülich der leeren**, in die Zieldestination √ºbernommen werden. üå≥ Dies ist wichtig, um eine exakte Kopie einer Verzeichnisstruktur zu erhalten, da oft auch leere Ordner eine funktionale Bedeutung haben.",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "üî• Ein Admin stellt fest, dass sein differenzielles Backup vom Mittwoch besch√§digt und unbrauchbar ist. Am Freitag l√§uft das n√§chste planm√§√üige differenzielle Backup. Kann er am Samstag eine vollst√§ndige Wiederherstellung durchf√ºhren?",
            "options": [
                "Nein, weil die Kette durch das defekte Backup unterbrochen ist.",
                "Ja, weil nur das Voll-Backup und das letzte funktionierende differenzielle Backup ben√∂tigt werden.",
                "Ja, aber nur die Daten bis Dienstag k√∂nnen wiederhergestellt werden.",
                "Nein, es muss sofort ein neues Voll-Backup erstellt werden."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Ja, das ist einer der gro√üen Vorteile der differenziellen Strategie. Jedes differenzielle Backup enth√§lt *alle* √Ñnderungen seit dem letzten Voll-Backup. ‚úÖ Das bedeutet, das funktionierende Backup vom Freitag enth√§lt auch alle √Ñnderungen, die im defekten Mittwoch-Backup enthalten gewesen w√§ren. Zur Wiederherstellung ben√∂tigt man also nur das **Voll-Backup vom Sonntag** und das **funktionierende differenzielle Backup vom Freitag**. Das defekte Backup vom Mittwoch ist irrelevant.",
            "difficulty": "experte",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "‚è≥ Eine Datei wurde vor 5 Tagen erstellt und zuletzt vor 2 Tagen ge√§ndert. Ein `robocopy`-Skript mit dem Parameter `/maxage:3` wird heute ausgef√ºhrt. Wird die Datei kopiert?",
            "options": [
                "Nein, weil die Datei √§lter als 3 Tage ist.",
                "Ja, weil das letzte √Ñnderungsdatum innerhalb des 3-Tage-Fensters liegt.",
                "Nein, weil /maxage sich auf das Erstellungsdatum bezieht.",
                "Ja, aber nur, wenn auch der /a Schalter gesetzt ist."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Parameter `/maxage` von `robocopy` bezieht sich auf das Datum der **letzten √Ñnderung**, nicht auf das Erstellungsdatum. ‚úçÔ∏è Da die Datei vor 2 Tagen zuletzt ge√§ndert wurde, ist sie 'j√ºnger' als die im Befehl angegebene Grenze von 3 Tagen. Daher wird die Datei kopiert. Das urspr√ºngliche Erstellungsdatum ist f√ºr diesen Parameter irrelevant.",
            "difficulty": "experte",
            "category": "robocopy-Befehl"
        },
        {
            "question": "‚ö†Ô∏è Laut dem Text bietet `robocopy` einen entscheidenden Vorteil f√ºr die Nachverfolgung von Backup-Vorg√§ngen, insbesondere wenn diese unbeaufsichtigt (z.B. am Wochenende) laufen. Welcher Vorteil ist das?",
            "options": [
                "Es sendet automatisch eine E-Mail-Benachrichtigung.",
                "Es ist von Natur aus fehlerfrei.",
                "Es kann eine detaillierte Log-Datei erstellen.",
                "Es √ºberpr√ºft die Datenintegrit√§t mit Checksummen."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Text hebt hervor, dass `robocopy` die M√∂glichkeit bietet, eine **Log-Datei** zu erstellen. üìù Mit Schaltern wie `/log:datei.log` kann der gesamte Kopiervorgang, inklusive aller Erfolgsmeldungen, Fehler und einer Zusammenfassung, in eine Textdatei geschrieben werden. Dies erm√∂glicht es Administratoren, am Montagmorgen zu √ºberpr√ºfen, ob der Wochenend-Backup-Job erfolgreich war, ohne die gesamte Konsolenausgabe durchsuchen zu m√ºssen.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "ü§î Warum ist der Befehl `xcopy Quelle Ziel /d:mm-tt-jjjj /e /c /v` eine Implementierung einer **differenziellen** und nicht einer inkrementellen Sicherung?",
            "options": [
                "Weil der Schalter /v eine vollst√§ndige √úberpr√ºfung durchf√ºhrt.",
                "Weil das Datum fest ist und sich nicht auf das letzte Backup bezieht.",
                "Weil der Schalter /c Fehler ignoriert, was typisch f√ºr differenzielle Backups ist.",
                "Weil der Schalter /a fehlt."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der entscheidende Punkt ist der Schalter `/d:mm-tt-jjjj`. Er weist `xcopy` an, alle Dateien zu kopieren, die an oder nach diesem **festen Datum** ge√§ndert wurden. üìå Wenn dieses Datum das Datum des letzten Voll-Backups ist, werden bei jedem Lauf alle seitdem ge√§nderten Dateien kopiert ‚Äì die genaue Definition eines differenziellen Backups. F√ºr ein inkrementelles Backup m√ºsste der Zustand (z.B. √ºber das Archiv-Attribut mit `/m`) nach jedem Lauf ver√§ndert werden, um nur die √Ñnderungen seit dem *letzten* Lauf zu sichern.",
            "difficulty": "experte",
            "category": "Datensicherungspraxis"
        },
        {
            "question": "üíæ Ein Unternehmen sichert 1 TB an Daten. Ein Voll-Backup wird sonntags erstellt. Von Montag bis Freitag fallen t√§glich 20 GB an neuen/ge√§nderten Daten an. Wie viel Speicherplatz wird **insgesamt** f√ºr die Sicherungen von Montag bis Freitag bei einer **inkrementellen** Strategie ben√∂tigt?",
            "options": [
                "20 GB",
                "100 GB",
                "300 GB",
                "1.1 TB"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Bei einer inkrementellen Strategie wird jeden Tag nur der Zuwachs seit dem Vortag gesichert. ‚ûï\n- Montag: 20 GB\n- Dienstag: 20 GB\n- Mittwoch: 20 GB\n- Donnerstag: 20 GB\n- Freitag: 20 GB\nDie Gesamtmenge des ben√∂tigten Speichers f√ºr die Wochentags-Backups ist die Summe der einzelnen Teile: 5 Tage * 20 GB/Tag = **100 GB**.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "üíΩ Im selben Szenario (1 TB Daten, 20 GB t√§gliche √Ñnderung), wie viel Speicherplatz wird **insgesamt** f√ºr die Sicherungen von Montag bis Freitag bei einer **differenziellen** Strategie ben√∂tigt?",
            "options": [
                "100 GB",
                "200 GB",
                "300 GB",
                "400 GB"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Bei einer differenziellen Strategie w√§chst die Gr√∂√üe des t√§glichen Backups an. üìà\n- Montag: 20 GB\n- Dienstag: 40 GB (√Ñnderungen von Mo+Di)\n- Mittwoch: 60 GB (Mo+Di+Mi)\n- Donnerstag: 80 GB (Mo-Do)\n- Freitag: 100 GB (Mo-Fr)\nDie Gesamtmenge des belegten Speichers ist die Summe dieser einzelnen Backups: 20 + 40 + 60 + 80 + 100 = **300 GB**.",
            "difficulty": "experte",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "üöÄ Welche Backup-Methode bietet typischerweise die **schnellsten einzelnen Backup-Vorg√§nge** w√§hrend der Woche, aber die **langsamste und komplexeste Wiederherstellung**?",
            "options": [
                "Voll-Backup",
                "Differenzielles Backup",
                "Inkrementelles Backup",
                "Spiegelung (Mirroring)"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Das **inkrementelle Backup** ist w√§hrend der Woche am schnellsten, da t√§glich nur die geringste Datenmenge (die √Ñnderungen seit dem Vortag) gesichert werden muss. üí® Die Wiederherstellung ist jedoch am langsamsten und fehleranf√§lligsten, da zuerst das Voll-Backup und dann jedes einzelne inkrementelle Backup in der korrekten Reihenfolge eingespielt werden muss. Ein Fehler in dieser Kette kompromittiert die gesamte Wiederherstellung. üê¢",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "üìú Wahr oder Falsch: `robocopy` ist, genau wie `xcopy`, eine 32-Bit-Anwendung, die sich im Verzeichnis `C:\\Windows\\System32` befindet und direkt in der CMD aufgerufen werden kann.",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Wahr. Der Text erw√§hnt explizit, dass `robocopy.exe` sich, wie `xcopy.exe`, im System32-Verzeichnis befindet. ‚úÖ Obwohl moderne Windows-Versionen 64-Bit sind, werden viele dieser klassischen Kommandozeilen-Tools aus Kompatibilit√§tsgr√ºnden weiterhin als 32-Bit- (oder inzwischen auch als 64-Bit-) Anwendungen ausgeliefert und sind √ºber den System-PATH direkt in jeder Kommandozeile verf√ºgbar.",
            "difficulty": "einsteiger",
            "category": "Wahr/Falsch mit komplexer Begr√ºndung"
        },{
            "question": "üíª Sie erhalten die Fehlermeldung 'Der Befehl \"dri\" ist entweder falsch geschrieben oder konnte nicht gefunden werden.' Was ist die wahrscheinlichste Ursache?",
            "options": [
                "Das System hat einen kritischen Fehler",
                "Der Befehl wurde falsch geschrieben (sollte 'dir' hei√üen)",
                "Die Festplatte ist defekt",
                "Der Benutzer hat keine Berechtigung"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** Dies ist ein klassischer Syntax-Error - der Befehl 'dri' existiert nicht, gemeint war 'dir'. üîç Die Fehlermeldung deutet eindeutig auf einen Tippfehler hin. Windows CMD ist case-insensitive, aber der Befehlsname muss korrekt geschrieben werden. üìù Andere Optionen w√ºrden andere Fehlermeldungen verursachen.",
            "difficulty": "einsteiger",
            "category": "Kommandozeileninterpreter"
        },
        {
            "question": "üÜò Mit welchem Befehl k√∂nnen Sie sich Hilfe zum 'copy' Befehl anzeigen lassen?",
            "options": [
                "copy /?",
                "help copy",
                "copy -help",
                "Sowohl A als auch B sind korrekt"
            ],
            "correct": [3],
            "explain": "**Begr√ºndung:** Beide Varianten funktionieren! üí° 'copy /?' zeigt die Hilfe direkt an, 'help copy' macht dasselbe. Die Syntax 'copy -help' ist Unix-Style und funktioniert in Windows CMD nicht. üö´ Windows verwendet den Forward-Slash (/) f√ºr Parameter, nicht den Bindestrich (-).",
            "difficulty": "einsteiger",
            "category": "Hilfe-System"
        },
        {
            "question": "‚öôÔ∏è Welche Zeichen haben in der Windows CMD eine besondere Bedeutung und m√ºssen daher vorsichtig verwendet werden?",
            "options": [
                "> < | * ?",
                "/ \\ : ; ,",
                "> \\ * ? | und Leerzeichen",
                "Nur > und <"
            ],
            "correct": [2],
            "explain": "**Begr√ºndung:** Diese Zeichen sind Wildcards und Operatoren: üî∏ '>' (Umleitung), '\\' (Pfadtrenner), '*' (Wildcard f√ºr mehrere Zeichen), '?' (Wildcard f√ºr ein Zeichen), '|' (Pipe-Operator). üö® Leerzeichen trennen Parameter, daher m√ºssen Pfade mit Leerzeichen in Anf√ºhrungszeichen gesetzt werden.",
            "difficulty": "fortgeschritten",
            "category": "Sonderzeichen"
        },
        {
            "question": "üìÅ Was zeigt der Prompt 'C:\\Windows\\System32>' an?",
            "options": [
                "Sie befinden sich im System32-Ordner auf Laufwerk C:",
                "Sie befinden sich im Windows-Ordner",
                "Das System ist gesperrt",
                "Ein Fehler ist aufgetreten"
            ],
            "correct": [0],
            "explain": "**Begr√ºndung:** Der Prompt zeigt immer das aktuelle Verzeichnis an. üìç 'C:' = Laufwerk, '\\Windows\\System32' = Pfad zum aktuellen Ordner. Der System32-Ordner enth√§lt wichtige Systemdateien. üõ°Ô∏è Das '>' Zeichen markiert das Ende des Prompts und zeigt, dass das System bereit f√ºr Eingaben ist.",
            "difficulty": "einsteiger",
            "category": "Pfadangaben"
        },
        {
            "question": "üîß Was ist die Hauptfunktion der PATH-Umgebungsvariable?",
            "options": [
                "Sie zeigt das aktuelle Verzeichnis an",
                "Sie definiert, in welchen Ordnern nach ausf√ºhrbaren Dateien gesucht wird",
                "Sie speichert alle Dateinamen",
                "Sie kontrolliert die Bildschirmaufl√∂sung"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** PATH ist der Suchpfad! üîç Wenn Sie einen Befehl eingeben, sucht Windows in allen PATH-Verzeichnissen nach der entsprechenden .exe/.com/.bat Datei. üìÇ Ohne PATH m√ºssten Sie immer den vollst√§ndigen Pfad zu Programmen angeben. Mit 'echo %PATH%' k√∂nnen Sie den aktuellen Suchpfad anzeigen.",
            "difficulty": "fortgeschritten",
            "category": "Suchpfad"
        },
        {
            "question": "üìÑ Wie ist ein Windows-Dateiname korrekt aufgebaut?",
            "options": [
                "Name.Erweiterung (z.B. dokument.txt)",
                "Erweiterung.Name (z.B. txt.dokument)",
                "Nur der Name ohne Punkt",
                "Name_Erweiterung (z.B. dokument_txt)"
            ],
            "correct": [0],
            "explain": "**Begr√ºndung:** Windows-Dateinamen bestehen aus Name + Punkt + Dateierweiterung. üìù Die Erweiterung (z.B. .txt, .exe, .doc) zeigt Windows, welches Programm die Datei √∂ffnen soll. üéØ Der Punkt ist das Trennzeichen - ohne ihn erkennt Windows den Dateityp nicht korrekt.",
            "difficulty": "einsteiger",
            "category": "Dateinamen"
        },
        {
            "question": "üïí Welcher Befehl zeigt die aktuelle Systemzeit an?",
            "options": [
                "clock",
                "time",
                "gettime",
                "datetime"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'time' zeigt die aktuelle Zeit an und erm√∂glicht auch deren √Ñnderung. üïê Mit 'time /t' wird nur die Zeit angezeigt ohne √Ñnderungsm√∂glichkeit. üìÖ Entsprechend zeigt 'date' das aktuelle Datum an. Diese Befehle geh√∂ren zu den grundlegenden CMD-Utilities.",
            "difficulty": "einsteiger",
            "category": "Allgemeine Befehle"
        },
        {
            "question": "üßπ Was bewirkt der Befehl 'cls'?",
            "options": [
                "Schlie√üt das CMD-Fenster",
                "L√∂scht alle Dateien",
                "L√∂scht den Bildschirminhalt der Konsole",
                "Startet das System neu"
            ],
            "correct": [2],
            "explain": "**Begr√ºndung:** 'cls' steht f√ºr 'Clear Screen' und l√∂scht den sichtbaren Inhalt der Konsole. üßΩ Der Befehlsverlauf bleibt erhalten (mit Pfeiltasten abrufbar), nur die Anzeige wird geleert. üì∫ Praktisch f√ºr einen 'sauberen' Bildschirm beim Arbeiten.",
            "difficulty": "einsteiger",
            "category": "Allgemeine Befehle"
        },
        {
            "question": "üíø Wie wechseln Sie von Laufwerk C: zu Laufwerk D:?",
            "options": [
                "cd D:",
                "D:",
                "change D:",
                "goto D:"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** Einfach 'D:' eingeben wechselt zum Laufwerk D. üîÑ Der 'cd' Befehl wechselt nur Verzeichnisse, nicht Laufwerke. üíæ Nach dem Laufwerkswechsel sind Sie im zuletzt verwendeten Verzeichnis dieses Laufwerks (oder im Root-Verzeichnis).",
            "difficulty": "einsteiger",
            "category": "Datentr√§ger-Befehle"
        },
        {
            "question": "üè∑Ô∏è Mit welchem Befehl k√∂nnen Sie ein Laufwerk umbenennen (Label setzen)?",
            "options": [
                "rename",
                "label",
                "name",
                "title"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'label' setzt oder √§ndert die Bezeichnung (Label) eines Laufwerks. üè∑Ô∏è Beispiel: 'label C: MeinSystem' benennt Laufwerk C: zu 'MeinSystem'. Mit 'vol' k√∂nnen Sie das aktuelle Label anzeigen. üìã Das Label ist nur kosmetisch und beeinflusst nicht die Funktion.",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§ger-Befehle"
        },
        {
            "question": "üîç Was kann das Tool 'diskpart' NICHT?",
            "options": [
                "Partitionen erstellen und l√∂schen",
                "Laufwerksbuchstaben zuweisen",
                "Dateien kopieren und verschieben",
                "Festplatten formatieren"
            ],
            "correct": [2],
            "explain": "**Begr√ºndung:** diskpart ist ein m√§chtiges Partitionierungs-Tool f√ºr Datentr√§ger-Management. üí™ Es kann Partitionen verwalten, formatieren, Laufwerksbuchstaben zuweisen - aber KEINE Dateiverwaltung! üìÅ F√ºr Dateien sind Befehle wie copy, move, del zust√§ndig. diskpart arbeitet auf Partitionsebene, nicht auf Dateiebene.",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§ger-Befehle"
        },
        {
            "question": "üìÇ Welcher Befehl erstellt ein neues Verzeichnis?",
            "options": [
                "cd",
                "md",
                "rd",
                "dir"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'md' (Make Directory) oder 'mkdir' erstellt neue Verzeichnisse. üìÅ Beispiel: 'md NeuerOrdner' erstellt den Ordner 'NeuerOrdner'. 'cd' wechselt Verzeichnisse, 'rd' l√∂scht sie, 'dir' zeigt den Inhalt an. üèóÔ∏è Mit 'md Pfad\\Unterordner' k√∂nnen auch Unterordner-Strukturen erstellt werden.",
            "difficulty": "einsteiger",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "üóÇÔ∏è Was zeigt der Befehl 'tree' an?",
            "options": [
                "Nur Dateien im aktuellen Ordner",
                "Die Verzeichnisstruktur als Baumdarstellung",
                "Nur versteckte Dateien",
                "Den Inhalt der Zwischenablage"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'tree' zeigt die komplette Verzeichnisstruktur als Baum-Diagramm an. üå≥ Mit Linien und √Ñsten wird die Hierarchie visualisiert. Parameter: 'tree /f' zeigt auch Dateien, 'tree /a' verwendet ASCII-Zeichen statt Grafikzeichen. üìä Sehr n√ºtzlich f√ºr einen √úberblick √ºber Ordnerstrukturen.",
            "difficulty": "fortgeschritten",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "üîÑ Was ist der Unterschied zwischen 'xcopy' und 'robocopy'?",
            "options": [
                "Kein Unterschied, beide sind identisch",
                "xcopy ist f√ºr einzelne Dateien, robocopy f√ºr Ordner",
                "robocopy ist robuster und bietet erweiterte Funktionen wie Wiederholung bei Fehlern",
                "xcopy funktioniert nur bei kleinen Dateien"
            ],
            "correct": [2],
            "explain": "**Begr√ºndung:** robocopy (Robust File Copy) ist der Nachfolger von xcopy mit deutlich mehr Funktionen! üöÄ robocopy kann unterbrochene Kopiervorg√§nge fortsetzen, hat bessere Fehlerbehandlung, Logging, Multithreading und viele Filteroptionen. üí™ xcopy ist einfacher, robocopy professioneller f√ºr gr√∂√üere Backup-Aufgaben.",
            "difficulty": "experte",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "üìÑ Wie k√∂nnen Sie den Inhalt einer Textdatei in der Konsole anzeigen?",
            "options": [
                "read datei.txt",
                "type datei.txt",
                "show datei.txt",
                "cat datei.txt"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'type' zeigt den Inhalt von Textdateien direkt in der Konsole an. üìñ Beispiel: 'type readme.txt'. Bei langen Dateien k√∂nnen Sie 'type datei.txt | more' verwenden f√ºr seitenweise Anzeige. üìú 'cat' ist ein Unix-Befehl und funktioniert in Windows CMD standardm√§√üig nicht.",
            "difficulty": "einsteiger",
            "category": "Datei-Befehle"
        },
        {
            "question": "‚úèÔ∏è Wie erstellen Sie eine neue Textdatei mit dem Inhalt 'Hallo Welt'?",
            "options": [
                "copy con test.txt (dann Inhalt eingeben und Strg+Z)",
                "create test.txt Hallo Welt",
                "new test.txt Hallo Welt",
                "make test.txt Hallo Welt"
            ],
            "correct": [0],
            "explain": "**Begr√ºndung:** 'copy con dateiname.txt' ist der klassische CMD-Weg zum Erstellen von Textdateien! ‚úçÔ∏è Nach der Eingabe tippen Sie den Text, dr√ºcken Enter f√ºr eine neue Zeile und beenden mit Strg+Z (oder F6). üíæ 'con' steht f√ºr Console - Sie kopieren quasi von der Konsole in die Datei.",
            "difficulty": "fortgeschritten",
            "category": "Datei-Befehle"
        },
        {
            "question": "üè∑Ô∏è Was bewirkt das Dateiattribut 'h' bei einer Datei?",
            "options": [
                "Die Datei wird schreibgesch√ºtzt",
                "Die Datei wird versteckt (hidden)",
                "Die Datei wird als Systemdatei markiert",
                "Die Datei wird automatisch gesichert"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** Das 'h'-Attribut macht Dateien 'hidden' (versteckt). üëª Versteckte Dateien werden im Explorer und bei 'dir' standardm√§√üig nicht angezeigt. Mit 'dir /a:h' oder 'attrib' k√∂nnen Sie sie sichtbar machen. üîç Andere Attribute: 'r'=readonly, 's'=system, 'a'=archive.",
            "difficulty": "fortgeschritten",
            "category": "Dateiattribute"
        },
        {
            "question": "üîí Eine Datei hat die Attribute 'r' und 'h'. Was bedeutet das?",
            "options": [
                "Die Datei ist nur lesbar und versteckt",
                "Die Datei ist besch√§digt",
                "Die Datei ist verschl√ºsselt",
                "Die Datei ist eine Systemdatei"
            ],
            "correct": [0],
            "explain": "**Begr√ºndung:** 'r' = read-only (schreibgesch√ºtzt), 'h' = hidden (versteckt). üîê Die Datei kann gelesen aber nicht ver√§ndert werden und ist standardm√§√üig unsichtbar. Mit 'attrib -r -h datei.txt' k√∂nnen beide Attribute entfernt werden. üëÅÔ∏è Kombination mehrerer Attribute ist normal f√ºr Systemdateien.",
            "difficulty": "fortgeschritten",
            "category": "Dateiattribute"
        },
        {
            "question": "üìù Welcher Editor wird standardm√§√üig ge√∂ffnet, wenn Sie 'notepad datei.txt' eingeben?",
            "options": [
                "Microsoft Word",
                "Windows Editor (Notepad)",
                "CMD-eigener Editor",
                "Internet Explorer"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'notepad' startet den Windows-Editor (Notepad.exe) zum Bearbeiten von Textdateien. üìù Wenn die Datei nicht existiert, fragt Notepad, ob sie erstellt werden soll. ‚ú® Notepad ist ideal f√ºr einfache Textbearbeitung, Konfigurationsdateien und Scripting. F√ºr gr√∂√üere Projekte sind spezialisierte Editoren besser geeignet.",
            "difficulty": "einsteiger",
            "category": "Text-Editoren"
        },
        {
            "question": "‚ö†Ô∏è Sie geben 'format C:' ein. Was passiert?",
            "options": [
                "Das System wird optimiert",
                "Alle Daten auf C: werden gel√∂scht und das Laufwerk neu formatiert",
                "Die Festplatte wird defragmentiert",
                "Tempor√§re Dateien werden gel√∂scht"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'format' l√∂scht ALLE Daten und erstellt ein neues Dateisystem! üíÄ EXTREM GEF√ÑHRLICH f√ºr das Systemlaufwerk C:. Windows wird normalerweise eine Warnung anzeigen oder den Befehl blockieren. ‚ö†Ô∏è Format sollte nur f√ºr leere Datentr√§ger oder bewusste Neuinstallationen verwendet werden. Immer Daten sichern!",
            "difficulty": "experte",
            "category": "Gef√§hrliche Befehle"
        },
        {
            "question": "üîß Was macht der Befehl 'chkdsk C: /f'?",
            "options": [
                "Formatiert das Laufwerk C:",
                "Pr√ºft das Laufwerk C: auf Fehler und repariert sie automatisch",
                "Zeigt nur Informationen √ºber das Laufwerk an",
                "L√∂scht tempor√§re Dateien"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'chkdsk' (Check Disk) pr√ºft Dateisystem-Fehler. üîç Der Parameter '/f' bedeutet 'fix' - gefundene Fehler werden automatisch repariert. ‚ö° Auf dem Systemlaufwerk l√§uft chkdsk meist beim n√§chsten Neustart. '/r' w√ºrde zus√§tzlich defekte Sektoren suchen und reparieren. üõ†Ô∏è Wichtiges Wartungs-Tool!",
            "difficulty": "fortgeschritten",
            "category": "Systempflege"
        },
        {
            "question": "üìä Welcher Parameter von 'dir' zeigt auch versteckte Dateien an?",
            "options": [
                "/h",
                "/hidden",
                "/a",
                "/all"
            ],
            "correct": [2],
            "explain": "**Begr√ºndung:** 'dir /a' zeigt ALLE Dateien inklusive versteckter an. üëÅÔ∏è Spezifischer: '/a:h' nur versteckte, '/a:s' nur System-Dateien, '/a:d' nur Verzeichnisse. Der '/a'-Parameter steht f√ºr 'attributes' und ist sehr m√§chtig f√ºr gefilterte Anzeigen. üéØ Ohne Parameter zeigt 'dir' nur normale, sichtbare Dateien.",
            "difficulty": "fortgeschritten",
            "category": "Datei-Anzeige"
        },
        {
            "question": "üîÑ Was bewirkt 'ren alt.txt neu.txt'?",
            "options": [
                "Kopiert alt.txt zu neu.txt",
                "Benennt alt.txt in neu.txt um",
                "L√∂scht beide Dateien",
                "Vergleicht beide Dateien"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'ren' (oder 'rename') benennt Dateien oder Ordner um. üîÑ Die urspr√ºngliche Datei 'alt.txt' wird zu 'neu.txt', der Inhalt bleibt unver√§ndert. Keine Kopie wird erstellt! üìÅ Funktioniert auch f√ºr Verzeichnisse: 'ren AlterOrdner NeuerOrdner'. Der Befehl ist sehr effizient, da nur der Dateisystem-Eintrag ge√§ndert wird.",
            "difficulty": "einsteiger",
            "category": "Datei-Befehle"
        },
        {
            "question": "üí® Was ist der Unterschied zwischen 'copy' und 'move'?",
            "options": [
                "Kein Unterschied",
                "copy erstellt eine Kopie, move verschiebt die Datei (Original wird gel√∂scht)",
                "move ist schneller als copy",
                "copy funktioniert nur bei kleinen Dateien"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** Wichtiger Unterschied! üìã 'copy' erstellt eine Kopie - Original bleibt erhalten. 'move' verschiebt die Datei - Original wird gel√∂scht. üöö 'move' ist effizienter beim Verschieben auf demselben Laufwerk (nur Dateisystem-Eintrag √§ndert sich). Zwischen Laufwerken muss auch 'move' kopieren und dann l√∂schen.",
            "difficulty": "fortgeschritten",
            "category": "Datei-Operationen"
        },
        {
            "question": "üóëÔ∏è Welcher Befehl l√∂scht die Datei 'test.txt' endg√ºltig?",
            "options": [
                "remove test.txt",
                "delete test.txt",
                "del test.txt",
                "erase test.txt"
            ],
            "correct": [2],
            "explain": "**Begr√ºndung:** 'del' (oder 'erase') l√∂scht Dateien dauerhaft! üóëÔ∏è Die Dateien landen NICHT im Papierkorb, sondern sind sofort weg. ‚ö†Ô∏è 'del *.*' l√∂scht alle Dateien im aktuellen Ordner. Parameter '/p' fragt vor jedem L√∂schen nach, '/q' l√∂scht ohne Nachfrage. Vorsicht ist geboten!",
            "difficulty": "einsteiger",
            "category": "Datei-Befehle"
        },
        {
            "question": "üîç Sie wollen alle .txt-Dateien im aktuellen Ordner auflisten. Welcher Befehl ist korrekt?",
            "options": [
                "dir *.txt",
                "dir .txt",
                "dir txt",
                "list *.txt"
            ],
            "correct": [0],
            "explain": "**Begr√ºndung:** 'dir *.txt' nutzt Wildcards! ‚≠ê Der Stern (*) steht f√ºr beliebig viele Zeichen. Zeigt alle Dateien an, die auf .txt enden. üéØ '?' steht f√ºr genau ein Zeichen. Beispiele: 'dir a*.doc' (alle .doc-Dateien die mit 'a' beginnen), 'dir ???.exe' (alle .exe-Dateien mit 3-stelligem Namen).",
            "difficulty": "fortgeschritten",
            "category": "Wildcards"
        },
        {
            "question": "üìÅ Was passiert bei 'rd /s MeinOrdner'?",
            "options": [
                "Der Ordner wird nur umbenannt",
                "Der Ordner und ALLE Inhalte werden gel√∂scht",
                "Nur leere Unterordner werden gel√∂scht",
                "Der Ordner wird versteckt"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** 'rd' (Remove Directory) mit '/s' l√∂scht den Ordner UND alle Inhalte rekursiv! üí• SEHR GEF√ÑHRLICH - alle Dateien und Unterordner sind unwiederbringlich weg. '/q' w√ºrde zus√§tzlich ohne Nachfrage l√∂schen. ‚ö†Ô∏è Ohne '/s' funktioniert 'rd' nur bei leeren Ordnern. Immer vorher Backup erstellen!",
            "difficulty": "experte",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "‚ö° Was bewirkt 'cd ..' ?",
            "options": [
                "Wechselt zum √ºbergeordneten Verzeichnis",
                "Zeigt versteckte Dateien an",
                "L√∂scht das aktuelle Verzeichnis",
                "Erstellt einen neuen Ordner"
            ],
            "correct": [0],
            "explain": "**Begr√ºndung:** 'cd ..' wechselt eine Ebene nach oben in der Verzeichnishierarchie! ‚¨ÜÔ∏è '..' ist eine spezielle Referenz auf das √ºbergeordnete Verzeichnis. '.' steht f√ºr das aktuelle Verzeichnis. üè† 'cd \\' springt direkt zum Root-Verzeichnis des Laufwerks. Sehr praktisch f√ºr Navigation!",
            "difficulty": "einsteiger",
            "category": "Navigation"
        },
        {
            "question": "üîß Welche Aussage √ºber CMD-Parameter ist FALSCH?",
            "options": [
                "Parameter beginnen meist mit '/' (z.B. /s, /p)",
                "Parameter k√∂nnen kombiniert werden (z.B. /s /q)",
                "Die Reihenfolge der Parameter ist immer wichtig",
                "Manche Parameter erwarten zus√§tzliche Werte"
            ],
            "correct": [2],
            "explain": "**Begr√ºndung:** Die Reihenfolge der Parameter ist meist NICHT wichtig! ‚úÖ 'dir /s /p' funktioniert genauso wie 'dir /p /s'. Windows CMD ist hier flexibel. üîÑ Parameter starten mit '/', k√∂nnen kombiniert werden und manche brauchen Werte (z.B. '/t:w' f√ºr Zeitformat). Die meisten Befehle sind tolerant bei der Parameter-Reihenfolge.",
            "difficulty": "fortgeschritten",
            "category": "Parameter-Syntax"
        },
        {
            "question": "üéØ Sie sind in C:\\Windows und geben 'cd System32' ein. Wo befinden Sie sich danach?",
            "options": [
                "C:\\System32",
                "C:\\Windows\\System32",
                "Fehlermeldung - Ordner existiert nicht",
                "C:\\"
            ],
            "correct": [1],
            "explain": "**Begr√ºndung:** Relative Pfadangabe! üìç 'cd System32' ohne Backslash am Anfang bedeutet: wechsle in den Unterordner 'System32' des aktuellen Verzeichnisses. Da Sie in C:\\Windows sind, landen Sie in C:\\Windows\\System32. üéØ 'cd \\System32' w√ºrde dagegen zu C:\\System32 f√ºhren (absoluter Pfad).",
            "difficulty": "fortgeschritten",
            "category": "Pfadnavigation"
        },
        {
      "question": "üìü Ein Nutzer gibt in CMD den Befehl `copi file.txt` ein und erh√§lt eine Fehlermeldung. Was ist passiert?",
      "options": [
        "Der Befehl existiert nicht, weil er falsch geschrieben wurde",
        "Die Datei file.txt existiert nicht",
        "Der Nutzer hat keine Berechtigungen",
        "Die Datei-Endung ist fehlerhaft"
      ],
      "correct": [0],
      "explain": "**Begr√ºndung:** CMD reagiert sehr strikt auf Syntax. Der richtige Befehl lautet `copy`, nicht `copi`. üëÄ\n- Andere Optionen sind m√∂glich, w√ºrden aber andere Fehlermeldungen erzeugen (z. B. 'Datei nicht gefunden').",
      "difficulty": "einsteiger",
      "category": "CMD-Grundlagen"
    },
    {
      "question": "üÜò Wie kann man sich in CMD die Hilfe zu einem bestimmten Befehl anzeigen lassen?",
      "options": [
        "Mit `hilfe Befehl`",
        "Mit `Befehl /?` oder `help Befehl`",
        "Mit `cmdhelp Befehl`",
        "Mit `man Befehl`"
      ],
      "correct": [1],
      "explain": "**Begr√ºndung:** In CMD funktioniert Hilfe √ºber `Befehl /?` oder `help Befehl`. üìñ\n- `hilfe` und `man` stammen aus anderen Umgebungen (Linux, PowerShell).",
      "difficulty": "einsteiger",
      "category": "CMD-Grundlagen"
    },
    {
      "question": "üõ†Ô∏è Szenario: Du gibst den Befehl `cd C:\\Programme\\` ein, erh√§ltst aber 'Das System kann den angegebenen Pfad nicht finden'. Was ist die wahrscheinlichste Ursache?",
      "options": [
        "Der Pfad ist falsch, weil Leerzeichen in 'Programme' nicht beachtet wurden",
        "Der Laufwerksbuchstabe ist falsch",
        "Der Benutzer hat keine Berechtigungen",
        "Das Programm-Verzeichnis existiert nicht"
      ],
      "correct": [0],
      "explain": "**Begr√ºndung:** Bei Leerzeichen im Pfad m√ºssen Anf√ºhrungszeichen gesetzt werden: `cd \"C:\\Programme\"`. Ohne sie interpretiert CMD den Pfad falsch. ‚ö†Ô∏è",
      "difficulty": "fortgeschritten",
      "category": "Pfadangaben"
    },
    {
      "question": "üìÇ Welcher Befehl zeigt alle Dateien und Unterordner eines Verzeichnisses in Baumstruktur an?",
      "options": [
        "tree",
        "dir /s",
        "ls -R",
        "foldermap"
      ],
      "correct": [0],
      "explain": "**Begr√ºndung:** `tree` zeigt eine grafische Baumstruktur. üå≥\n- `dir /s` listet ebenfalls rekursiv auf, aber nicht als Baum.\n- `ls -R` geh√∂rt zu Linux.",
      "difficulty": "einsteiger",
      "category": "Verzeichnis-Befehle"
    },
    {
      "question": "üíæ Welche Funktion hat der Befehl `diskpart`?",
      "options": [
        "Dateien kopieren",
        "Partitionen und Datentr√§ger verwalten",
        "Systemzeit √§ndern",
        "Dateiattribute √§ndern"
      ],
      "correct": [1],
      "explain": "**Begr√ºndung:** `diskpart` ist ein m√§chtiges Tool zur Partitionierung und Datentr√§gerverwaltung. üîß\n- Alle anderen Befehle geh√∂ren zu anderen Kategorien.",
      "difficulty": "fortgeschritten",
      "category": "Datentr√§ger-Befehle"
    },
    {
      "question": "‚ö° Szenario: Ein Anwender m√∂chte alle Dateien von `C:\\Users\\Test` nach `D:\\Backup` kopieren, inklusive Unterordner und Attribute. Welcher Befehl ist am besten geeignet?",
      "options": [
        "copy C:\\Users\\Test D:\\Backup",
        "xcopy C:\\Users\\Test D:\\Backup /E /H /K",
        "robocopy C:\\Users\\Test D:\\Backup",
        "move C:\\Users\\Test D:\\Backup"
      ],
      "correct": [2],
      "explain": "**Begr√ºndung:** `robocopy` ist der robusteste Befehl f√ºr umfangreiche Kopieraktionen und erh√§lt Attribute. üöö\n- `xcopy` ist veraltet, aber mit Schaltern noch nutzbar.\n- `copy` ist f√ºr einfache Dateien.",
      "difficulty": "fortgeschritten",
      "category": "Verzeichnis-Befehle"
    },
    {
      "question": "üìÑ Welche Dateiattribute gibt es in Windows CMD standardm√§√üig?",
      "options": [
        "a, s, h, r",
        "x, y, z, k",
        "bin, exe, dll",
        "ro, hi, sy, ar"
      ],
      "correct": [0],
      "explain": "**Begr√ºndung:** Attribute sind: Archiv (a), System (s), Hidden (h), Read-only (r). üîí\n- Die anderen sind Fantasie oder Datei-Endungen.",
      "difficulty": "einsteiger",
      "category": "Datei-Befehle"
    },
    {
      "question": "üßÆ Berechnung: Ein Backup-Job mit `robocopy` √ºbertr√§gt 1,5 GB Daten. Wenn die √úbertragungsrate bei 50 MB/s liegt, wie lange dauert die √úbertragung ungef√§hr?",
      "options": [
        "30 Sekunden",
        "60 Sekunden",
        "90 Sekunden",
        "120 Sekunden"
      ],
      "correct": [2],
      "explain": "**Begr√ºndung:** 1,5 GB = 1500 MB. 1500 MB √∑ 50 MB/s = 30 s. üöÄ\n- Achtung: In der Praxis k√∂nnen Attribute, kleine Dateien und IO-Overhead die Zeit verl√§ngern. Daher ist 30 s nur der Idealwert.",
      "difficulty": "fortgeschritten",
      "category": "Berechnungen"
    },
    {
      "question": "ü§î Wahr/Falsch: CMD unterscheidet streng zwischen Gro√ü- und Kleinschreibung bei Befehlen.",
      "options": [
        "Wahr",
        "Falsch"
      ],
      "correct": [1],
      "explain": "**Begr√ºndung:** Befehle sind in CMD nicht case-sensitive. `DIR` = `dir`. üî§\n- Bei Pfadangaben in bestimmten Tools kann es aber Unterschiede geben (z. B. in anderen Betriebssystemen).",
      "difficulty": "einsteiger",
      "category": "CMD-Mythen"
    },
    {
      "question": "üîç Szenario: Du willst herausfinden, welche Optionen der Befehl `xcopy` unterst√ºtzt. Was tust du?",
      "options": [
        "xcopy --help",
        "xcopy help",
        "xcopy /?",
        "man xcopy"
      ],
      "correct": [2],
      "explain": "**Begr√ºndung:** In CMD wird Hilfe mit `/ ?` abgerufen. ‚úÖ",
      "difficulty": "einsteiger",
      "category": "CMD-Grundlagen"
    },
     {
      "question": "Welcher Befehl zeigt Ihnen die Syntax und die verf√ºgbaren Optionen f√ºr den `xcopy`-Befehl an? üíª",
      "options": [
        "help xcopy",
        "xcopy /?",
        "info xcopy",
        "man xcopy"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der Schalter `/?` ist der Standardweg in der Windows-Kommandozeile, um die Hilfe f√ºr einen bestimmten Befehl direkt aufzurufen. `help xcopy` funktioniert zwar auch, aber `xcopy /?` ist die direktere Methode. `info` und `man` sind Befehle aus der Linux/Unix-Welt. üí°",
      "difficulty": "einsteiger",
      "category": "CMD Grundlagen"
    },
    {
      "question": "Sie befinden sich im Verzeichnis `C:\\Users\\Admin\\Documents` und m√∂chten eine Textdatei namens `notiz.txt` im selben Verzeichnis erstellen, ohne einen externen Editor zu √∂ffnen. Welcher Befehl ist daf√ºr korrekt? ‚úçÔ∏è",
      "options": [
        "create file notiz.txt",
        "echo . > notiz.txt",
        "new-item notiz.txt",
        "make text > notiz.txt"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der Befehl `echo . > notiz.txt` ist eine schnelle Methode, um eine leere Datei zu erstellen. `echo .` gibt einen Punkt aus, und die Umleitung `>` schreibt diese Ausgabe in die Datei `notiz.txt`. Wenn die Datei nicht existiert, wird sie erstellt. `create file` und `make text` sind keine validen CMD-Befehle. `new-item` ist ein PowerShell-Cmdlet. üìÇ",
      "difficulty": "fortgeschritten",
      "category": "Dateibefehle"
    },
    {
      "question": "Was ist der Hauptunterschied zwischen den Befehlen `del` und `rd`? üóëÔ∏è",
      "options": [
        "`del` l√∂scht Verzeichnisse, `rd` l√∂scht Dateien.",
        "`del` l√∂scht nur leere Dateien, `rd` l√∂scht Verzeichnisse.",
        "`del` l√∂scht Dateien, `rd` l√∂scht leere Verzeichnisse.",
        "Es gibt keinen Unterschied, `rd` ist nur eine Abk√ºrzung f√ºr `del`."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** `del` (delete) wird verwendet, um eine oder mehrere Dateien zu l√∂schen. `rd` (remove directory) wird verwendet, um ein Verzeichnis zu entfernen. Standardm√§√üig kann `rd` nur leere Verzeichnisse l√∂schen. Um ein Verzeichnis inklusive Inhalt zu l√∂schen, br√§uchte man den Schalter `/s` (`rd /s Verzeichnisname`). ‚ùå",
      "difficulty": "einsteiger",
      "category": "Verzeichnis- & Dateibefehle"
    },
    {
      "question": "Ein Benutzer f√ºhrt den Befehl `format D: /q /fs:NTFS` aus. Was passiert? üíø",
      "options": [
        "Laufwerk D: wird langsam und gr√ºndlich mit dem FAT32-Dateisystem formatiert.",
        "Eine Schnellformatierung von Laufwerk D: mit dem NTFS-Dateisystem wird durchgef√ºhrt.",
        "Der Befehl schl√§gt fehl, da `/q` und `/fs` nicht kombiniert werden k√∂nnen.",
        "Laufwerk D: wird auf Fehler √ºberpr√ºft und das Dateisystem zu NTFS konvertiert."
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der Befehl `format D:` initiiert die Formatierung von Laufwerk D. Der Schalter `/q` steht f√ºr 'quick format' (Schnellformatierung), bei der nur die Dateizuordnungstabelle gel√∂scht wird. `/fs:NTFS` spezifiziert das zu verwendende Dateisystem als NTFS. Die Kombination ist absolut valide und √ºblich. ‚öôÔ∏è",
      "difficulty": "fortgeschritten",
      "category": "Datentr√§gerbefehle"
    },
    {
      "question": "Sie m√∂chten alle `.log`-Dateien aus dem Verzeichnis `C:\\Logs` und all seinen Unterverzeichnissen in das Verzeichnis `D:\\Archiv` kopieren und dabei die Verzeichnisstruktur beibehalten. Welcher Befehl ist am besten geeignet? üå≥",
      "options": [
        "copy C:\\Logs\\*.log D:\\Archiv",
        "move /s C:\\Logs\\*.log D:\\Archiv",
        "xcopy C:\\Logs\\*.log D:\\Archiv /s",
        "ren C:\\Logs\\*.log D:\\Archiv\\*.bak"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** `xcopy` ist der erweiterte Kopierbefehl. Der Schalter `/s` sorgt daf√ºr, dass alle Unterverzeichnisse (au√üer leere) durchsucht und die Verzeichnisstruktur im Ziel beibehalten wird. `copy` allein durchsucht keine Unterverzeichnisse. `move` w√ºrde die Dateien verschieben, nicht kopieren. `ren` benennt Dateien um. `robocopy` w√§re eine noch robustere Alternative, aber `xcopy` ist hier die korrekte Antwort. üöÄ",
      "difficulty": "fortgeschritten",
      "category": "Verzeichnisbefehle"
    },
    {
      "question": "Was bewirkt der Befehl `path` ohne zus√§tzliche Parameter? üó∫Ô∏è",
      "options": [
        "Er setzt den Suchpfad auf die Standardwerte zur√ºck.",
        "Er zeigt den aktuellen Suchpfad f√ºr ausf√ºhrbare Dateien an.",
        "Er √∂ffnet ein Fenster zur Bearbeitung der Umgebungsvariablen.",
        "Er √ºberpr√ºft die G√ºltigkeit aller Pfade in der PATH-Variable."
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der `path`-Befehl, allein ausgef√ºhrt, zeigt die aktuelle Konfiguration der PATH-Umgebungsvariable an. Diese Variable teilt dem System mit, in welchen Verzeichnissen es nach ausf√ºhrbaren Dateien suchen soll, wenn kein vollst√§ndiger Pfad angegeben wird. üîç",
      "difficulty": "einsteiger",
      "category": "CMD Grundlagen"
    },
    {
      "question": "Ein Skript soll eine wichtige Konfigurationsdatei `config.sys` vor versehentlichem L√∂schen sch√ºtzen. Welcher `attrib`-Befehl erreicht dies am effektivsten? üõ°Ô∏è",
      "options": [
        "attrib +a config.sys",
        "attrib +h config.sys",
        "attrib +s config.sys",
        "attrib +r config.sys"
      ],
      "correct": 3,
      "explain": "**Begr√ºndung:** Der Befehl `attrib +r config.sys` setzt das 'Read-only' (Schreibschutz) Attribut f√ºr die Datei. Eine schreibgesch√ºtzte Datei kann nicht ohne Weiteres ge√§ndert oder gel√∂scht werden. `+a` ist das Archiv-Attribut, `+h` versteckt die Datei (hidden), und `+s` markiert sie als Systemdatei. W√§hrend `+h` und `+s` sie auch sch√ºtzen, ist `+r` der direkteste Weg, den Schreibschutz zu aktivieren. üîí",
      "difficulty": "fortgeschritten",
      "category": "Dateiattribute"
    },
    {
      "question": "Sie sehen die Fehlermeldung: `'befehl' is not recognized as an internal or external command, operable program or batch file.` Was ist die wahrscheinlichste Ursache? ü§î",
      "options": [
        "Der Befehl wurde mit falschen Parametern aufgerufen.",
        "Sie haben keine Administratorrechte, um den Befehl auszuf√ºhren.",
        "Der Befehl hat einen internen Syntaxfehler.",
        "Der Befehl existiert nicht oder sein Speicherort ist nicht im `PATH`."
      ],
      "correct": 3,
      "explain": "**Begr√ºndung:** Diese klassische Fehlermeldung bedeutet, dass der Kommandozeileninterpreter `cmd.exe` den eingegebenen Befehl weder als internen Befehl (wie `dir` oder `cls`) noch als ausf√ºhrbare Datei in den im `PATH` definierten Verzeichnissen finden kann. Ein Tippfehler im Befehlsnamen ist eine h√§ufige Ursache. ü§∑‚Äç‚ôÇÔ∏è",
      "difficulty": "einsteiger",
      "category": "CMD Grundlagen"
    },
    {
      "question": "Wahr oder Falsch: Der Befehl `cd C:\\Users\\..\\Public` f√ºhrt Sie immer in das Verzeichnis `C:\\Public`. üßê",
      "options": [
        "Wahr",
        "Falsch"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Falsch. Der `..` Operator navigiert eine Ebene im Verzeichnisbaum nach oben. Ausgehend von `C:\\Users` w√ºrde `..` Sie nach `C:\\` bringen. Von dort aus w√ºrde der Befehl versuchen, in `C:\\Public` zu wechseln. Der korrekte Pfad w√§re also `C:\\Users\\Public`. Der Befehl f√ºhrt also nach `C:\\Public`, nicht `C:\\Users\\Public`. Die Aussage ist somit falsch, da der Zielpfad von `C:\\Users` aus `C:\\Public` w√§re, was meist nicht existiert. Der Pfad von `C:\\Users\\Admin` aus w√§re `C:\\Users\\Public`. Die Frage ist bewusst knifflig gestellt. üß†",
      "difficulty": "experte",
      "category": "Verzeichnisbefehle"
    },
    {
      "question": "Welches Tool innerhalb der CMD wird verwendet, um Partitionen zu verwalten, Volumes zu erstellen und Festplatten zu konvertieren? üõ†Ô∏è",
      "options": [
        "chkdsk",
        "format",
        "diskpart",
        "label"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** `diskpart` ist ein leistungsstarkes Kommandozeilenprogramm zur Verwaltung von Datentr√§gern, Partitionen und Volumes. Es bietet weit mehr Funktionen als `format` (formatiert), `chkdsk` (√ºberpr√ºft) oder `label` (setzt Volumebezeichnung). Mit `diskpart` kann man z.B. Festplatten von MBR zu GPT konvertieren oder komplexe RAID-Volumes erstellen. üî©",
      "difficulty": "fortgeschritten",
      "category": "Datentr√§gerbefehle"
    },
    {
      "question": "Sie m√∂chten den Inhalt der Datei `liste.txt` anzeigen, aber der Inhalt ist sehr lang. Welcher Befehl zeigt den Inhalt seitenweise an? üìú",
      "options": [
        "type liste.txt | page",
        "cat liste.txt",
        "type liste.txt | more",
        "read liste.txt"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Der `type`-Befehl gibt den Inhalt einer Datei aus. Das Pipe-Symbol `|` leitet diese Ausgabe an den `more`-Befehl weiter. `more` ist ein Filter, der die Ausgabe anh√§lt, sobald der Bildschirm voll ist, und auf einen Tastendruck wartet, um die n√§chste Seite anzuzeigen. `page` und `read` sind keine Standard-CMD-Befehle, `cat` ist aus der Linux-Welt. üìÑ",
      "difficulty": "einsteiger",
      "category": "Allgemeine Befehle"
    },
    {
      "question": "Was ist der Hauptvorteil von `robocopy` gegen√ºber `xcopy`? üí™",
      "options": [
        "`robocopy` ist schneller bei kleinen Dateien.",
        "`robocopy` kann Dateien umbenennen, w√§hrend es kopiert.",
        "`robocopy` bietet mehr Optionen, z.B. Spiegelung von Verzeichnissen und Wiederholungsversuche bei Fehlern.",
        "`robocopy` ist der einzige Befehl, der versteckte Dateien kopieren kann."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** `robocopy` (Robust File Copy) ist der moderne Nachfolger von `xcopy`. Es ist deutlich robuster und funktionsreicher. Zu den Vorteilen geh√∂ren die F√§higkeit, Verzeichnisse zu spiegeln (`/mir`), Kopiervorg√§nge bei Netzwerkunterbrechungen fortzusetzen, die Anzahl der Wiederholungsversuche (`/r`) und die Wartezeit (`/w`) festzulegen und vieles mehr. Es ist das bevorzugte Tool f√ºr komplexe Kopieraufgaben und Backups. üèÜ",
      "difficulty": "fortgeschritten",
      "category": "Verzeichnisbefehle"
    },
    {
      "question": "Sie f√ºhren den Befehl `dir /a:h /b` in einem Verzeichnis aus. Was wird angezeigt? üïµÔ∏è",
      "options": [
        "Alle Dateien und Verzeichnisse mit Attributen und in Kurzform.",
        "Nur die Namen der versteckten Dateien und Verzeichnisse.",
        "Eine leere Ausgabe, da die Attribute sich widersprechen.",
        "Alle Dateien, sortiert nach dem Attribut 'hidden'."
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der `dir`-Befehl listet Verzeichnisinhalte auf. Der Schalter `/a:h` filtert die Anzeige und zeigt nur Elemente mit dem Attribut 'hidden' (versteckt) an. Der Schalter `/b` (bare format) sorgt daf√ºr, dass nur die reinen Namen ohne Kopfzeile, Gr√∂√üe oder Datum ausgegeben werden. Die Kombination zeigt also eine reine Liste der versteckten Dateinamen. üëª",
      "difficulty": "experte",
      "category": "Verzeichnisbefehle"
    },
    {
      "question": "Welches der folgenden Symbole wird verwendet, um die Ausgabe eines Befehls an einen anderen Befehl weiterzuleiten (Piping)? ‚õìÔ∏è",
      "options": [
        ">",
        "<",
        "|",
        "&"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Das Pipe-Symbol `|` ist ein zentrales Konzept der Kommandozeile. Es nimmt den Standard-Output (STDOUT) des Befehls links vom Symbol und verwendet ihn als Standard-Input (STDIN) f√ºr den Befehl rechts vom Symbol. Beispiel: `dir | find \"txt\"` listet den Verzeichnisinhalt auf und filtert dann nach Zeilen, die \"txt\" enthalten. ‚û°Ô∏è",
      "difficulty": "einsteiger",
      "category": "CMD Grundlagen"
    },
    {
      "question": "Sie m√∂chten ein Verzeichnis namens 'Mein Projekt' erstellen. Welcher Befehl ist korrekt? üìÇ",
      "options": [
        "md Mein Projekt",
        "md 'Mein Projekt'",
        "md \"Mein Projekt\"",
        "md Mein-Projekt"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Da der Verzeichnisname ein Leerzeichen enth√§lt, muss er in Anf√ºhrungszeichen (`\"`) eingeschlossen werden. Andernfalls w√ºrde der `md`-Befehl versuchen, zwei separate Verzeichnisse namens 'Mein' und 'Projekt' zu erstellen. Option 3 ist die syntaktisch korrekte. Option 4 w√ºrde funktionieren, entspricht aber nicht der Anforderung. Option 2 mit einfachen Anf√ºhrungszeichen funktioniert in der CMD nicht f√ºr Pfade. ‚úÖ",
      "difficulty": "einsteiger",
      "category": "Verzeichnisbefehle"
    },
    {
      "question": "Was ist der Zweck des Befehls `vol`? üíæ",
      "options": [
        "Er zeigt das verf√ºgbare Volumen (Speicherplatz) eines Laufwerks an.",
        "Er √§ndert die Volumebezeichnung (Label) eines Laufwerks.",
        "Er zeigt die Volumebezeichnung und die Seriennummer eines Laufwerks an.",
        "Er startet das Tool zur Volumenverwaltung."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Der Befehl `vol` (volume) gibt zwei Informationen √ºber ein angegebenes Laufwerk aus: die Volumebezeichnung (das 'Label', z.B. 'System') und die einmalige Volume-Seriennummer, die bei der Formatierung zugewiesen wird. Um das Label zu √§ndern, verwendet man den `label`-Befehl. üè∑Ô∏è",
      "difficulty": "einsteiger",
      "category": "Datentr√§gerbefehle"
    },
    {
      "question": "Sie m√∂chten eine Datei `alt.txt` in `neu.txt` umbenennen. Welcher Befehl ist NICHT daf√ºr geeignet? ü§î",
      "options": [
        "ren alt.txt neu.txt",
        "rename alt.txt neu.txt",
        "move alt.txt neu.txt",
        "copy alt.txt neu.txt"
      ],
      "correct": 3,
      "explain": "**Begr√ºndung:** `ren` und sein Alias `rename` sind die Standardbefehle zum Umbenennen. `move` kann ebenfalls zum Umbenennen verwendet werden, wenn Quelle und Ziel im selben Verzeichnis liegen. `copy` hingegen erstellt eine neue Datei (`neu.txt`) als Kopie der alten (`alt.txt`), aber die Originaldatei bleibt erhalten. Es ist also kein reiner Umbenennungsvorgang. üîÑ",
      "difficulty": "fortgeschritten",
      "category": "Dateibefehle"
    },
    {
      "question": "In einem Pfad wie `C:\\WINDOWS\\system32\\calc.exe`, was ist `system32`? üß©",
      "options": [
        "Der Laufwerksbuchstabe",
        "Ein Verzeichnis (Ordner)",
        "Der Dateiname",
        "Die Dateierweiterung"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Die Pfadstruktur ist hierarchisch: `C:` ist der Laufwerksbuchstabe. `WINDOWS` und `system32` sind Verzeichnisse, wobei `system32` ein Unterverzeichnis von `WINDOWS` ist. `calc` ist der Dateiname und `.exe` ist die Dateierweiterung. ŒπŒµ",
      "difficulty": "einsteiger",
      "category": "Pfadangaben und Dateinamen"
    },
    {
      "question": "Wahr oder Falsch: Bei Befehlen in der Windows CMD muss strikt auf Gro√ü- und Kleinschreibung geachtet werden. üÖ∞Ô∏è",
      "options": [
        "Wahr",
        "Falsch"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Falsch. Die Windows-Kommandozeile (CMD.EXE) ist im Gegensatz zu Linux-Shells nicht 'case-sensitive'. Die Befehle `DIR`, `dir` und `DiR` werden alle identisch interpretiert und ausgef√ºhrt. Das Gleiche gilt f√ºr die meisten Dateinamen im Windows-Dateisystem. ‡∏™‡∏ö‡∏≤‡∏¢",
      "difficulty": "einsteiger",
      "category": "CMD Grundlagen"
    },
    {
      "question": "Welcher Befehl l√∂scht das Verzeichnis `C:\\Temp` inklusive aller darin enthaltenen Dateien und Unterverzeichnisse, ohne bei jeder L√∂schung nachzufragen? üí£",
      "options": [
        "del C:\\Temp /s /q",
        "rd C:\\Temp /s /q",
        "erase C:\\Temp /all",
        "rmdir C:\\Temp"
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** `rd` (oder `rmdir`) ist der Befehl zum L√∂schen von Verzeichnissen. Der Schalter `/s` (subdirectories) weist ihn an, auch alle Unterverzeichnisse und Dateien zu l√∂schen. Der Schalter `/q` (quiet) unterdr√ºckt die Best√§tigungsabfrage 'Sind Sie sicher (J/N)?'. `del` l√∂scht nur Dateien, nicht die Verzeichnisstruktur selbst. üî•",
      "difficulty": "fortgeschritten",
      "category": "Verzeichnisbefehle"
    },
    {
      "question": "Sie erstellen eine einfache Textdatei mit `copy con test.txt`, geben Text ein und m√∂chten die Eingabe beenden und die Datei speichern. Welche Tastenkombination verwenden Sie? ‚å®Ô∏è",
      "options": [
        "STRG + S",
        "ESC",
        "F6 oder STRG + Z",
        "STRG + C"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Der Befehl `copy con` kopiert die Eingabe von der Konsole (`con`) in eine Datei. Um dem System das Dateiende-Zeichen (EOF) zu signalisieren, dr√ºckt man entweder `F6` oder die Tastenkombination `STRG + Z` und anschlie√üend Enter. `STRG + S` hat keine Funktion, `ESC` bricht die Zeile ab und `STRG + C` bricht den gesamten `copy`-Prozess ab. üíæ",
      "difficulty": "fortgeschritten",
      "category": "Dateibefehle"
    },
    {
      "question": "Der Befehl `chkdsk C: /f` wird ausgef√ºhrt. Was ist die Hauptaufgabe des Schalters `/f`? üîß",
      "options": [
        "Er formatiert das Laufwerk, falls Fehler gefunden werden.",
        "Er findet fehlerhafte Sektoren und versucht, Daten wiederherzustellen.",
        "Er behebt gefundene Fehler auf dem Datentr√§ger.",
        "Er erzwingt die √úberpr√ºfung, auch wenn das Laufwerk als fehlerfrei markiert ist."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** `chkdsk` (Check Disk) √ºberpr√ºft ein Laufwerk auf Dateisystemfehler. Ohne Parameter l√§uft es im schreibgesch√ºtzten Modus und meldet nur Fehler. Der Schalter `/f` (fix) weist das Tool an, alle gefundenen Fehler aktiv zu beheben. Wenn das Laufwerk in Benutzung ist (z.B. das Systemlaufwerk), wird die √úberpr√ºfung f√ºr den n√§chsten Systemstart geplant. üõ†Ô∏è",
      "difficulty": "fortgeschritten",
      "category": "Datentr√§gerbefehle"
    },
    {
      "question": "Was zeigt der Befehl `tree /f` an? ÔøΩ",
      "options": [
        "Nur die Verzeichnisstruktur des aktuellen Laufwerks.",
        "Die Verzeichnisstruktur und zus√§tzlich die Dateien in jedem Verzeichnis.",
        "Die Verzeichnisstruktur im 'fast' Modus, ohne Details.",
        "Die Verzeichnisstruktur und die Dateigr√∂√üen."
      ],
      "correct": 1,
      "explain": "**Begr√ºndung:** Der `tree`-Befehl zeigt die Ordnerstruktur eines Pfades in einer grafischen Baumansicht an. Standardm√§√üig werden nur die Verzeichnisse aufgelistet. Der Schalter `/f` (files) erweitert die Anzeige und listet zus√§tzlich die Namen der Dateien innerhalb jedes Verzeichnisses auf. üåø",
      "difficulty": "einsteiger",
      "category": "Verzeichnisbefehle"
    },
    {
      "question": "Sie m√∂chten alle Textdateien (`*.txt`) im aktuellen Verzeichnis finden, die das Wort 'Error' enthalten. Welcher Befehl ist daf√ºr geeignet? üßê",
      "options": [
        "find \"Error\" *.txt",
        "search \"Error\" in *.txt",
        "grep \"Error\" *.txt",
        "type *.txt | find \"Error\""
      ],
      "correct": 0,
      "explain": "**Begr√ºndung:** Der `find`-Befehl ist das Standard-Tool in CMD, um Zeichenfolgen in Dateien zu suchen. Die Syntax `find \"Suchtext\" Dateiname(n)` ist korrekt. `grep` ist das √Ñquivalent aus der Linux/Unix-Welt. Die Pipe-Variante in Option 3 w√ºrde funktionieren, ist aber umst√§ndlicher und weniger effizient als die direkte Verwendung von `find`. üïµÔ∏è‚Äç‚ôÄÔ∏è",
      "difficulty": "fortgeschritten",
      "category": "Dateibefehle"
    },
    {
      "question": "Welches Attribut wird von Backup-Programmen h√§ufig verwendet, um festzustellen, ob eine Datei seit dem letzten Backup ge√§ndert wurde? üì¶",
      "options": [
        "r (Read-only)",
        "h (Hidden)",
        "s (System)",
        "a (Archive)"
      ],
      "correct": 3,
      "explain": "**Begr√ºndung:** Das Archiv-Attribut (`a`) wird vom Betriebssystem automatisch gesetzt, sobald eine Datei erstellt oder ge√§ndert wird. Backup-Software kann dieses Attribut nutzen: Sie sichert alle Dateien mit gesetztem `a`-Attribut und entfernt es danach. So werden beim n√§chsten inkrementellen Backup nur die neuen oder ge√§nderten Dateien erfasst. üó≥Ô∏è",
      "difficulty": "experte",
      "category": "Dateiattribute"
    },
    {
      "question": "Sie m√∂chten das aktuelle Datum auf den 31.10.2025 √§ndern. Welcher Befehl ist korrekt? üóìÔ∏è",
      "options": [
        "time 31-10-2025",
        "date 31-10-25",
        "date 31.10.2025",
        "setdate 31/10/2025"
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Der `date`-Befehl wird verwendet, um das Systemdatum anzuzeigen und zu √§ndern. Das erwartete Datumsformat h√§ngt von den L√§ndereinstellungen des Systems ab. In Deutschland ist das Format `TT.MM.JJJJ` √ºblich. Daher ist `date 31.10.2025` die wahrscheinlichste korrekte Eingabe. Die anderen Formate w√ºrden zu einem Syntaxfehler f√ºhren. üìÖ",
      "difficulty": "einsteiger",
      "category": "Allgemeine Befehle"
    },
    {
      "question": "Der Befehl `move /y C:\\*.tmp D:\\Trash` wird ausgef√ºhrt. Was bewirkt der Schalter `/y`? üëâ",
      "options": [
        "Er verschiebt nur Dateien, die j√ºnger ('younger') als 24 Stunden sind.",
        "Er fragt bei jeder Datei nach, ob sie wirklich verschoben werden soll.",
        "Er unterdr√ºckt die Abfrage zum √úberschreiben von bereits existierenden Dateien im Ziel.",
        "Er kopiert die Dateien nur, anstatt sie zu verschieben."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Wenn der `move`-Befehl Dateien in ein Ziel verschiebt, in dem bereits Dateien mit demselben Namen existieren, fragt er standardm√§√üig nach, ob diese √ºberschrieben werden sollen. Der Schalter `/y` unterdr√ºckt diese Nachfrage und √ºberschreibt die Zieldateien automatisch. Das Gegenst√ºck ist `/-y`, was die Nachfrage erzwingt. ü§´",
      "difficulty": "fortgeschritten",
      "category": "Dateibefehle"
    },
    {
      "question": "Ein Admin m√∂chte eine Liste aller laufenden Prozesse in die Datei `prozesse.txt` schreiben. Welcher Befehl ist daf√ºr korrekt? üìà",
      "options": [
        "tasklist > prozesse.txt",
        "proclist >> prozesse.txt",
        "ps > prozesse.txt",
        "tasklist | prozesse.txt"
      ],
      "correct": 0,
      "explain": "**Begr√ºndung:** `tasklist` ist der Befehl, der die laufenden Prozesse anzeigt. Der Umleitungsoperator `>` nimmt die Ausgabe des Befehls und schreibt sie in die angegebene Datei. Wenn die Datei bereits existiert, wird sie √ºberschrieben. `>>` w√ºrde die Ausgabe an die Datei anh√§ngen. `ps` und `proclist` sind keine Standard-CMD-Befehle. üìù",
      "difficulty": "fortgeschritten",
      "category": "Allgemeine Befehle"
    },
    {
      "question": "Sie m√∂chten den Befehl `cls` ausf√ºhren, um den Bildschirm zu leeren. Wo befindet sich die Logik f√ºr diesen Befehl? üèõÔ∏è",
      "options": [
        "In einer Datei namens `cls.exe` im `system32`-Verzeichnis.",
        "Er ist direkt in den Windows-Kernel integriert.",
        "Er ist ein interner Befehl des Kommandozeileninterpreters `cmd.exe`.",
        "In einer Dynamic Link Library (DLL), die von der CMD geladen wird."
      ],
      "correct": 2,
      "explain": "**Begr√ºndung:** Es gibt einen wichtigen Unterschied zwischen internen und externen Befehlen. Externe Befehle sind eigenst√§ndige `.exe`- oder `.com`-Dateien (z.B. `format.com` oder `diskpart.exe`). Interne Befehle wie `dir`, `copy`, `ren`, `cls` oder `date` sind fest in `cmd.exe` einprogrammiert und ben√∂tigen keine separate Datei. Sie sind immer verf√ºgbar, solange die CMD l√§uft. üß†",
      "difficulty": "experte",
      "category": "CMD Grundlagen"
    },
    {
      "question": "Welcher Befehl √§ndert die aktuelle Eingabeaufforderung (Prompt) so, dass sie den aktuellen Pfad gefolgt von einem `>` anzeigt? üë®‚Äçüíª",
      "options": [
        "prompt $p$g",
        "prompt $cwd",
        "set prompt=%path%",
        "prompt $path$>"
      ],
      "correct": 0,
      "explain": "**Begr√ºndung:** Der `prompt`-Befehl steuert das Aussehen der Eingabeaufforderung. Dabei werden spezielle Metacodes verwendet. `$p` steht f√ºr den aktuellen Pfad (path) und `$g` steht f√ºr das 'greater than'-Zeichen (`>`). Die Kombination `prompt $p$g` erzeugt den Standard-Prompt, z.B. `C:\\Users\\Admin>`. üé®",
      "difficulty": "experte",
      "category": "Allgemeine Befehle"
    }
  ]
}