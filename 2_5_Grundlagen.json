{
    "questions": [
        {
            "question": "Ein Junior-Administrator soll ein Verzeichnis aller `.log`-Dateien auf Laufwerk `D:` erstellen und in der Datei `audit.txt` speichern. Er f√ºhrt den Befehl `dir d:\\*.log > audit.txt` aus. Am n√§chsten Tag soll er die neuen Log-Dateien an die bestehende `audit.txt` anh√§ngen. Welchen Befehl muss er verwenden, um die alten Eintr√§ge nicht zu √ºberschreiben? üìú",
            "options": [
                "dir d:\\*.log > audit.txt",
                "dir d:\\*.log | audit.txt",
                "dir d:\\*.log >> audit.txt",
                "dir d:\\*.log + audit.txt"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Operator `>>` wird als Anh√§ngesymbol verwendet. Er leitet die Ausgabe eines Befehls in eine Datei um und f√ºgt sie am Ende der Datei an, ohne den vorhandenen Inhalt zu l√∂schen. \n- **`>` (Umleitungssymbol):** W√ºrde die `audit.txt` komplett √ºberschreiben. ‚ùå\n- **`|` (Pipe):** Verkettet Befehle, indem es die Ausgabe des ersten Befehls als Eingabe f√ºr den zweiten verwendet, was hier nicht zielf√ºhrend ist. ‚ùå\n- **`+` (Zusammenf√ºhrungssymbol):** Wird prim√§r beim `copy`-Befehl verwendet, um Dateien zu kombinieren, nicht zur Umleitung von Befehlsausgaben. ‚ùå\nüí° Dieses Wissen ist entscheidend f√ºr das Logging und die Protokollierung in Skripten.",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Sie m√∂chten einen neuen 64 GB USB-Stick f√ºr die Windows-Installation vorbereiten. Der Stick muss eine einzelne, aktive prim√§re Partition enthalten, die mit NTFS formatiert ist. Welche `diskpart`-Befehlssequenz ist korrekt und vollst√§ndig? üõ†Ô∏è",
            "options": [
                "select disk 1, create partition primary, active, format fs=ntfs, assign",
                "list disk, select disk 1, clean, create partition primary, active, format fs=ntfs quick, assign",
                "list disk, select disk 1, clean, create partition, format, assign letter=e",
                "select disk 1, format fs=ntfs quick, active, assign"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die korrekte Reihenfolge ist entscheidend. Zuerst muss der Datentr√§ger mit `list disk` identifiziert und mit `select disk X` ausgew√§hlt werden. `clean` entfernt alle vorhandenen Partitionierungsinformationen. Danach wird mit `create partition primary` eine prim√§re Partition erstellt, mit `active` als bootf√§hig markiert, mit `format fs=ntfs quick` schnell formatiert und schlie√ülich mit `assign` ein Laufwerksbuchstabe zugewiesen. \n- **Option A:** Vergisst `list disk` und `clean`, was zu Fehlern f√ºhren kann, wenn der Stick nicht leer ist. ‚ùå\n- **Option C:** Ist zu unpr√§zise (`create partition` ohne 'primary', `format` ohne Dateisystem). ‚ùå\n- **Option D:** Versucht zu formatieren, bevor eine Partition erstellt wurde. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Ein Server soll w√∂chentlich einen Integrit√§tscheck der Systemfestplatte (C:) durchf√ºhren und eventuelle Fehler automatisch beheben. Der Report soll nicht am Bildschirm angezeigt, sondern in eine Log-Datei geschrieben werden. Welcher Befehl ist daf√ºr am besten geeignet? ‚öôÔ∏è",
            "options": [
                "chkdsk c: /f > nul",
                "chkdsk c: /r",
                "format c: /q",
                "diskpart detail disk > log.txt"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Der Befehl `chkdsk c: /f` pr√ºft das Laufwerk C: auf Fehler und behebt (`/f`) diese. Die Umleitung `> nul` unterdr√ºckt die Ausgabe auf der Konsole, was f√ºr automatisierte Skripts ideal ist, um den Bildschirm sauber zu halten. \n- **`/r`:** Sucht zus√§tzlich nach fehlerhaften Sektoren und stellt lesbare Informationen wieder her, was deutlich l√§nger dauert und f√ºr einen schnellen Check oft nicht n√∂tig ist. ‚ùå\n- **`format c:`:** W√ºrde die Systemfestplatte formatieren und das Betriebssystem l√∂schen.  –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞! ‚ùå\n- **`diskpart detail disk`:** Liefert nur Informationen √ºber den Datentr√§ger, f√ºhrt aber keine Fehlerpr√ºfung oder -korrektur durch. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Wahr oder Falsch: Der Befehl `clean` in `diskpart` ist eine sichere Methode, um sensible Daten unwiederbringlich zu l√∂schen, da er alle Sektoren der Festplatte √ºberschreibt. üîí",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. Der `clean`-Befehl l√∂scht lediglich die MBR- oder GPT-Partitionierungsinformationen vom Datentr√§ger. Die eigentlichen Daten bleiben physisch auf der Festplatte erhalten und k√∂nnen mit Datenrettungstools oft wiederhergestellt werden. Nur der Befehl `clean all` √ºberschreibt jeden Sektor mit Nullen und sorgt f√ºr ein sicheres L√∂schen (‚ÄûSecure Erase‚Äú). üí° Dies ist ein kritischer Unterschied im Kontext der Datensicherheit.",
            "difficulty": "experte",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "Vergleichen Sie die Befehle `del` und `rd`. Welches Szenario beschreibt den korrekten Einsatz der beiden Befehle? üóëÔ∏è",
            "options": [
                "`del` l√∂scht Verzeichnisse und `rd` l√∂scht Dateien.",
                "Beide k√∂nnen Dateien und leere Verzeichnisse l√∂schen.",
                "`del` l√∂scht eine oder mehrere Dateien, w√§hrend `rd` ein leeres Verzeichnis l√∂scht.",
                "`rd` l√∂scht ein Verzeichnis inklusive aller Unterverzeichnisse und Dateien, `del` nur einzelne Dateien."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die Trennung ist klar definiert: `del` (delete) ist f√ºr das L√∂schen von Dateien zust√§ndig. `rd` (remove directory) ist f√ºr das Entfernen von Verzeichnissen zust√§ndig. Standardm√§√üig kann `rd` nur leere Verzeichnisse l√∂schen. Um ein Verzeichnis samt Inhalt zu l√∂schen, ben√∂tigt man den Schalter `/s` (z.B. `rd /s meinverzeichnis`).\n- **Option A:** Ist genau umgekehrt. ‚ùå\n- **Option B:** `del` kann keine Verzeichnisse l√∂schen. ‚ùå\n- **Option D:** `rd` l√∂scht ohne den Schalter `/s` eben nicht den Inhalt mit. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie haben einen Ordner mit hunderten von Bilddateien (JPG) und Textdokumenten (TXT). Sie m√∂chten alle JPG-Dateien in einen Unterordner namens `Bilder` verschieben. Welcher Befehl ist am effizientesten? üìÇ",
            "options": [
                "copy *.jpg Bilder\\",
                "move *.jpg Bilder",
                "xcopy *.jpg Bilder\\ /s",
                "ren *.jpg *.bak"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `move`-Befehl ist f√ºr das Verschieben von Dateien und Verzeichnissen konzipiert. Er ist effizienter als `copy` gefolgt von `del`, da die Dateidaten nicht physisch kopiert, sondern nur der Verzeichniseintrag im Dateisystem ge√§ndert wird (solange es auf demselben Volume geschieht).\n- **`copy`:** W√ºrde die Dateien nur kopieren, die Originale blieben erhalten. ‚ùå\n- **`xcopy`:** Ist f√ºr das Kopieren von Verzeichnisstrukturen gedacht und hier unn√∂tig komplex. ‚ùå\n- **`ren`:** W√ºrde die Dateien nur umbenennen, nicht verschieben. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert"
        },
        {
            "question": "Ein Skript soll die Ausgabe eines langen Befehls erzeugen, aber der Benutzer soll diese Ausgabe nicht auf dem Bildschirm sehen, um die Konsole √ºbersichtlich zu halten. Welcher Befehlsteil erreicht dies? üôà",
            "options": [
                "| more",
                "> nul",
                "/p",
                "| clip"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die Umleitung `> nul` sendet die Standardausgabe (STDOUT) eines Befehls an das `nul`-Ger√§t, welches ein virtuelles Ger√§t ist, das alle empfangenen Daten verwirft. Dadurch wird die Ausgabe effektiv unterdr√ºckt. \n- **`| more`:** H√§lt die Ausgabe seitenweise an, zeigt sie aber an. ‚ùå\n- **`/p`:** Ist ein Schalter vieler Befehle (wie `dir`), um die Ausgabe zu pausieren, zeigt sie aber ebenfalls an. ‚ùå\n- **`| clip`:** Leitet die Ausgabe in die Zwischenablage um, nicht ins Nichts. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Welchen entscheidenden Vorteil bietet `PowerShell` gegen√ºber der klassischen `CMD.EXE`, der in den Unterlagen angedeutet wird? üöÄ",
            "options": [
                "PowerShell ist abw√§rtskompatibler zu MS-DOS.",
                "PowerShell-Befehle sind immer k√ºrzer und einfacher zu merken.",
                "PowerShell arbeitet mit Objekten statt mit reinem Text, was eine m√§chtigere Verarbeitung und Skripterstellung erm√∂glicht.",
                "CMD.EXE kann keine Netzwerkoperationen durchf√ºhren, PowerShell schon."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der fundamentale Unterschied und gr√∂√üte Vorteil von PowerShell ist die objektorientierte Pipeline. W√§hrend CMD Textzeilen von einem Befehl zum n√§chsten weitergibt, reicht PowerShell strukturierte .NET-Objekte weiter. Dies erlaubt eine wesentlich komplexere und zuverl√§ssigere Verarbeitung von Daten in Skripten. CMD kann durchaus Netzwerkbefehle wie `ping` oder `ipconfig` ausf√ºhren. PowerShell ist eine modernere, aber nicht zwangsl√§ufig abw√§rtskompatiblere oder immer k√ºrzere Alternative.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie befinden sich im Verzeichnis `C:\\Users\\Admin\\Documents`. Welcher einzelne Befehl bringt Sie direkt zum Wurzelverzeichnis von Laufwerk C:? üå≥",
            "options": [
                "cd ..",
                "cd /",
                "cd \\",
                "cd c:"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `cd \\` (change directory mit Backslash) wechselt immer in das Wurzelverzeichnis des aktuellen Laufwerks. \n- **`cd ..`:** Wechselt nur eine Ebene nach oben (zu `C:\\Users\\Admin`). ‚ùå\n- **`cd /`:** Der Slash `/` wird in CMD prim√§r f√ºr Schalter/Optionen verwendet, nicht f√ºr die Pfadnavigation wie in Linux. ‚ùå\n- **`cd c:`:** Zeigt nur den aktuellen Pfad auf Laufwerk C: an, wechselt aber nicht das Verzeichnis, wenn man sich bereits auf C: befindet. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Ein Kollege hat mit `diskpart` eine Partition gel√∂scht, aber der Speicherplatz wurde nicht wie erwartet dem benachbarten Volume hinzugef√ºgt. Welcher `diskpart`-Befehl ist notwendig, um den freien Speicherplatz einer vorhandenen Partition zuzuweisen? ‚ûï",
            "options": [
                "assign",
                "create",
                "merge",
                "extend"
            ],
            "correct": 3,
            "explain": "**Begr√ºndung:** Der `extend`-Befehl wird in `diskpart` verwendet, um ein Volume oder eine Partition in den n√§chsten zusammenh√§ngenden, nicht zugeordneten Speicherplatz auf demselben Datentr√§ger zu erweitern. Man muss zuerst das Volume ausw√§hlen (`select volume X`) und kann es dann mit `extend` vergr√∂√üern. \n- **`assign`:** Weist nur einen Laufwerksbuchstaben zu. ‚ùå\n- **`create`:** Erstellt eine neue Partition im freien Speicher. ‚ùå\n- **`merge`:** F√ºhrt untergeordnete virtuelle Datentr√§ger zusammen, was hier nicht relevant ist. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Welche Funktion haben die Platzhalter `*` und `?` in der CMD? W√§hlen Sie die pr√§ziseste Definition. üß©",
            "options": [
                "`*` steht f√ºr ein beliebiges Zeichen, `?` f√ºr eine beliebige Zeichenkette.",
                "`*` steht f√ºr eine beliebige Zeichenkette (auch keine), `?` steht f√ºr genau ein beliebiges Zeichen.",
                "`*` steht f√ºr Zahlen, `?` f√ºr Buchstaben.",
                "Beide stehen f√ºr eine beliebige Anzahl von beliebigen Zeichen."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Dies ist eine fundamentale Regel der Wildcard-Nutzung. Der Stern (`*`) ist der 'gierige' Platzhalter f√ºr null oder mehr beliebige Zeichen. Das Fragezeichen (`?`) ist der pr√§zise Platzhalter f√ºr exakt ein beliebiges Zeichen. Ein Beispiel: `datei?.txt` findet `datei1.txt` und `dateiA.txt`, aber nicht `datei10.txt` oder `datei.txt`. `datei*.txt` w√ºrde sie alle finden.",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie m√∂chten eine Textdatei namens `setup.txt` direkt in der Kommandozeile erstellen und den Text 'Installation_Start' hineinschreiben. Welcher Befehl und welche Aktion beenden den Schreibvorgang korrekt? ‚úçÔ∏è",
            "options": [
                "type > setup.txt, dann 'Installation_Start' tippen und mit ESC beenden.",
                "md setup.txt, dann 'Installation_Start' tippen und mit Enter beenden.",
                "copy con setup.txt, dann 'Installation_Start' tippen und mit Strg+Z gefolgt von Enter beenden.",
                "edit setup.txt, dann 'Installation_Start' tippen und mit F3 speichern."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `copy con` (copy from console) leitet die Konsoleneingabe in eine Datei um. Nach der Eingabe des Textes wird der Vorgang durch das Senden des 'End-of-File'-Zeichens (EOF) abgeschlossen, was in Windows durch die Tastenkombination `Strg+Z` und anschlie√üendes Dr√ºcken von `Enter` geschieht. \n- **Option A, B, D:** Sind syntaktisch falsche oder unpassende Befehle f√ºr diesen Zweck. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datei-Befehle"
        },
        {
            "question": "Sie geben den Befehl `help | more` ein. Was ist die genaue Funktion des Pipe-Symbols `|` in diesem Kontext? ‚õìÔ∏è",
            "options": [
                "Es leitet die Hilfe-Ausgabe in eine Datei namens 'more' um.",
                "Es startet den 'more'-Befehl parallel zum 'help'-Befehl.",
                "Es sorgt daf√ºr, dass die sehr lange Ausgabe des 'help'-Befehls seitenweise durch den 'more'-Befehl angezeigt wird.",
                "Es f√ºgt den Inhalt der Datei 'more' an die Hilfe-Ausgabe an."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Das Pipe-Symbol `|` ist ein Verkettungssymbol. Es nimmt die Standardausgabe (STDOUT) des Befehls links von der Pipe und verwendet sie als Standardeingabe (STDIN) f√ºr den Befehl rechts von der Pipe. Hier wird die komplette Liste aller Befehle von `help` an `more` weitergeleitet, welcher die Eingabe dann seitenweise anzeigt und auf eine Benutzereingabe wartet, um zur n√§chsten Seite zu bl√§ttern.",
            "difficulty": "fortgeschritten",
            "category": "Befehlssyntax"
        },
        {
            "question": "Ein Techniker m√∂chte die Volumebezeichnung eines USB-Sticks (Laufwerk E:) von 'TRANSCEND' auf 'BACKUP' √§ndern. Welcher Befehl ist daf√ºr direkt und ohne weitere Umwege vorgesehen? üè∑Ô∏è",
            "options": [
                "ren e: BACKUP",
                "label e: BACKUP",
                "vol e: BACKUP",
                "attrib e: +L BACKUP"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `label`-Befehl ist speziell daf√ºr vorgesehen, die Datentr√§gerbezeichnung (das Volume Label) eines Laufwerks zu erstellen, zu √§ndern oder zu l√∂schen. \n- **`ren`:** Dient zum Umbenennen von Dateien und Verzeichnissen, nicht von Laufwerken. ‚ùå\n- **`vol`:** Zeigt nur die aktuelle Bezeichnung an, kann sie aber nicht √§ndern. ‚ùå\n- **`attrib`:** Modifiziert Dateiattribute (wie schreibgesch√ºtzt, versteckt etc.), nicht die Volumebezeichnung. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Datentr√§ger-Befehle"
        },
        {
            "question": "Wahr oder Falsch: Der Befehl `cd Ordner1\\Ordner2` ist ein Beispiel f√ºr die Verwendung eines relativen Pfades. üõ§Ô∏è",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Wahr. Ein relativer Pfad geht vom aktuellen Verzeichnis aus. Wenn Sie sich z.B. in `C:\\Daten` befinden, w√ºrde `cd Ordner1\\Ordner2` versuchen, in das Verzeichnis `C:\\Daten\\Ordner1\\Ordner2` zu wechseln. Ein absoluter Pfad hingegen beginnt immer mit einem Laufwerksbuchstaben oder einem `\\` vom Wurzelverzeichnis aus (z.B. `cd C:\\Windows\\System32`). Dieses Verst√§ndnis ist fundamental f√ºr die Navigation und Skripterstellung.",
            "difficulty": "fortgeschritten",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "Sie m√ºssen in `diskpart` eine 500 MB gro√üe prim√§re Partition auf einem leeren Datentr√§ger erstellen. Welcher Befehl ist daf√ºr korrekt? üìè",
            "options": [
                "create partition primary size=500",
                "create primary partition 500mb",
                "create partition size=500mb primary",
                "create partition primary 500"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die korrekte Syntax f√ºr das Erstellen einer Partition mit einer bestimmten Gr√∂√üe in `diskpart` lautet `create partition [typ] size=[gr√∂√üe_in_mb]`. Der Parameter `size` erwartet die Gr√∂√üe in Megabyte (MB). \n- **Option B, C, D:** Verwenden eine falsche Syntax oder Reihenfolge der Parameter. Die Angabe 'mb' ist nicht Teil des Werts. ‚ùå",
            "difficulty": "experte",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "Was ist der historische und funktionale Hauptunterschied zwischen `CMD.EXE` und dem √§lteren `COMMAND.COM`? üèõÔ∏è",
            "options": [
                "`COMMAND.COM` war 32-Bit, `CMD.EXE` ist 16-Bit.",
                "`CMD.EXE` wurde mit Windows NT eingef√ºhrt und ist ein nativer 32/64-Bit-Prozess, w√§hrend `COMMAND.COM` ein 16-Bit-Interpreter aus der MS-DOS-√Ñra ist.",
                "`COMMAND.COM` unterst√ºtzte Batch-Skripte, `CMD.EXE` nicht.",
                "Es gibt keinen funktionalen Unterschied, nur der Name wurde ge√§ndert."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Dies ist ein wichtiger historischer Kontext. `COMMAND.COM` war der Kommandozeileninterpreter f√ºr MS-DOS und √§ltere Windows-Versionen (9x/Me). Es war eine 16-Bit-Anwendung mit vielen Einschr√§nkungen. `CMD.EXE` wurde als nativer 32-Bit-Interpreter (heute auch 64-Bit) f√ºr die Windows-NT-Linie (NT, 2000, XP, etc.) entwickelt und bot eine erweiterte Befehlssyntax und bessere Integration in das Betriebssystem. Beide unterst√ºtzen Batch-Skripte, aber `CMD.EXE` mit mehr Funktionen.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie vermuten, dass eine wichtige Systemdatei versteckt und schreibgesch√ºtzt ist. Welcher Befehl zeigt die Attribute der Datei `kernel32.dll` im System32-Ordner an? üëÅÔ∏è",
            "options": [
                "dir C:\\Windows\\System32\\kernel32.dll",
                "type C:\\Windows\\System32\\kernel32.dll",
                "attrib C:\\Windows\\System32\\kernel32.dll",
                "find \"kernel32.dll\" C:\\Windows\\System32"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der `attrib`-Befehl ist speziell daf√ºr da, die Attribute von Dateien oder Verzeichnissen anzuzeigen oder zu √§ndern. Dazu geh√∂ren A (Archiv), S (System), H (Hidden/Versteckt) und R (Read-only/Schreibgesch√ºtzt). \n- **`dir`:** Zeigt die Datei an, aber nicht immer alle Attribute auf einen Blick. ‚ùå\n- **`type`:** W√ºrde versuchen, den bin√§ren Inhalt der DLL-Datei als Text auszugeben, was zu unsinniger Ausgabe f√ºhrt. ‚ùå\n- **`find`:** Durchsucht den Inhalt von Dateien, nicht deren Attribute. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datei-Befehle"
        },
        {
            "question": "Um die gesamte Befehlshistorie der aktuellen CMD-Sitzung anzuzeigen, kann man `doskey /history` verwenden. Welcher Tastaturbefehl bietet eine √§hnliche, aber interaktivere Funktionalit√§t? ‚å®Ô∏è",
            "options": [
                "F7",
                "F3",
                "Pfeiltaste Oben (‚Üë)",
                "Tab-Taste"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die `F7`-Taste √∂ffnet in der CMD ein kleines Fenster, das eine nummerierte Liste der zuletzt eingegebenen Befehle anzeigt. Man kann dann mit den Pfeiltasten einen Befehl ausw√§hlen und mit `Enter` direkt ausf√ºhren. \n- **`F3`:** Wiederholt den letzten Befehl. ‚ùå\n- **`Pfeiltaste Oben`:** Bl√§ttert einzeln durch die vorherigen Befehle. ‚ùå\n- **`Tab-Taste`:** Wird zur automatischen Vervollst√§ndigung von Date- und Verzeichnisnamen verwendet. ‚ùå",
            "difficulty": "experte",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Ein Skript muss den vollst√§ndigen Pfad zu allen ausf√ºhrbaren Programmen (`.exe`) im Windows-Verzeichnis und allen seinen Unterverzeichnissen auflisten. Welcher `dir`-Befehl ist daf√ºr am besten geeignet? üó∫Ô∏è",
            "options": [
                "dir C:\\Windows\\*.exe",
                "dir C:\\Windows\\*.exe /s /b",
                "tree C:\\Windows /f",
                "find \".exe\" C:\\Windows"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `dir C:\\Windows\\*.exe /s /b` ist hier perfekt. `*.exe` filtert nach der Dateiendung. Der Schalter `/s` (subdirectories) durchsucht rekursiv alle Unterverzeichnisse. Der Schalter `/b` (bare format) gibt nur den reinen Pfad und Dateinamen aus, ohne Kopf- und Fu√üzeilen, was ideal f√ºr die Weiterverarbeitung in Skripten ist. \n- **Option A:** Durchsucht nur das `C:\\Windows`-Verzeichnis selbst, nicht die Unterordner. ‚ùå\n- **Option C:** `tree` zeigt die Verzeichnisstruktur an, was hier zu viel Information w√§re. ‚ùå\n- **Option D:** `find` durchsucht den *Inhalt* von Dateien, nicht die Dateinamen. ‚ùå",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Sie m√ºssen eine gro√üe Anzahl von Dateien (ca. 150 GB) samt Unterverzeichnissen und NTFS-Berechtigungen auf einen neuen Server kopieren. Welcher Befehl ist daf√ºr robuster und besser geeignet als `copy` oder `xcopy`? üöö",
            "options": [
                "move",
                "diskpart",
                "robocopy",
                "format"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `robocopy` (Robust File Copy) ist das Mittel der Wahl f√ºr gro√üe und komplexe Kopiervorg√§nge. Es wurde speziell f√ºr solche Szenarien entwickelt und bietet Features wie das Kopieren von NTFS-Berechtigungen, Wiederaufnahme bei Netzwerkunterbrechungen, Spiegelungsmodi und umfangreiches Logging. `xcopy` ist zwar m√§chtiger als `copy`, aber `robocopy` ist der moderne Standard f√ºr administrative Aufgaben. Der Befehl wird im Material als Alternative zu `xcopy` erw√§hnt und geh√∂rt zum Wissen eines Fachinformatikers.",
            "difficulty": "experte",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Welcher `diskpart`-Befehl wird verwendet, um einen Datentr√§ger, der als 'offline' markiert ist, wieder f√ºr das System verf√ºgbar zu machen? üîå",
            "options": [
                "active",
                "online",
                "rescan",
                "assign"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Wenn ein Datentr√§ger oder ein Volume in `diskpart` (oder der Datentr√§gerverwaltung) als 'offline' angezeigt wird, kann das System nicht darauf zugreifen. Der Befehl `online` (nachdem das Objekt mit `select` ausgew√§hlt wurde) schaltet es wieder in den Online-Zustand und macht es f√ºr das Betriebssystem sichtbar und nutzbar. \n- **`active`:** Markiert eine Partition als bootf√§hig. ‚ùå\n- **`rescan`:** Sucht nach neuen, an den Computer angeschlossenen Datentr√§gern. ‚ùå\n- **`assign`:** Weist einen Laufwerksbuchstaben zu, was aber erst m√∂glich ist, wenn das Volume online ist. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        },
        {
            "question": "Was ist das Ergebnis des Befehls `prompt $T$G`? üïí",
            "options": [
                "Der Pfad gefolgt von einem '>'-Zeichen.",
                "Datum und Uhrzeit.",
                "Die aktuelle Uhrzeit gefolgt von einem '>'-Zeichen.",
                "Der Text '$T$G' wird als neuer Prompt gesetzt."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der `prompt`-Befehl √§ndert die Eingabeaufforderung. Dabei werden spezielle Metacodes verwendet. `$T` steht f√ºr die aktuelle Uhrzeit (Time) und `$G` steht f√ºr das 'gr√∂√üer als'-Zeichen (`>`). Der Befehl setzt den Prompt also z.B. auf `14:30:55,12>`. Dies kann n√ºtzlich sein, um Befehle in Skripten mit einem Zeitstempel zu versehen. `$P$G` ist der Standard-Prompt, der den Pfad anzeigt.",
            "difficulty": "experte",
            "category": "Allgemeine Befehle"
        },
        {
            "question": "Sie haben ein Verzeichnis `C:\\Logs` mit tausenden von Dateien. Sie m√∂chten schnell herausfinden, ob es eine Datei mit dem exakten Namen `error_2025-08-26.log` gibt. Welcher Befehl ist am schnellsten und ressourcenschonendsten? üí®",
            "options": [
                "dir C:\\Logs /s",
                "find \"error_2025-08-26.log\" C:\\Logs\\*",
                "dir C:\\Logs\\error_2025-08-26.log",
                "tree C:\\Logs"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der direkteste Weg ist, `dir` mit dem vollst√§ndigen Dateinamen aufzurufen. Wenn die Datei existiert, wird sie sofort aufgelistet. Wenn nicht, meldet `dir` 'Datei nicht gefunden'. Dies ist wesentlich schneller als andere Methoden. \n- **`dir /s`:** W√ºrde alle Unterverzeichnisse durchsuchen, was unn√∂tig ist. ‚ùå\n- **`find`:** Durchsucht den *Inhalt* der Dateien nach dem String, nicht die Dateinamen. Das w√ºrde extrem lange dauern und nicht das gew√ºnschte Ergebnis liefern. ‚ùå\n- **`tree`:** Zeigt die gesamte Verzeichnisstruktur an, was bei tausenden Dateien sehr un√ºbersichtlich und langsam ist. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Wahr oder Falsch: Die Eingabe von `help > befehle.txt` und `help /?` f√ºhrt zum exakt gleichen Ergebnis. ü§î",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. `help > befehle.txt` leitet die *Ausgabe* des `help`-Befehls (also die Liste aller verf√ºgbaren Befehle) in die Datei `befehle.txt` um. Der Befehl `help /?` hingegen zeigt die *Hilfe zum `help`-Befehl selbst* an, also eine Beschreibung, wie der `help`-Befehl funktioniert. Das sind zwei v√∂llig unterschiedliche Aktionen.",
            "difficulty": "fortgeschritten",
            "category": "Wahr/Falsch mit Begr√ºndung"
        },
        {
            "question": "In der Befehlssyntax-Hilfe (z.B. bei `dir /?`) sind einige Parameter in eckigen Klammern `[ ]` aufgef√ºhrt. Was bedeutet diese Konvention? üìñ",
            "options": [
                "Diese Parameter sind veraltet und sollten nicht mehr verwendet werden.",
                "Diese Parameter sind obligatorisch und m√ºssen immer angegeben werden.",
                "Diese Parameter sind optional und k√∂nnen weggelassen werden.",
                "Diese Parameter funktionieren nur im Administratormodus."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die eckigen Klammern `[ ]` sind eine Standardkonvention in der Dokumentation von Kommandozeilenprogrammen, um optionale Parameter, Schalter oder Argumente zu kennzeichnen. Elemente ohne Klammern sind in der Regel erforderlich. Dieses Wissen ist entscheidend, um die Hilfe-Texte der CMD korrekt interpretieren zu k√∂nnen.",
            "difficulty": "einsteiger",
            "category": "Befehlssyntax"
        },
        {
            "question": "Ein USB-Stick wurde f√§lschlicherweise mit `diskpart` und dem `clean`-Befehl bereinigt. Der Benutzer m√∂chte nun versuchen, die Daten wiederherzustellen. Was ist der wichtigste erste Schritt, den er unternehmen sollte, um die Chancen auf eine erfolgreiche Wiederherstellung zu maximieren? üöë",
            "options": [
                "Sofort eine neue Partition erstellen und formatieren, um wieder auf den Stick zugreifen zu k√∂nnen.",
                "Den `chkdsk /r`-Befehl ausf√ºhren, um die Dateistruktur zu reparieren.",
                "Den Stick sofort vom Computer trennen und keine weiteren Schreibvorg√§nge durchf√ºhren.",
                "Den Befehl `diskpart convert mbr` ausf√ºhren."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Nach einem `clean`-Befehl sind die Daten physisch noch vorhanden, aber der 'Wegweiser' (die Partitionstabelle) zu ihnen wurde gel√∂scht. Jeder weitere Schreibvorgang (wie das Erstellen einer neuen Partition, Formatieren, `chkdsk`) birgt die Gefahr, die alten Daten physisch zu √ºberschreiben und sie damit endg√ºltig zu zerst√∂ren. Der wichtigste Schritt ist daher, alle Schreibzugriffe zu verhindern und spezialisierte Datenrettungssoftware zu verwenden, die den Datentr√§ger Sektor f√ºr Sektor scannen kann.",
            "difficulty": "experte",
            "category": "Szenario-basiert"
        },
        {
            "question": "Welcher Befehl erstellt ein neues Verzeichnis namens `Test Data` im aktuellen Ordner? üóÇÔ∏è",
            "options": [
                "md Test Data",
                "md \"Test Data\"",
                "create Test Data",
                "dir \"Test Data\""
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Da der Verzeichnisname ein Leerzeichen enth√§lt, muss er in Anf√ºhrungszeichen `\" \"` eingeschlossen werden. Ohne Anf√ºhrungszeichen w√ºrde der `md` (make directory)-Befehl versuchen, zwei separate Verzeichnisse namens `Test` und `Data` zu erstellen. \n- **Option A:** W√ºrde zwei Ordner erstellen. ‚ùå\n- **Option C:** Der Befehl `create` existiert in diesem Kontext in der CMD nicht. ‚ùå\n- **Option D:** `dir` zeigt den Inhalt an, erstellt aber nichts. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "Sie m√∂chten alle Textdateien (`.txt`) im aktuellen Verzeichnis umbenennen, sodass sie stattdessen die Endung `.bak` haben. Welcher Befehl erledigt das f√ºr alle Dateien auf einmal? üîÑ",
            "options": [
                "move *.txt *.bak",
                "copy *.txt *.bak",
                "ren *.txt *.bak",
                "attrib *.txt -r"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `ren` (rename) ist f√ºr das Umbenennen von Dateien zust√§ndig. Er unterst√ºtzt die Verwendung von Wildcards (`*` und `?`), um Operationen auf mehrere Dateien gleichzeitig anzuwenden. Der Befehl `ren *.txt *.bak` findet alle Dateien, die auf `.txt` enden, und ersetzt die Endung durch `.bak`, w√§hrend der Dateiname erhalten bleibt.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "Vergleichen Sie die Befehle `date` und `time`. Was ist eine Gemeinsamkeit in ihrer Standardfunktionalit√§t in der CMD? üï∞Ô∏è",
            "options": [
                "Beide zeigen nur Informationen an und erlauben keine √Ñnderungen.",
                "Beide erfordern Administratorrechte, um ausgef√ºhrt zu werden.",
                "Beide zeigen den aktuellen Wert an und bieten direkt im Anschluss die M√∂glichkeit, einen neuen Wert einzugeben.",
                "Beide k√∂nnen ihre Ausgabe nur im `YYYY-MM-DD` bzw. `HH:MM:SS` Format darstellen."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Wenn `date` oder `time` ohne Parameter aufgerufen wird, zeigen sie zun√§chst den aktuellen Systemwert an. Direkt in der n√§chsten Zeile erscheint eine Eingabeaufforderung, in der der Benutzer ein neues Datum bzw. eine neue Uhrzeit eingeben kann. Dr√ºckt man einfach `Enter`, wird keine √Ñnderung vorgenommen. Diese interaktive Funktionalit√§t ist eine charakteristische Gemeinsamkeit der beiden Befehle.",
            "difficulty": "einsteiger",
            "category": "Vergleichende Analyse"
        },
        {
            "question": "Sie f√ºhren den Befehl `tree /f` in einem Ordner aus. Was unterscheidet die Ausgabe von einem einfachen `tree`-Befehl? üå≤",
            "options": [
                "Die Ausgabe wird in eine Datei namens 'f' geschrieben.",
                "Es werden nur die Verzeichnisse des ersten Levels angezeigt.",
                "Die Ausgabe wird alphabetisch sortiert.",
                "Zus√§tzlich zur Verzeichnisstruktur werden auch die Dateien in jedem Verzeichnis aufgelistet."
            ],
            "correct": 3,
            "explain": "**Begr√ºndung:** Der `tree`-Befehl zeigt die Ordnerstruktur eines Pfades grafisch an. Der Schalter `/f` (files) erweitert diese Funktionalit√§t und sorgt daf√ºr, dass nicht nur die Verzeichnisse, sondern auch alle darin enthaltenen Dateien aufgelistet werden, was einen vollst√§ndigen √úberblick √ºber die Hierarchie gibt.",
            "difficulty": "fortgeschritten",
            "category": "Verzeichnis-Befehle"
        },
        {
            "question": "Ein Benutzer m√∂chte ein Skript erstellen, das automatisch ein Backup-Verzeichnis erstellt. Das Verzeichnis soll nach dem aktuellen Datum benannt werden, z.B. 'Backup_2025-08-26'. Welche CMD-Funktion ist unerl√§sslich, um dies zu erreichen? üóìÔ∏è",
            "options": [
                "Die `date`-Variable, zug√§nglich √ºber `%DATE%`.",
                "Der `format`-Befehl mit einem Datumsparameter.",
                "Der `set`-Befehl allein.",
                "Der `doskey`-Befehl zur Makroerstellung."
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die CMD stellt Umgebungsvariablen bereit, die dynamische Systeminformationen enthalten. `%DATE%` ist eine solche Variable, die das aktuelle Systemdatum enth√§lt. In einem Skript k√∂nnte man also einen Befehl wie `md Backup_%DATE%` verwenden, um einen Ordner mit dem tagesaktuellen Datum im Namen zu erstellen. Dies ist eine grundlegende, aber extrem m√§chtige Technik f√ºr die Automatisierung.",
            "difficulty": "experte",
            "category": "Logische R√§tsel und Probleml√∂sung"
        },
        {
            "question": "Welcher `diskpart`-Befehl liefert detaillierte Informationen √ºber das aktuell ausgew√§hlte Objekt, z.B. den Typ, die Gr√∂√üe und den Status einer Partition? ‚ÑπÔ∏è",
            "options": [
                "list",
                "help",
                "detail",
                "attributes"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Nachdem ein Objekt mit `select` in den Fokus genommen wurde (z.B. `select partition 1`), liefert der Befehl `detail` spezifische Informationen genau zu diesem Objekt. `detail disk` zeigt z.B. Festplattendetails, `detail partition` Partitionsdetails und `detail volume` Volumedetails. \n- **`list`:** Zeigt eine √úbersicht aller Objekte eines Typs, aber keine Details zu einem einzelnen. ‚ùå\n- **`help`:** Zeigt Hilfe zu Befehlen an. ‚ùå\n- **`attributes`:** Dient zum Anzeigen und √Ñndern von Attributen, nicht zur allgemeinen Detailansicht. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        },
        {
            "question": "Wie kann man in der CMD schnell den Bildschirm von allen vorherigen Befehlen und Ausgaben bereinigen? üßº",
            "options": [
                "clear",
                "clean",
                "cls",
                "exit"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der Befehl `cls` (clear screen) ist der Standardbefehl in der Windows-Kommandozeile, um den gesamten Inhalt des Konsolenfensters zu l√∂schen und den Cursor in die obere linke Ecke zu setzen. \n- **`clear`:** Ist der entsprechende Befehl in Linux/Unix-Shells, funktioniert in CMD aber nicht. ‚ùå\n- **`clean`:** Ist ein `diskpart`-Befehl mit einer v√∂llig anderen (und gef√§hrlichen) Funktion. ‚ùå\n- **`exit`:** Schlie√üt das CMD-Fenster. ‚ùå",
            "difficulty": "einsteiger",
            "category": "Allgemeine Befehle"
        },
        {
            "question": "Sie m√ºssen eine Partition in `diskpart` als 'inaktiv' markieren. Welcher Befehl wird nach der Auswahl der Partition daf√ºr verwendet? ‚õî",
            "options": [
                "deactivate",
                "inactive",
                "remove active",
                "setid inactive"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl `inactive` ist das direkte Gegenst√ºck zum `active`-Befehl. Nachdem eine Partition ausgew√§hlt wurde (z.B. `select partition 1`), markiert der Befehl `inactive` diese als nicht mehr bootf√§hig. Dies ist eine wichtige Funktion bei der Verwaltung von Multi-Boot-Systemen.",
            "difficulty": "fortgeschritten",
            "category": "Datentr√§gerverwaltung (diskpart)"
        }
    ]
}