{
    "questions": [
        {
            "question": "Ein Datenbankadministrator m√∂chte alle Helden aus der 'helden'-Tabelle auslesen, die im Jahr 1955 geboren wurden und deren Nachname mit einem 'K' beginnt. Welche SQL-Abfrage sollte er verwenden? ü§î",
            "options": [
                "SELECT * FROM helden WHERE gebjahr = 1955 AND nachname LIKE 'K%';",
                "SELECT * FROM helden WHERE gebjahr = 1955 OR nachname LIKE 'K%';",
                "SELECT * FROM helden WHERE gebjahr = 1955, nachname LIKE 'K%';",
                "SELECT * FROM helden WHERE gebjahr = '1955' AND nachname = 'K%';"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie korrekte Abfrage verwendet `WHERE` mit den logischen Operatoren `AND` und `LIKE`. `AND` verkn√ºpft die beiden Bedingungen: Das Geburtsjahr muss 1955 sein UND der Nachname muss mit 'K' beginnen. Der `LIKE`-Operator in Kombination mit dem Wildcard-Zeichen `%` (beliebiger Text) erm√∂glicht die Suche nach einem Muster. \n- **Option B** ist falsch, da `OR` entweder Helden aus 1955 ODER Helden mit Nachnamen beginnend mit 'K' zur√ºckgeben w√ºrde, was nicht der Anforderung entspricht. \n- **Option C** ist syntaktisch falsch, da ein Komma nicht als logischer Operator in der `WHERE`-Klausel verwendet werden kann. \n- **Option D** ist in doppelter Hinsicht falsch: Das Jahr 1955 ist ein numerischer Wert und darf nicht in Anf√ºhrungszeichen stehen, und der `=` Operator sucht nach einer exakten √úbereinstimmung, nicht nach einem Muster wie `%`. üí°",
            "difficulty": "fortgeschritten",
            "category": "SELECT und Filter"
        },
        {
            "question": "Sie sollen in der 'helden'-Tabelle den Vornamen des Helden mit der helden_id '2' von 'Dag' in 'Dago' √§ndern. Welcher Befehl ist daf√ºr der Richtige? ‚úèÔ∏è",
            "options": [
                "UPDATE helden SET vorname = 'Dago' WHERE helden_id = 2;",
                "MODIFY helden SET vorname = 'Dago' WHERE helden_id = 2;",
                "UPDATE helden WHERE helden_id = 2 SET vorname = 'Dago';",
                "CHANGE helden vorname = 'Dago' WHERE helden_id = 2;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie korrekte Syntax f√ºr das Aktualisieren von Daten in einer Tabelle ist `UPDATE tabelle SET spalte = 'neuer_wert' WHERE bedingung;`. Hierbei wird mit `SET` festgelegt, welche Spalte ge√§ndert werden soll und mit `WHERE` wird der spezifische Datensatz ausgew√§hlt, der aktualisiert werden soll. \n- **Option B** und **D** sind falsche Befehle. Es gibt zwar √§hnliche Befehle f√ºr die Tabellenstruktur (`ALTER TABLE... MODIFY COLUMN` oder `CHANGE`), aber nicht f√ºr die Daten selbst. \n- **Option C** hat die falsche Reihenfolge der Klauseln; die `SET`-Klausel muss vor der `WHERE`-Klausel stehen. ‚úçÔ∏è",
            "difficulty": "einsteiger",
            "category": "Datenmanipulation (UPDATE)"
        },
        {
            "question": "Um die Anzahl der Helden in der 'helden'-Tabelle zu ermitteln, welche der folgenden Aggregat-Funktionen w√§re die richtige Wahl? üî¢",
            "options": [
                "SUM(*)",
                "COUNT(*)",
                "AVG(helden_id)",
                "MAX(helden_id)"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDie Aggregat-Funktion `COUNT(*)` ist der Standardweg, um die Anzahl der Zeilen (Datens√§tze) in einer Tabelle zu z√§hlen. Das `*` als Argument steht f√ºr 'alle Zeilen'. \n- **Option A** (`SUM`) w√ºrde versuchen, alle Werte zu addieren, was f√ºr eine Z√§hlung nicht sinnvoll ist. \n- **Option C** (`AVG`) berechnet den Durchschnitt, was hier nicht gefragt ist. \n- **Option D** (`MAX`) gibt den h√∂chsten Wert zur√ºck, was ebenfalls nicht der gew√ºnschten Z√§hlung entspricht. \n`COUNT(*)` ist am effizientesten, da es keine Spaltenwerte auslesen muss. üìä",
            "difficulty": "einsteiger",
            "category": "Aggregat-Funktionen"
        },
        {
            "question": "Ein Entwickler hat eine Abfrage geschrieben, die Daten aus der 'helden'- und der 'hut'-Tabelle miteinander verbindet. Er stellt jedoch fest, dass ihm Datens√§tze fehlen, f√ºr die in der 'hut'-Tabelle kein passender Eintrag existiert. Was k√∂nnte der Grund sein und wie kann er das beheben? ü§ù",
            "options": [
                "Er hat `INNER JOIN` verwendet. Er sollte stattdessen `RIGHT JOIN` nutzen, um alle Datens√§tze aus der 'hut'-Tabelle zu erhalten.",
                "Er hat `INNER JOIN` verwendet. Er sollte stattdessen `LEFT JOIN` nutzen, um alle Datens√§tze aus der 'helden'-Tabelle zu erhalten.",
                "Er hat eine falsche `ON`-Bedingung genutzt. Die Bedingung `helden.helden_id = hut.helden_id` ist fehlerhaft.",
                "Er hat `FULL JOIN` verwendet. Er sollte stattdessen `INNER JOIN` nutzen, um nur passende Datens√§tze zu sehen."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nEin `INNER JOIN` gibt nur die Datens√§tze zur√ºck, f√ºr die eine √úbereinstimmung in beiden Tabellen gefunden wird. Wenn also ein Held in der 'helden'-Tabelle keinen entsprechenden Eintrag in der 'hut'-Tabelle hat, wird dieser Held durch den `INNER JOIN` nicht im Ergebnis auftauchen. Die L√∂sung ist die Verwendung eines `LEFT JOIN` (oder `LEFT OUTER JOIN`), der alle Datens√§tze aus der linken Tabelle (`helden`) zur√ºckgibt, unabh√§ngig davon, ob es eine √úbereinstimmung in der rechten Tabelle (`hut`) gibt. \n- **Option A** ist falsch, da ein `RIGHT JOIN` alle Datens√§tze aus der `hut`-Tabelle, aber nicht unbedingt alle Helden, zur√ºckgeben w√ºrde. \n- **Option C** ist in der Regel korrekt, da die Bedingung der korrekte Weg ist, um die Tabellen √ºber den Prim√§r- und Fremdschl√ºssel zu verkn√ºpfen. \n- **Option D** ist ebenfalls falsch, da der `INNER JOIN` genau das beschriebene Problem verursacht. üîÑ",
            "difficulty": "experte",
            "category": "JOINs und Tabellenverkn√ºpfung"
        },
        {
            "question": "Sie m√ºssen einen neuen Helden mit den Daten ('Don', 'Vito', 1950, 'Sizilien') in die 'helden'-Tabelle einf√ºgen. Der Prim√§rschl√ºssel `helden_id` soll automatisch generiert werden. Welchen SQL-Befehl verwenden Sie? üìù",
            "options": [
                "INSERT INTO helden VALUES ('Don', 'Vito', 1950, 'Sizilien');",
                "INSERT INTO helden (vorname, nachname, gebjahr, land) VALUES ('Don', 'Vito', 1950, 'Sizilien');",
                "ADD INTO helden (vorname, nachname, gebjahr, land) VALUES ('Don', 'Vito', 1950, 'Sizilien');",
                "INSERT INTO helden (helden_id, vorname, nachname, gebjahr, land) VALUES (NULL, 'Don', 'Vito', 1950, 'Sizilien');"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDer korrekte Befehl, um einen neuen Datensatz einzuf√ºgen, ist `INSERT INTO tabelle (spalten) VALUES (werte);`. Durch die explizite Angabe der Spaltenliste in Klammern kann man den automatisch generierten Prim√§rschl√ºssel (wie `helden_id`) weglassen. \n- **Option A** ist falsch, da die Reihenfolge der Werte strikt mit der Spaltenreihenfolge der Tabelle √ºbereinstimmen muss und die `helden_id` nicht angegeben wird, was zu einem Fehler f√ºhren kann. \n- **Option C** verwendet einen nicht existierenden Befehl (`ADD INTO`). \n- **Option D** w√ºrde versuchen, eine `NULL`-Wert in den Prim√§rschl√ºssel einzuf√ºgen, was zwar in einigen Systemen funktioniert, aber nicht die bevorzugte Methode ist und in anderen Systemen zu Fehlern f√ºhren kann. üöÄ",
            "difficulty": "einsteiger",
            "category": "Datenmanipulation (INSERT)"
        },
        {
            "question": "Ein Programmierer m√∂chte die 'helden'-Tabelle so sortieren, dass die neuesten Geburtsjahre zuerst erscheinen und innerhalb desselben Geburtsjahres die Nachnamen alphabetisch sortiert sind. Welche der folgenden Abfragen w√ºrde dies erreichen? üìú",
            "options": [
                "SELECT * FROM helden ORDER BY gebjahr DESC, nachname ASC;",
                "SELECT * FROM helden ORDER BY nachname ASC, gebjahr DESC;",
                "SELECT * FROM helden SORT BY gebjahr DESC, nachname ASC;",
                "SELECT * FROM helden ORDER BY gebjahr DESC THEN nachname ASC;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Sortierung in SQL erfolgt mit der `ORDER BY`-Klausel. Wenn mehrere Kriterien f√ºr die Sortierung existieren, werden sie durch Kommas getrennt aufgelistet. Die Reihenfolge in der Klausel bestimmt die Sortierungsebene: Zuerst nach `gebjahr` absteigend (`DESC`), dann, falls die `gebjahr` Werte gleich sind, nach `nachname` aufsteigend (`ASC`). \n- **Option B** w√ºrde zuerst nach Nachnamen sortieren, was nicht den Anforderungen entspricht. \n- **Option C** verwendet den nicht existierenden Befehl `SORT BY`. \n- **Option D** ist syntaktisch falsch; die Sortierkriterien werden durch Kommata getrennt. ‚û°Ô∏è",
            "difficulty": "fortgeschritten",
            "category": "Sortierung (ORDER BY)"
        },
        {
            "question": "In der 'helden'-Tabelle ist der Geburtsjahr-Wert (`gebjahr`) f√ºr 'Digedag' '1953'. Was ist der Wert nach Ausf√ºhrung von `SELECT AVG(gebjahr) FROM helden;`? üî¢",
            "options": [
                "1954",
                "1953",
                "1953.5",
                "Die Abfrage schl√§gt fehl."
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie `AVG()`-Funktion berechnet den Durchschnitt der Werte in der angegebenen Spalte. Die Geburtsjahre in der Tabelle 'helden' sind: 1955, 1955 und 1953. Die Summe ist 1955 + 1955 + 1953 = 5863. Es gibt 3 Datens√§tze. Der Durchschnitt ist 5863 / 3 = 1954.333... Da die Optionen Ganzzahlen sind, ist die n√§chstgelegene Antwort 1954, die den arithmetischen Durchschnitt der gegebenen Daten korrekt wiedergibt. \n- **Option B** w√§re das Minimum, nicht der Durchschnitt. \n- **Option C** ist nicht korrekt. \n- **Option D** ist falsch, da die Abfrage syntaktisch korrekt ist und einen numerischen Wert zur√ºckgibt. üéØ",
            "difficulty": "fortgeschritten",
            "category": "Berechnung (AVG)"
        },
        {
            "question": "Wahr oder Falsch? Die Gro√ü- und Kleinschreibung von SQL-Befehlen (`SELECT`, `FROM`, `WHERE`) spielt keine Rolle, w√§hrend die Gro√ü- und Kleinschreibung von Textwerten innerhalb der Anf√ºhrungszeichen (`'Sachsen'`) von der Datenbank unterschieden wird. üíª",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Aussage ist wahr. SQL-Befehle, Schl√ºsselw√∂rter und Klauseln (wie `SELECT`, `FROM`, `WHERE`) sind case-insensitiv. Man kann sie in Gro√übuchstaben, Kleinbuchstaben oder einer Mischung schreiben, und die Abfrage funktioniert trotzdem. Im Gegensatz dazu sind die tats√§chlichen Datenwerte, die in Anf√ºhrungszeichen stehen, wie 'Sachsen', case-sensitiv. Das bedeutet, dass die Suche nach `'sachsen'` m√∂glicherweise keinen Treffer findet, wenn der gespeicherte Wert `'Sachsen'` ist. Dies ist jedoch von der spezifischen Datenbank-Software (z.B. MySQL, PostgreSQL) und ihrer Konfiguration abh√§ngig. ‚öñÔ∏è",
            "difficulty": "einsteiger",
            "category": "Syntaxregeln"
        },
        {
            "question": "Ein Anwender hat in der 'helden'-Tabelle alle Datens√§tze mit dem `vorname` 'Dig' gel√∂scht. Sein Befehl war `DELETE FROM helden WHERE vorname = 'Dig';`. Jetzt m√∂chte er diese Aktion r√ºckg√§ngig machen. Was ist die beste Vorgehensweise? üîô",
            "options": [
                "Er kann `UNDO DELETE FROM helden` verwenden, um die gel√∂schten Datens√§tze wiederherzustellen.",
                "Er muss die Datenbank aus einem Backup wiederherstellen oder die Datens√§tze manuell neu einf√ºgen.",
                "Er kann `ROLLBACK` verwenden, um die Transaktion r√ºckg√§ngig zu machen.",
                "Er kann die Datens√§tze nicht wiederherstellen, da SQL-Befehle permanent sind."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nIn der Praxis sind einfache `DELETE`-Befehle in den meisten SQL-Umgebungen nicht direkt r√ºckg√§ngig zu machen, es sei denn, sie wurden innerhalb einer Transaktion ausgef√ºhrt und diese wird noch nicht abgeschlossen. Da in der Aufgabe keine Transaktion erw√§hnt wird, ist der Befehl als permanent anzusehen. Die sicherste und √ºbliche Methode, um verlorene Daten wiederherzustellen, ist die Wiederherstellung aus einem aktuellen Backup. Alternativ m√ºssten die Daten manuell wieder eingef√ºgt werden. \n- **Option A** ist falsch, da es keinen `UNDO DELETE` Befehl in SQL gibt. \n- **Option C** ist nur dann g√ºltig, wenn der `DELETE`-Befehl Teil einer Transaktion war und diese noch nicht durch `COMMIT` abgeschlossen wurde. \n- **Option D** ist zu absolut formuliert; die Wiederherstellung ist, wie in Option B beschrieben, m√∂glich. üíæ",
            "difficulty": "experte",
            "category": "Datenmanipulation (DELETE)"
        },
        {
            "question": "Ein Nutzer f√ºhrt die Abfrage `SELECT vorname, nachname FROM helden WHERE nachname LIKE '%dag';` aus. Welches Ergebnis wird er erhalten? üïµÔ∏è",
            "options": [
                "Digedag Gro√ü",
                "Dag Blond und Digedag Gro√ü",
                "Dag Blond",
                "Es gibt keine √úbereinstimmungen, da `dag` klein geschrieben ist."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDie Abfrage verwendet den `LIKE`-Operator mit dem Wildcard `%`, was bedeutet, dass nach allen Nachnamen gesucht wird, die mit 'dag' enden. Laut der Beispieltabelle sind die Nachnamen 'Blond' und 'Gro√ü' vorhanden. Jedoch ist die `LIKE`-Klausel auf den Vornamen 'Dag' und 'Digedag' bezogen.  Der Text 'nachname LIKE '%dag'' ist ein Tippfehler. Korrekt w√§re `vorname LIKE '%dag'`. Gehen wir davon aus, dass der Fehler in der Frage liegt und der `vorname` gemeint ist: Die Vornamen 'Dag' und 'Digedag' enden beide mit 'dag'. Daher werden beide Datens√§tze zur√ºckgegeben. Die Gro√ü- und Kleinschreibung spielt bei den Befehlen selbst keine Rolle, aber bei Textwerten, je nach Datenbank. In diesem Fall ist es meist case-insensitiv. \n- **Option A** ist unvollst√§ndig. \n- **Option C** ist unvollst√§ndig. \n- **Option D** ist falsch, da die Suche nach 'dag' in den meisten Standardeinstellungen auch 'Dag' finden w√ºrde. üìù",
            "difficulty": "einsteiger",
            "category": "Wildcards und Filter"
        },
        {
            "question": "Sie haben die Aufgabe, eine Abfrage zu erstellen, die die Anzahl der Helden pro Geburtsjahr z√§hlt. Wie gehen Sie vor? üí°",
            "options": [
                "SELECT COUNT(*) FROM helden GROUP BY gebjahr;",
                "SELECT COUNT(gebjahr), gebjahr FROM helden GROUP BY gebjahr;",
                "SELECT COUNT(gebjahr) FROM helden;",
                "SELECT * FROM helden GROUP BY gebjahr;"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDie korrekte Vorgehensweise erfordert die Verwendung der `GROUP BY`-Klausel, um die Datens√§tze nach dem `gebjahr` zu gruppieren. Danach wird die Aggregat-Funktion `COUNT()` auf jede dieser Gruppen angewandt. Um sowohl die Anzahl als auch das jeweilige Geburtsjahr im Ergebnis zu sehen, m√ºssen beide in der `SELECT`-Klausel stehen. \n- **Option A** ist fast korrekt, gibt aber nicht das Geburtsjahr selbst aus. \n- **Option C** z√§hlt nur die Gesamtzahl der Helden, nicht pro Jahr. \n- **Option D** ist syntaktisch falsch; in einer `GROUP BY`-Abfrage m√ºssen alle nicht-aggregierten Spalten auch in der `GROUP BY`-Klausel stehen. üìä",
            "difficulty": "fortgeschritten",
            "category": "Gruppierung (GROUP BY)"
        },
        {
            "question": "Wahr oder Falsch? Der SQL-Befehl `SELECT * FROM helden;` und der Befehl `SELECT * FROM helden ORDER BY nachname ASC;` liefern immer die gleiche Anzahl von Datens√§tzen. ‚úÖ",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Aussage ist wahr. Die `ORDER BY`-Klausel √§ndert lediglich die Reihenfolge der Datens√§tze im Ergebnis. Sie filtert keine Zeilen heraus und f√ºgt auch keine hinzu. Daher ist die Anzahl der zur√ºckgegebenen Zeilen immer identisch, unabh√§ngig von der Sortierung. üîÑ",
            "difficulty": "einsteiger",
            "category": "Sortierung (ORDER BY)"
        },
        {
            "question": "Sie m√∂chten alle Helden aus der 'helden'-Tabelle l√∂schen, deren `helden_id` gr√∂√üer als 2 ist. Wie lautet der korrekte Befehl? üóëÔ∏è",
            "options": [
                "DELETE FROM helden WHERE helden_id > 2;",
                "REMOVE FROM helden WHERE helden_id > 2;",
                "DELETE FROM helden WHERE helden_id > '2';",
                "DELETE ALL FROM helden WHERE helden_id > 2;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDer korrekte Befehl zum L√∂schen von Datens√§tzen ist `DELETE FROM tabelle WHERE bedingung;`. Die Bedingung `helden_id > 2` w√§hlt alle Datens√§tze mit einer ID gr√∂√üer als 2 aus. \n- **Option B** ist ein ung√ºltiger Befehl. \n- **Option C** ist falsch, da '2' als String behandelt wird und der Vergleich zu unvorhersehbaren Ergebnissen f√ºhren kann oder fehlschl√§gt. \n- **Option D** verwendet den ung√ºltigen Zusatz `ALL`. üßπ",
            "difficulty": "einsteiger",
            "category": "Datenmanipulation (DELETE)"
        },
        {
            "question": "Ein Junior-Entwickler schreibt die Abfrage `SELECT helden.vorname, hut.hutfarbe FROM helden, hut WHERE helden.helden_id = hut.helden_id;`. Ein erfahrener Entwickler r√§t ihm, stattdessen `SELECT helden.vorname, hut.hutfarbe FROM helden INNER JOIN hut ON helden.helden_id = hut.helden_id;` zu verwenden. Warum ist die zweite Variante aus didaktischer Sicht vorzuziehen? üßë‚Äçüíª",
            "options": [
                "Die erste Variante ist syntaktisch inkorrekt und wird einen Fehler verursachen.",
                "Die zweite Variante ist intuitiver und expliziter, da sie die Join-Art (`INNER JOIN`) klar benennt.",
                "Die erste Variante ist ineffizienter und f√ºhrt zu einer schlechteren Performance.",
                "Die zweite Variante gibt mehr Datens√§tze zur√ºck, da der `INNER JOIN` eine erweiterte Funktionalit√§t bietet."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nBeide Abfragen liefern dasselbe Ergebnis. Die erste ist die √§ltere, implizite Syntax f√ºr Joins. Die zweite Variante (`INNER JOIN ... ON`) ist die moderne, explizite Syntax. Aus didaktischer Sicht ist sie klarer und besser lesbar, da sie die Absicht des Entwicklers, die Tabellen zu verkn√ºpfen, eindeutig kommuniziert. Zudem macht sie es einfacher, zu anderen Join-Typen (`LEFT JOIN`, `RIGHT JOIN`) zu wechseln. Die Performance-Unterschiede sind in der Regel vernachl√§ssigbar. \n- **Option A** ist falsch; beide Varianten sind syntaktisch korrekt. \n- **Option C** ist in den meisten modernen Datenbank-Engines nicht korrekt. \n- **Option D** ist falsch; beide Joins geben exakt die gleiche Anzahl an Datens√§tzen zur√ºck. üß†",
            "difficulty": "fortgeschritten",
            "category": "JOINs und Syntax"
        },
        {
            "question": "Welche der folgenden Aussagen √ºber SQL-Befehle ist falsch? ‚ùå",
            "options": [
                "Jeder Befehl muss mit einem Semikolon enden.",
                "Textwerte m√ºssen in Anf√ºhrungszeichen geschrieben werden.",
                "SQL-Befehle m√ºssen immer in einer einzigen Zeile geschrieben werden.",
                "SELECT-Befehle werden verwendet, um Daten aus Tabellen abzufragen."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:**\nDie Aussage, dass SQL-Befehle immer in einer einzigen Zeile geschrieben werden m√ºssen, ist falsch. Zur besseren Lesbarkeit, insbesondere bei komplexen Abfragen, ist es √ºblich und erlaubt, einen SQL-Befehl √ºber mehrere Zeilen zu verteilen. Das Semikolon am Ende kennzeichnet das Ende des Befehls. \n- **Option A** ist wahr, es ist eine Standardregel f√ºr die Ausf√ºhrung von Befehlen. \n- **Option B** ist wahr, Text- und Datumswerte m√ºssen in Anf√ºhrungszeichen eingeschlossen sein. \n- **Option D** ist wahr, da `SELECT` die grundlegende Anweisung zum Lesen von Daten ist. üìã",
            "difficulty": "einsteiger",
            "category": "Grundregeln"
        },
        {
            "question": "Sie haben die Aufgabe, die `nachname` von allen Helden, deren Geburtsjahr vor 1955 liegt, in 'Unbekannt' zu √§ndern. Wie lautet der korrekte SQL-Befehl? ü§´",
            "options": [
                "UPDATE helden SET nachname = 'Unbekannt' WHERE gebjahr < 1955;",
                "CHANGE helden nachname = 'Unbekannt' WHERE gebjahr < 1955;",
                "UPDATE helden WHERE gebjahr < 1955 SET nachname = 'Unbekannt';",
                "UPDATE helden SET nachname = 'Unbekannt' WHERE gebjahr = '1953';"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDer korrekte Befehl zum √Ñndern von Datens√§tzen ist `UPDATE tabelle SET spalte = 'neuer_wert' WHERE bedingung;`. Die Bedingung `gebjahr < 1955` w√§hlt alle Datens√§tze aus, deren Geburtsjahr vor 1955 liegt. \n- **Option B** ist ein ung√ºltiger Befehl. \n- **Option C** hat die falsche Reihenfolge. Die `SET`-Klausel muss vor der `WHERE`-Klausel stehen. \n- **Option D** w√ºrde nur den Helden aus 1953, nicht aber alle Helden vor 1955 √§ndern. Au√üerdem wird hier der numerische Wert in Anf√ºhrungszeichen gesetzt, was falsch ist. ‚úçÔ∏è",
            "difficulty": "fortgeschritten",
            "category": "Datenmanipulation (UPDATE)"
        },
        {
            "question": "Wahr oder Falsch? Die Abfrage `SELECT COUNT(*), gebjahr FROM helden GROUP BY gebjahr;` z√§hlt, wie oft jedes Geburtsjahr in der Tabelle vorkommt. üìä",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Aussage ist wahr. Der Befehl gruppiert die Datens√§tze nach dem Wert in der Spalte `gebjahr`. Anschlie√üend z√§hlt `COUNT(*)` die Anzahl der Datens√§tze in jeder dieser Gruppen. Das Ergebnis ist eine Liste, die f√ºr jedes eindeutige Geburtsjahr die jeweilige Anzahl der Helden anzeigt. Das ist die Standardmethode f√ºr Z√§hlungen pro Gruppe. ‚úÖ",
            "difficulty": "einsteiger",
            "category": "Aggregat-Funktionen"
        },
        {
            "question": "Sie m√ºssen alle Datens√§tze aus der `helden`-Tabelle l√∂schen. Welcher Befehl ist am effektivsten? üí•",
            "options": [
                "DELETE FROM helden;",
                "DELETE FROM helden WHERE 1=1;",
                "TRUNCATE TABLE helden;",
                "DROP TABLE helden;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nUm alle Datens√§tze zu l√∂schen, ohne die Tabellenstruktur zu ver√§ndern, ist der einfachste Befehl `DELETE FROM helden;`. Dieser Befehl ist, im Gegensatz zu `TRUNCATE`, eine DML-Anweisung (Data Manipulation Language) und kann, je nach Datenbank-System, r√ºckg√§ngig gemacht werden, falls man in einer Transaktion arbeitet. \n- **Option B** ist ebenfalls g√ºltig, aber der `WHERE 1=1` ist redundant, da er immer wahr ist und daher alle Zeilen l√∂scht. \n- **Option C** (`TRUNCATE TABLE`) ist eine DDL-Anweisung (Data Definition Language) und ist in der Regel schneller und effizienter, da sie die Datens√§tze nicht einzeln l√∂scht, sondern die gesamte Tabelle quasi 'leert'. Sie kann jedoch nicht r√ºckg√§ngig gemacht werden. \n- **Option D** (`DROP TABLE`) l√∂scht die gesamte Tabelle samt ihrer Struktur, was nicht der Anforderung entspricht. ‚ùó",
            "difficulty": "experte",
            "category": "Datenmanipulation (DELETE)"
        },
        {
            "question": "Ein Programmierer m√∂chte die 'helden'-Tabelle nach dem `nachname` aufsteigend sortieren. Welcher Befehl ist korrekt und wie w√ºrde er die Sortierung von 'Blond' und 'Knoll' handhaben? üìù",
            "options": [
                "SELECT * FROM helden ORDER BY nachname ASC; Es sortiert alphabetisch, also 'Blond' vor 'Knoll'.",
                "SELECT * FROM helden ORDER BY nachname DESC; Es sortiert alphabetisch, also 'Blond' vor 'Knoll'.",
                "SELECT * FROM helden SORT BY nachname ASC; Es sortiert alphabetisch, also 'Knoll' vor 'Blond'.",
                "SELECT * FROM helden ORDER BY nachname; Es sortiert alphabetisch, aber nur, wenn die Spalte `nachname` ein String ist."
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie korrekte Syntax f√ºr eine aufsteigende Sortierung ist `ORDER BY spalte ASC`. Das `ASC` kann weggelassen werden, da es der Standardwert ist. Die Sortierung erfolgt alphabetisch. Daher kommt 'Blond' vor 'Knoll'. \n- **Option B** ist falsch, da `DESC` absteigend sortiert und somit 'Knoll' vor 'Blond' k√§me. \n- **Option C** verwendet einen ung√ºltigen Befehl (`SORT BY`) und die Reihenfolge ist falsch. \n- **Option D** ist falsch, da `ORDER BY` immer funktioniert, solange der Datentyp sortierbar ist, und das `ASC` weggelassen werden kann. üìú",
            "difficulty": "einsteiger",
            "category": "Sortierung (ORDER BY)"
        },
        {
            "question": "Welcher SQL-Befehl wird verwendet, um neue Datens√§tze in eine bestehende Tabelle einzuf√ºgen? ‚ûï",
            "options": [
                "ADD INTO",
                "INSERT INTO",
                "CREATE INTO",
                "PUT INTO"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDer Standard-SQL-Befehl zum Hinzuf√ºgen (Einf√ºgen) neuer Datens√§tze in eine Tabelle ist `INSERT INTO`. \n- **Option A**, **C** und **D** sind ung√ºltige Befehle in Standard-SQL f√ºr diesen Zweck. `CREATE` wird verwendet, um neue Objekte wie Tabellen zu erstellen, aber nicht, um Daten einzuf√ºgen. üì•",
            "difficulty": "einsteiger",
            "category": "Datenmanipulation (INSERT)"
        },
         {
            "question": "Welche SQL-Befehle geh√∂ren zur Gruppe der Data Manipulation Language (DML) und werden zum √Ñndern von Daten verwendet? ‚úçÔ∏è",
            "options": [
                "CREATE, ALTER, DROP",
                "SELECT, INSERT, UPDATE, DELETE",
                "GRANT, REVOKE",
                "COMMIT, ROLLBACK"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDie Data Manipulation Language (DML) umfasst Befehle zur Manipulation der Daten innerhalb von Tabellen. Dazu geh√∂ren `SELECT` (Lesen/Abfragen), `INSERT` (Einf√ºgen), `UPDATE` (√Ñndern) und `DELETE` (L√∂schen). \n- **Option A** sind DDL-Befehle (Data Definition Language) zur Definition und √Ñnderung der Datenbankstruktur. \n- **Option C** sind DCL-Befehle (Data Control Language) zur Steuerung von Zugriffsrechten. \n- **Option D** sind TCL-Befehle (Transaction Control Language) zur Steuerung von Transaktionen. üìÇ",
            "difficulty": "einsteiger",
            "category": "SQL-Kategorien"
        },
        {
            "question": "Ein Datenbank-Benutzer m√∂chte wissen, wie viele Helden in der 'helden'-Tabelle den gleichen Nachnamen 'Knoll' haben. Welche Abfrage liefert die korrekte Anzahl? üî¢",
            "options": [
                "SELECT COUNT(*) FROM helden WHERE nachname = 'Knoll';",
                "SELECT COUNT(nachname) FROM helden WHERE nachname LIKE 'Knoll';",
                "SELECT COUNT(*) FROM helden GROUP BY nachname HAVING nachname = 'Knoll';",
                "SELECT SUM(nachname) FROM helden WHERE nachname = 'Knoll';"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDer Befehl `SELECT COUNT(*) FROM helden WHERE nachname = 'Knoll';` ist der effizienteste und direkteste Weg. Die `WHERE`-Klausel filtert zuerst die Datens√§tze, die der Bedingung entsprechen, und `COUNT(*)` z√§hlt dann die Anzahl der verbleibenden Zeilen. \n- **Option B** ist fast korrekt, aber die Verwendung von `=` ist hier besser als `LIKE`, da es sich um eine exakte √úbereinstimmung handelt. \n- **Option C** ist unn√∂tig komplex. `GROUP BY` ist f√ºr die Z√§hlung nach Gruppen gedacht. Der `HAVING`-Filter wird auf die Gruppen angewendet, nicht auf die einzelnen Datens√§tze. Ein einfacher `WHERE`-Filter reicht hier aus. \n- **Option D** ist falsch, da `SUM()` nur auf numerische Werte angewendet werden kann. üìä",
            "difficulty": "fortgeschritten",
            "category": "Aggregat-Funktionen"
        },
        {
            "question": "Wahr oder Falsch? Der Befehl `DELETE FROM helden;` l√∂scht alle Datens√§tze in der 'helden'-Tabelle und kann mit `ROLLBACK` r√ºckg√§ngig gemacht werden, wenn die Transaktion noch nicht abgeschlossen ist. üîÑ",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Aussage ist wahr. `DELETE FROM helden;` l√∂scht alle Zeilen, ohne die Tabellenstruktur zu beeintr√§chtigen. Da `DELETE` ein DML-Befehl ist, kann er Teil einer Transaktion sein. Wenn vor dem `DELETE` ein `BEGIN TRANSACTION` (oder √§hnliches) ausgef√ºhrt wurde und danach noch kein `COMMIT`, kann man die Aktion mit `ROLLBACK` r√ºckg√§ngig machen. Im Gegensatz dazu l√∂scht `TRUNCATE TABLE` die Daten unwiderruflich. üí°",
            "difficulty": "fortgeschritten",
            "category": "Datenmanipulation (DELETE)"
        },
        {
            "question": "Sie m√ºssen einen neuen Helden ('Dagmar', 'Blond', 1956, 'Th√ºringen') in die 'helden'-Tabelle einf√ºgen. Es ist bekannt, dass `helden_id` ein automatisch generierter Prim√§rschl√ºssel ist. Welcher Befehl ist syntaktisch korrekt? üìù",
            "options": [
                "INSERT INTO helden VALUES ('Dagmar', 'Blond', 1956, 'Th√ºringen');",
                "INSERT INTO helden (vorname, nachname, gebjahr, land) VALUES ('Dagmar', 'Blond', 1956, 'Th√ºringen');",
                "INSERT INTO helden VALUES (NULL, 'Dagmar', 'Blond', 1956, 'Th√ºringen');",
                "INSERT helden (vorname, nachname, gebjahr, land) VALUES ('Dagmar', 'Blond', 1956, 'Th√ºringen');"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDie korrekte Syntax f√ºr das Einf√ºgen von Daten, wenn der Prim√§rschl√ºssel automatisch generiert wird, besteht darin, die Liste der Spalten explizit anzugeben und den Prim√§rschl√ºssel wegzulassen. \n- **Option A** ist riskant, da sie von der Annahme abh√§ngt, dass die Reihenfolge der Werte mit der physischen Spaltenreihenfolge der Tabelle √ºbereinstimmt, was zu Fehlern f√ºhren kann, wenn die Struktur ge√§ndert wird. \n- **Option C** kann in einigen SQL-Dialekten funktionieren, ist aber nicht die empfohlene Methode. \n- **Option D** fehlt das `INTO`-Schl√ºsselwort nach `INSERT`. üöÄ",
            "difficulty": "einsteiger",
            "category": "Datenmanipulation (INSERT)"
        },
        {
            "question": "Sie sollen die Nachnamen aller Helden aus der 'helden'-Tabelle abfragen und m√∂chten sicherstellen, dass jeder Nachname nur einmal im Ergebnis vorkommt. Welcher Befehl ist daf√ºr am besten geeignet? üßê",
            "options": [
                "SELECT DISTINCT nachname FROM helden;",
                "SELECT UNIQUE nachname FROM helden;",
                "SELECT nachname FROM helden GROUP BY nachname;",
                "SELECT nachname FROM helden ORDER BY nachname;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDer Befehl `SELECT DISTINCT` ist die Standardmethode, um nur die eindeutigen (distinkten) Werte einer oder mehrerer Spalten zur√ºckzugeben. \n- **Option B** (`UNIQUE`) ist kein g√ºltiges SQL-Schl√ºsselwort f√ºr diesen Zweck. \n- **Option C** (`GROUP BY`) w√ºrde ebenfalls das korrekte Ergebnis liefern, ist aber f√ºr diesen einfachen Anwendungsfall unn√∂tig komplex. `DISTINCT` ist die direktere und intuitivere L√∂sung. \n- **Option D** sortiert die Nachnamen, entfernt aber keine Duplikate. üìö",
            "difficulty": "fortgeschritten",
            "category": "Abfragen und Duplikate"
        },
        {
            "question": "Um das Geburtsjahr des √§ltesten Helden aus der 'helden'-Tabelle zu finden, welche Aggregat-Funktion ist zu verwenden? üë∂",
            "options": [
                "MAX(gebjahr)",
                "MIN(gebjahr)",
                "AVG(gebjahr)",
                "SUM(gebjahr)"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDas √§lteste Geburtsjahr ist die kleinste Zahl. Daher muss die `MIN()`-Funktion verwendet werden, um den kleinsten Wert in der Spalte `gebjahr` zu finden. \n- **Option A** (`MAX`) w√ºrde das j√ºngste Geburtsjahr (die gr√∂√üte Zahl) zur√ºckgeben. \n- **Option C** (`AVG`) berechnet den Durchschnitt. \n- **Option D** (`SUM`) summiert die Werte. üí°",
            "difficulty": "einsteiger",
            "category": "Aggregat-Funktionen"
        },
        {
            "question": "Ein Entwickler m√∂chte alle Helden aus der 'helden'-Tabelle abfragen, deren `vorname` nicht mit 'Dig' beginnt. Welche Abfrage ist korrekt? üö´",
            "options": [
                "SELECT * FROM helden WHERE vorname NOT LIKE 'Dig%';",
                "SELECT * FROM helden WHERE vorname <> 'Dig%';",
                "SELECT * FROM helden WHERE NOT vorname LIKE 'Dig%';",
                "SELECT * FROM helden WHERE vorname != 'Dig%';"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie korrekte Abfrage verwendet den `NOT LIKE`-Operator. Er ist die Negation von `LIKE` und sucht nach Werten, die dem angegebenen Muster nicht entsprechen. \n- **Option B** und **D** verwenden den Ungleich-Operator (`<>` oder `!=`), der f√ºr eine exakte √úbereinstimmung, nicht f√ºr Mustervergleiche mit Wildcards, gedacht ist. \n- **Option C** ist syntaktisch ebenfalls korrekt, aber `NOT LIKE` ist die gebr√§uchlichere und lesbarere Schreibweise. ‚ùå",
            "difficulty": "fortgeschritten",
            "category": "Wildcards und Filter"
        },
        {
            "question": "Sie m√∂chten die Datens√§tze der 'helden'-Tabelle nach dem `nachname` aufsteigend sortieren. Welche Abfrage ist syntaktisch korrekt? üìú",
            "options": [
                "SELECT * FROM helden ORDER BY nachname ASC;",
                "SELECT * FROM helden SORT BY nachname;",
                "SELECT * FROM helden ORDER BY nachname;",
                "SELECT * FROM helden SORTED BY nachname ASC;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie korrekte Syntax f√ºr die Sortierung ist `ORDER BY spalte [ASC|DESC]`. Die Klausel `ASC` f√ºr aufsteigende Sortierung kann dabei weggelassen werden, da sie der Standardwert ist. \n- **Option B** und **D** verwenden ung√ºltige Schl√ºsselw√∂rter (`SORT BY`, `SORTED BY`). \n- **Option C** ist ebenfalls korrekt, da `ASC` der Standard ist, aber die explizite Angabe in **Option A** ist aus didaktischer Sicht klarer. ‚úÖ",
            "difficulty": "einsteiger",
            "category": "Sortierung (ORDER BY)"
        },
        {
            "question": "In einer SQL-Abfrage steht `WHERE vorname LIKE '_ig%'`. Welches Ergebnis w√ºrde dies in der 'helden'-Tabelle liefern? üïµÔ∏è‚Äç‚ôÇÔ∏è",
            "options": [
                "Alle Vornamen, die mit 'ig' enden.",
                "Alle Vornamen, die ein 'ig' enthalten.",
                "Alle Vornamen, die mit einem beliebigen Zeichen beginnen, gefolgt von 'ig' und beliebigem Text.",
                "Kein Ergebnis, da die Syntax fehlerhaft ist."
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:**\nDas Unterstrich-Wildcard-Zeichen (`_`) steht f√ºr genau ein beliebiges Zeichen. Das Prozentzeichen (`%`) steht f√ºr eine beliebige Anzahl von Zeichen (einschlie√ülich null). Daher bedeutet `_ig%`, dass der `vorname` mit einem beliebigen Zeichen beginnt, dann 'ig' folgt und danach ein beliebiger Text stehen kann. Beispiele aus der Tabelle w√§ren `Dig`. `Dag` und `Digedag` entsprechen nicht dieser Bedingung. \n- **Option A** w√ºrde `%ig` erfordern. \n- **Option B** w√ºrde `%ig%` erfordern. \n- **Option D** ist falsch, die Syntax ist korrekt. üí°",
            "difficulty": "fortgeschritten",
            "category": "Wildcards und Filter"
        },
        {
            "question": "Sie m√∂chten den Nachnamen des Helden mit der `helden_id` 3 von 'Gro√ü' auf 'Klein' √§ndern. Was ist der korrekte Befehl? ‚úèÔ∏è",
            "options": [
                "UPDATE helden SET nachname = 'Klein' WHERE helden_id = 3;",
                "SET helden nachname = 'Klein' WHERE helden_id = 3;",
                "MODIFY helden nachname = 'Klein' WHERE helden_id = 3;",
                "UPDATE helden WHERE nachname = 'Gro√ü' SET nachname = 'Klein';"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie korrekte Syntax f√ºr das √Ñndern von Daten ist `UPDATE tabelle SET spalte = neuer_wert WHERE bedingung;`. \n- **Option B** und **C** verwenden ung√ºltige Befehle f√ºr diese Operation. \n- **Option D** ist fehlerhaft, da sie nicht den spezifischen Datensatz √ºber die ID ausw√§hlt und die `SET`-Klausel vor der `WHERE`-Klausel stehen muss. üîÑ",
            "difficulty": "einsteiger",
            "category": "Datenmanipulation (UPDATE)"
        },
        {
            "question": "Welche SQL-Befehle werden typischerweise f√ºr die Erstellung, √Ñnderung und L√∂schung der Datenbankstruktur (Tabellen, Indizes etc.) verwendet? üõ†Ô∏è",
            "options": [
                "SELECT, INSERT, UPDATE, DELETE",
                "CREATE, ALTER, DROP",
                "GRANT, REVOKE, DENY",
                "BEGIN, COMMIT, ROLLBACK"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDiese Befehle geh√∂ren zur Data Definition Language (DDL). `CREATE` wird verwendet, um neue Objekte zu erstellen, `ALTER` um bestehende zu √§ndern und `DROP` um sie zu l√∂schen. \n- **Option A** sind DML-Befehle (Datenmanipulation). \n- **Option C** sind DCL-Befehle (Zugriffsrechte). \n- **Option D** sind TCL-Befehle (Transaktionskontrolle). üèóÔ∏è",
            "difficulty": "fortgeschritten",
            "category": "SQL-Kategorien"
        },
        {
            "question": "Wahr oder Falsch? Ein `LEFT JOIN` zwischen der 'helden'-Tabelle (links) und der 'hut'-Tabelle (rechts) gibt alle Helden zur√ºck, auch jene, die keinen zugeh√∂rigen Hut-Eintrag haben. ‚úÖ",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Aussage ist wahr. Ein `LEFT JOIN` (oder `LEFT OUTER JOIN`) gibt alle Datens√§tze aus der 'linken' Tabelle (hier 'helden') zur√ºck, unabh√§ngig davon, ob es passende Datens√§tze in der 'rechten' Tabelle gibt. F√ºr die Datens√§tze, bei denen keine √úbereinstimmung gefunden wird, werden die Spalten der 'rechten' Tabelle mit `NULL`-Werten gef√ºllt. Dies ist der Hauptunterschied zum `INNER JOIN`. ü§ù",
            "difficulty": "fortgeschritten",
            "category": "JOINs und Tabellenverkn√ºpfung"
        },
        {
            "question": "Um die Durchschnitts-Lebenszeit der Helden zu berechnen, die in Sachsen geboren wurden, welche SQL-Abfrage sollte man verwenden? üí°",
            "options": [
                "SELECT AVG(YEAR(CURDATE()) - gebjahr) FROM helden WHERE land = 'Sachsen';",
                "SELECT AVG(gebjahr) FROM helden WHERE land = 'Sachsen';",
                "SELECT SUM(YEAR(CURDATE()) - gebjahr) / COUNT(*) FROM helden WHERE land = 'Sachsen';",
                "SELECT AVG(gebjahr) FROM helden WHERE land = 'Sachsen' GROUP BY land;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nUm die Lebenszeit zu berechnen, muss das Geburtsjahr vom aktuellen Jahr abgezogen werden. Die Funktion `CURDATE()` (oder ein √§hnlicher Befehl, je nach Datenbank) liefert das aktuelle Datum, und `YEAR()` extrahiert das Jahr daraus. `AVG()` berechnet den Durchschnitt dieser Werte. \n- **Option B** w√ºrde nur den Durchschnitt der Geburtsjahre ermitteln, nicht die Lebenszeit. \n- **Option C** ist rechnerisch korrekt, aber die Verwendung der `AVG()`-Funktion, wie in Option A, ist eleganter und lesbarer. \n- **Option D** gruppiert zwar nach dem Land, aber dies ist hier unn√∂tig, da die `WHERE`-Klausel bereits auf 'Sachsen' filtert. üìä",
            "difficulty": "experte",
            "category": "Berechnungsaufgaben"
        },
        {
            "question": "Wahr oder Falsch? Der Befehl `SELECT * FROM helden ORDER BY gebjahr DESC;` liefert alle Datens√§tze der Tabelle in absteigender Reihenfolge des Geburtsjahres. üìâ",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Aussage ist wahr. Die Klausel `ORDER BY` sortiert die Ergebnisse. Der Zusatz `DESC` steht f√ºr 'descending', also absteigend. Die Ergebnisse werden also vom neuesten (gr√∂√üte Jahreszahl) zum √§ltesten Geburtsjahr (kleinste Jahreszahl) sortiert. ‚úÖ",
            "difficulty": "einsteiger",
            "category": "Sortierung (ORDER BY)"
        },
        {
            "question": "Ein Programmierer m√∂chte die Anzahl der Helden z√§hlen, deren `vorname` mit 'D' beginnt. Welcher Befehl ist am besten geeignet? üßê",
            "options": [
                "SELECT COUNT(vorname) FROM helden WHERE vorname LIKE 'D%';",
                "SELECT COUNT(*) FROM helden WHERE vorname LIKE 'D%';",
                "SELECT COUNT(*) FROM helden WHERE LEFT(vorname, 1) = 'D';",
                "SELECT COUNT(vorname) FROM helden WHERE vorname = 'D%';"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDie Abfrage `SELECT COUNT(*) FROM helden WHERE vorname LIKE 'D%';` ist die g√§ngigste und effizienteste Methode. Sie z√§hlt alle Datens√§tze, die nach dem `WHERE`-Filter √ºbrig bleiben. \n- **Option A** ist ebenfalls korrekt, aber `COUNT(*)` ist √ºblicherweise der bevorzugte Weg, da er potenziell schneller ist und die Anzahl der Zeilen z√§hlt, unabh√§ngig von `NULL`-Werten in der Spalte. \n- **Option C** verwendet eine Funktion (`LEFT()`), was die Abfrage unn√∂tig komplex macht. \n- **Option D** ist falsch, da der `=` Operator keine Wildcards ber√ºcksichtigt. üïµÔ∏è‚Äç‚ôÄÔ∏è",
            "difficulty": "fortgeschritten",
            "category": "Aggregat-Funktionen"
        },
        {
            "question": "Sie m√ºssen den Helden 'Digedag' l√∂schen, indem Sie seine `helden_id` verwenden. Wie lautet die sicherste Abfrage? üõ°Ô∏è",
            "options": [
                "DELETE FROM helden WHERE helden_id = 3;",
                "DELETE FROM helden WHERE vorname = 'Digedag';",
                "DELETE FROM helden WHERE helden_id > 2 AND helden_id < 4;",
                "DROP FROM helden WHERE helden_id = 3;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Verwendung des Prim√§rschl√ºssels (`helden_id`) ist die sicherste Methode, um einen bestimmten Datensatz zu l√∂schen. Ein Prim√§rschl√ºssel ist eindeutig, was garantiert, dass nur der beabsichtigte Datensatz gel√∂scht wird. \n- **Option B** birgt das Risiko, dass es mehrere Helden mit dem Vornamen 'Digedag' geben k√∂nnte, was zum unbeabsichtigten L√∂schen mehrerer Datens√§tze f√ºhren w√ºrde. \n- **Option C** ist funktional gleichwertig, aber unn√∂tig kompliziert. \n- **Option D** ist ein ung√ºltiger Befehl (`DROP` l√∂scht die gesamte Tabelle). üîí",
            "difficulty": "einsteiger",
            "category": "Datenmanipulation (DELETE)"
        },
        {
            "question": "Was ist der Hauptunterschied zwischen den Befehlen `DELETE FROM helden;` und `TRUNCATE TABLE helden;`? ü§î",
            "options": [
                "`DELETE` ist schneller und kann nicht r√ºckg√§ngig gemacht werden, w√§hrend `TRUNCATE` langsamer ist und gel√∂schte Datens√§tze wiederherstellt.",
                "`DELETE` l√∂scht Datens√§tze einzeln und ist Teil von DML, w√§hrend `TRUNCATE` die gesamte Tabelle leert, ist Teil von DDL und kann nicht r√ºckg√§ngig gemacht werden.",
                "`DELETE` kann nur bestimmte Datens√§tze l√∂schen, w√§hrend `TRUNCATE` immer alle Datens√§tze l√∂scht.",
                "`TRUNCATE` wird f√ºr die Tabellenstruktur verwendet, w√§hrend `DELETE` f√ºr die Datenmanipulation zust√§ndig ist."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\n`DELETE` ist ein DML-Befehl, der Datens√§tze einzeln l√∂scht, was langsamer sein kann. Die Aktion kann r√ºckg√§ngig gemacht werden, wenn sie in einer Transaktion ausgef√ºhrt wird. `TRUNCATE` hingegen ist ein DDL-Befehl, der die gesamte Tabelle leert, indem er die Datenbl√∂cke deallokiert. Dies ist extrem schnell, da die einzelnen Zeilen nicht gel√∂scht werden. Ein `TRUNCATE`-Befehl kann in der Regel nicht durch `ROLLBACK` r√ºckg√§ngig gemacht werden. \n- **Option A** ist falsch, da sie die Eigenschaften vertauscht. \n- **Option C** ist teilweise richtig, aber der Hauptunterschied liegt in der Art der Operation und der Zugeh√∂rigkeit zu DML/DDL. \n- **Option D** ist falsch, da beide Befehle Daten manipulieren. ü§Ø",
            "difficulty": "experte",
            "category": "DDL vs. DML"
        },
        {
            "question": "Sie sollen in der 'helden'-Tabelle den `nachname` aller Helden von 'Knoll' in 'Knuell' und das `land` von 'Sachsen' in 'Sachsen-Anhalt' √§ndern. Welcher Befehl ist korrekt? ‚úçÔ∏è",
            "options": [
                "UPDATE helden SET nachname = 'Knuell' AND land = 'Sachsen-Anhalt' WHERE nachname = 'Knoll';",
                "UPDATE helden SET nachname = 'Knuell', land = 'Sachsen-Anhalt' WHERE nachname = 'Knoll';",
                "UPDATE helden SET (nachname, land) = ('Knuell', 'Sachsen-Anhalt') WHERE nachname = 'Knoll';",
                "UPDATE helden SET nachname = 'Knuell', UPDATE helden SET land = 'Sachsen-Anhalt' WHERE nachname = 'Knoll';"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:**\nDer korrekte Weg, um mehrere Spalten in einer `UPDATE`-Abfrage zu √§ndern, ist die Trennung der Zuweisungen durch ein Komma (`SET spalte1 = wert1, spalte2 = wert2`). \n- **Option A** verwendet `AND`, was f√ºr logische Bedingungen in der `WHERE`-Klausel gedacht ist und hier einen Syntaxfehler verursacht. \n- **Option C** ist in einigen SQL-Dialekten (wie PostgreSQL) g√ºltig, aber nicht im Standard-SQL. \n- **Option D** verwendet zwei separate `UPDATE`-Befehle, was in einer einzelnen Anweisung nicht zul√§ssig ist. üîß",
            "difficulty": "fortgeschritten",
            "category": "Datenmanipulation (UPDATE)"
        },
        {
            "question": "Wahr oder Falsch? Der Befehl `SELECT * FROM helden WHERE gebjahr = 1955 OR gebjahr = 1953;` liefert dieselben Datens√§tze wie `SELECT * FROM helden WHERE gebjahr IN (1955, 1953);`. ‚úÖ",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDie Aussage ist wahr. Die Klausel `IN` ist eine Kurzform f√ºr mehrere `OR`-Bedingungen. Sie pr√ºft, ob ein Wert in einer angegebenen Liste von Werten enthalten ist. Beide Abfragen sind funktional identisch. Die Verwendung von `IN` ist jedoch bei einer gr√∂√üeren Anzahl von Werten oft √ºbersichtlicher und besser lesbar. ‚öñÔ∏è",
            "difficulty": "fortgeschritten",
            "category": "Filter-Operatoren"
        },
        {
            "question": "Um die `helden`-Tabelle nach dem `vorname` aufsteigend und dann nach dem `nachname` absteigend zu sortieren, welche Abfrage ist korrekt? üìú",
            "options": [
                "SELECT * FROM helden ORDER BY vorname ASC, nachname DESC;",
                "SELECT * FROM helden ORDER BY nachname DESC, vorname ASC;",
                "SELECT * FROM helden ORDER BY vorname, nachname DESC;",
                "SELECT * FROM helden SORT BY vorname, nachname DESC;"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:**\nDer korrekte Befehl ist `ORDER BY vorname ASC, nachname DESC;`. Die Sortierkriterien werden durch Kommas getrennt und in der gew√ºnschten Reihenfolge angegeben. Da `ASC` der Standard ist, kann es auch weggelassen werden, was Option C ebenfalls korrekt macht, aber Option A ist die explizitere Form. \n- **Option B** w√ºrde zuerst nach `nachname` und dann nach `vorname` sortieren, was der falschen Reihenfolge entspricht. \n- **Option D** verwendet einen ung√ºltigen Befehl. ‚û°Ô∏è",
            "difficulty": "fortgeschritten",
            "category": "Sortierung (ORDER BY)"
        },
        {
            "question": "Ein Entwickler stellt fest, dass eine Abfrage, die Kunden und ihre Bestellungen mittels `INNER JOIN` verbindet, nur Kunden anzeigt, die auch tats√§chlich Bestellungen haben. Welcher `JOIN`-Typ muss verwendet werden, um **alle** Kunden aufzulisten, auch die ohne Bestellungen? üßë‚Äçüíª",
            "options": [
                "RIGHT JOIN auf der Kundentabelle",
                "LEFT JOIN, wobei die Kundentabelle die linke (erste) Tabelle ist",
                "Einen zus√§tzlichen INNER JOIN mit einer Hilfstabelle",
                "CROSS JOIN, gefolgt von einer WHERE-Klausel"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Ein `LEFT JOIN` (oder `LEFT OUTER JOIN`) ist hier die korrekte Wahl. Er nimmt alle Datens√§tze aus der linken Tabelle (hier: `Kunden`) und f√ºgt die passenden Datens√§tze aus der rechten Tabelle (`Bestellungen`) hinzu. ‚ÜîÔ∏è Wenn f√ºr einen Kunden keine passende Bestellung gefunden wird, werden die Spalten der Bestellungstabelle mit `NULL`-Werten aufgef√ºllt. \n\n- **Option A** w√§re nur korrekt, wenn die Kundentabelle die *rechte* Tabelle im Join w√§re. \n- **Option C & D** sind unn√∂tig komplex und f√ºr dieses spezifische, h√§ufige Problem nicht die Standardl√∂sung.",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert (JOINs)"
        },
        {
            "question": "Sie m√∂chten eine neue Tabelle `Protokolle` erstellen, in der jeder Eintrag eine eindeutige, fortlaufende ID, eine Nachricht (bis zu 500 Zeichen) und einen exakten Zeitstempel der Erstellung haben soll. Welcher `CREATE TABLE`-Befehl ist daf√ºr am besten geeignet? ‚úçÔ∏è",
            "options": [
                "CREATE TABLE Protokolle(ID INTEGER, Nachricht CHAR(500), Erstellt DATE)",
                "CREATE TABLE Protokolle(ID INTEGER PRIMARY KEY, Nachricht VARCHAR(500), Erstellt TIMESTAMP)",
                "CREATE TABLE Protokolle(ID DECIMAL, Nachricht CHARACTER, Erstellt DATE)",
                "CREATE TABLE Protokolle(ID INTEGER, Nachricht VARCHAR, Erstellt TIMESTAMP)"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die korrekte Antwort nutzt die passendsten Datentypen. `ID INTEGER PRIMARY KEY` stellt sicher, dass die ID eindeutig und nicht `NULL` ist. `VARCHAR(500)` ist f√ºr die Nachricht ideal, da es Speicherplatz spart, indem es nur die tats√§chlich ben√∂tigte L√§nge belegt (im Gegensatz zu `CHAR(500)`). `TIMESTAMP` (obwohl nicht explizit in der Liste, ist es eine Standarderweiterung von `DATE` und `NOW()`) speichert Datum und Uhrzeit, was f√ºr einen Zeitstempel erforderlich ist. `NOW()` liefert beides. \n\n- **Option A** ist ineffizient, da `CHAR(500)` immer 500 Zeichen belegt und `DATE` keine Uhrzeit speichert. \n- **Option C** verwendet unpassende Datentypen. \n- **Option D** definiert keinen Prim√§rschl√ºssel, was f√ºr eine ID-Spalte kritisch ist.",
            "difficulty": "einsteiger",
            "category": "DDL & Datentypen"
        },
        {
            "question": "Ein Datenanalyst m√∂chte den durchschnittlichen Bestellwert pro Kunde f√ºr das vergangene Jahr berechnen, aber nur f√ºr Kunden, die insgesamt mehr als 1.000 ‚Ç¨ Umsatz generiert haben. Welche Klauseln werden zwingend ben√∂tigt, um diese Anforderung zu erf√ºllen? üìà",
            "options": [
                "AVG(), GROUP BY, WHERE",
                "SUM(), GROUP BY, WHERE",
                "AVG(), GROUP BY, HAVING",
                "MIN(), MAX(), ORDER BY"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Dies ist ein klassischer Anwendungsfall f√ºr `GROUP BY` und `HAVING`. \n1. `AVG()` wird ben√∂tigt, um den Durchschnittswert zu berechnen. \n2. `GROUP BY Kunde` fasst die Bestellungen pro Kunde zusammen. \n3. Die Bedingung \"mehr als 1.000 ‚Ç¨ Umsatz\" bezieht sich auf das Ergebnis einer Aggregatfunktion (`SUM(Umsatz)`). Solche Bedingungen k√∂nnen nicht in der `WHERE`-Klausel stehen, sondern m√ºssen in der `HAVING`-Klausel platziert werden. ‚úÖ\n\n- **Option A & B** sind falsch, weil `WHERE` nicht auf aggregierte Ergebnisse filtern kann. `WHERE` filtert Zeilen *vor* der Gruppierung.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse (WHERE vs. HAVING)"
        },
        {
            "question": "Wahr oder Falsch: Der Befehl `DELETE FROM Mitarbeiter` hat denselben Effekt wie `DROP TABLE Mitarbeiter`. üö´",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. `DELETE FROM Mitarbeiter` l√∂scht alle **Daten (Zeilen)** in der Tabelle. Die Tabellenstruktur selbst (Spalten, Datentypen, Indizes) bleibt erhalten und die Tabelle kann sofort wieder mit neuen Daten gef√ºllt werden. üóëÔ∏è `DROP TABLE Mitarbeiter` l√∂scht die gesamte Tabelle, einschlie√ülich ihrer Struktur und aller zugeh√∂rigen Objekte. Die Tabelle existiert danach nicht mehr und m√ºsste komplett neu erstellt werden. üî•",
            "difficulty": "einsteiger",
            "category": "Wahr/Falsch (DML vs. DDL)"
        },
        {
            "question": "Ein Projektmanager m√∂chte alle Aufgaben sehen, deren F√§lligkeitsdatum innerhalb der n√§chsten 7 Tage liegt. Das F√§lligkeitsdatum ist in der Spalte `faelligkeit` vom Typ `DATE` gespeichert. Welcher `WHERE`-Filter ist daf√ºr korrekt? üóìÔ∏è",
            "options": [
                "WHERE DATEDIFF('DAY', NOW(), faelligkeit) BETWEEN 0 AND 7",
                "WHERE DATEADD('DAY', 7, faelligkeit) > NOW()",
                "WHERE faelligkeit = NOW() + 7",
                "WHERE DATEDIFF('YEAR', NOW(), faelligkeit) < 7"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die Funktion `DATEDIFF('DAY', Anfangsdatum, Enddatum)` berechnet die Differenz zwischen zwei Daten in Tagen. Die Bedingung `BETWEEN 0 AND 7` w√§hlt alle Aufgaben aus, deren F√§lligkeit heute (Differenz 0) oder in den n√§chsten 7 Tagen liegt. üéØ\n\n- **Option B** ist logisch fehlerhaft. \n- **Option C** verwendet eine ung√ºltige Syntax zur Datumsaddition. \n- **Option D** w√ºrde die Differenz in Jahren berechnen, was f√ºr diese Anforderung falsch ist.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgabe (Datumsfunktionen)"
        },
        {
            "question": "Ein DBA m√∂chte einem neuen Benutzer `readonly` Lesezugriff auf **alle** Tabellen in der Datenbank `CompanyDB` geben, aber keine Schreibrechte. Welcher Befehl ist der richtige? üîê",
            "options": [
                "GRANT SELECT ON CompanyDB.* TO 'readonly'",
                "GRANT ALL ON CompanyDB.* TO 'readonly'",
                "UPDATE USER 'readonly' SET PERMISSION = READ ON CompanyDB",
                "REVOKE WRITE ON CompanyDB.* FROM 'readonly'"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Der `GRANT`-Befehl wird verwendet, um Berechtigungen zu erteilen. `GRANT SELECT` gibt explizit nur die Leseberechtigung. `ON CompanyDB.*` wendet diese Berechtigung auf alle Objekte (Tabellen, Views etc.) innerhalb der angegebenen Datenbank an. `TO 'readonly'` spezifiziert den Empf√§nger der Berechtigung. üë§\n\n- **Option B** w√ºrde alle Rechte (`ALL`) vergeben, einschlie√ülich Schreibrechten. \n- **Option C** ist syntaktisch falsch. \n- **Option D** entzieht Rechte, anstatt sie zu gew√§hren.",
            "difficulty": "einsteiger",
            "category": "DCL (Berechtigungen)"
        },
        {
            "question": "Was ist der Hauptunterschied zwischen den Datentypen `CHAR(10)` und `VARCHAR(10)` in Bezug auf die Speicherung der Zeichenkette 'SQL'? üíæ",
            "options": [
                "Beide belegen 10 Bytes auf der Festplatte.",
                "CHAR(10) belegt 10 Bytes, w√§hrend VARCHAR(10) nur 4 Bytes belegt (3 f√ºr 'SQL' + 1 f√ºr die L√§ngeninformation).",
                "VARCHAR(10) ist immer schneller im Zugriff als CHAR(10).",
                "Es gibt keinen Unterschied in der Speicherung."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `CHAR` steht f√ºr eine Zeichenkette mit **fester L√§nge**. `CHAR(10)` reserviert immer 10 Bytes, auch wenn weniger Zeichen gespeichert werden. Leerer Platz wird mit Leerzeichen aufgef√ºllt. `VARCHAR` steht f√ºr eine Zeichenkette mit **variabler L√§nge**. `VARCHAR(10)` speichert nur die tats√§chlichen Zeichen plus einen kleinen Overhead (typischerweise 1-2 Bytes) zur Speicherung der L√§nge. Das macht `VARCHAR` speichereffizienter f√ºr Daten mit variierender L√§nge. üìè\n\n- **Option A & D** sind falsch. \n- **Option C** ist eine Verallgemeinerung, die nicht immer zutrifft. Bei fester Datenl√§nge kann `CHAR` sogar performanter sein.",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse (Datentypen)"
        },
        {
            "question": "Sie m√ºssen eine Liste aller Mitarbeiter erstellen, deren Nachname mit 'M' beginnt und auf 'r' endet. Welcher `WHERE`-Bedingung ist korrekt? üîç",
            "options": [
                "WHERE Nachname LIKE 'M_r'",
                "WHERE Nachname LIKE 'M%r'",
                "WHERE Nachname = 'M*r'",
                "WHERE LEFT(Nachname, 1) = 'M' AND RIGHT(Nachname, 1) = 'r'"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `LIKE`-Operator wird f√ºr Mustervergleiche in Zeichenketten verwendet. Das Prozentzeichen `%` ist ein Platzhalter f√ºr eine beliebige Anzahl (auch null) von Zeichen. `M%r` passt also auf 'Meyer', 'Maurer', 'Miller' usw. \n\n- **Option A** mit dem Unterstrich `_` w√ºrde nur auf Nachnamen mit genau drei Buchstaben passen, wie 'M√§r'. \n- **Option C** verwendet einen falschen Platzhalter. \n- **Option D** ist zwar logisch korrekt, aber umst√§ndlicher und oft weniger performant als der daf√ºr optimierte `LIKE`-Operator.",
            "difficulty": "einsteiger",
            "category": "Operatoren (LIKE)"
        },
        {
            "question": "Gegeben sei die Abfrage: `SELECT COUNT(ManagerID) FROM Mitarbeiter;`. Wenn es 100 Mitarbeiter gibt, aber 5 davon keinen Manager zugeordnet haben (ManagerID ist `NULL`), was ist das Ergebnis der Abfrage? üî¢",
            "options": [
                "100",
                "95",
                "Ein Fehler, da NULL-Werte nicht gez√§hlt werden k√∂nnen.",
                "0"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die Aggregatfunktion `COUNT(Spaltenname)` z√§hlt die Anzahl der Zeilen, in denen die angegebene Spalte einen **Nicht-NULL-Wert** hat. Da 5 Mitarbeiter eine `NULL` in der `ManagerID`-Spalte haben, werden diese nicht mitgez√§hlt. 100 - 5 = 95. \n\nWichtiger Hinweis: `COUNT(*)` hingegen w√ºrde alle Zeilen z√§hlen, unabh√§ngig von `NULL`-Werten, und somit 100 zur√ºckgeben. ‚ú®",
            "difficulty": "fortgeschritten",
            "category": "Logisches R√§tsel (Aggregatfunktionen)"
        },
        {
            "question": "Ein neuer Praktikant soll der Tabelle `Produkte` hinzugef√ºgt werden. Er soll die `ProductID` 101, den Namen 'Monitor' und den Preis 299.99 haben. Welcher `INSERT`-Befehl ist syntaktisch korrekt? ‚ûï",
            "options": [
                "INSERT (101, 'Monitor', 299.99) INTO Produkte",
                "INSERT INTO Produkte VALUES (101, 'Monitor', 299.99)",
                "UPDATE Produkte SET VALUES = (101, 'Monitor', 299.99)",
                "INSERT INTO Produkte (ProductID, Name, Preis) ADD (101, 'Monitor', 299.99)"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die grundlegende Syntax zum Einf√ºgen einer vollst√§ndigen Zeile lautet `INSERT INTO Tabellenname VALUES (Wert1, Wert2, ...)` . Die Werte m√ºssen in der korrekten Reihenfolge der Spalten der Tabelle angegeben werden. ‚úÖ\n\n- **Option A** hat die `VALUES`-Klausel vergessen und die Klammern falsch gesetzt. \n- **Option C** verwechselt `UPDATE` (zum √Ñndern bestehender Daten) mit `INSERT`. \n- **Option D** verwendet eine ung√ºltige `ADD`-Klausel.",
            "difficulty": "einsteiger",
            "category": "DML (INSERT)"
        },
        {
            "question": "Wahr oder Falsch: Eine Unterabfrage (Subquery) in der `FROM`-Klausel muss immer einen Alias (z.B. `AS tbl`) erhalten. üí°",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Wahr. Wenn eine Unterabfrage in der `FROM`-Klausel verwendet wird, erzeugt sie eine tempor√§re, abgeleitete Tabelle im Speicher. Damit die √§u√üere Abfrage auf die Spalten dieser tempor√§ren Tabelle zugreifen kann, muss sie einen Namen (Alias) bekommen. Ohne diesen Alias kann das SQL-System die Spalten nicht eindeutig zuordnen, was zu einem Syntaxfehler f√ºhrt. üè∑Ô∏è",
            "difficulty": "experte",
            "category": "Wahr/Falsch (Subqueries)"
        },
        {
            "question": "Sie m√ºssen eine Spalte `Status` mit dem Standardwert 'aktiv' zur bestehenden Tabelle `Kunden` hinzuf√ºgen. Die Spalte soll maximal 20 Zeichen lang sein. Welcher `ALTER TABLE`-Befehl ist korrekt? üõ†Ô∏è",
            "options": [
                "ALTER TABLE Kunden MODIFY COLUMN Status VARCHAR(20) DEFAULT 'aktiv'",
                "ALTER TABLE Kunden ADD COLUMN Status VARCHAR(20) DEFAULT 'aktiv'",
                "ALTER TABLE Kunden ADD Status CHAR(20) IS 'aktiv'",
                "MODIFY TABLE Kunden ADD Status VARCHAR(20) = 'aktiv'"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der Befehl zum Hinzuf√ºgen einer neuen Spalte zu einer bestehenden Tabelle lautet `ALTER TABLE Tabellenname ADD COLUMN ...`. Die Definition der Spalte `Status VARCHAR(20) DEFAULT 'aktiv'` ist ebenfalls korrekt. ‚úÖ\n\n- **Option A** (`MODIFY COLUMN`) wird verwendet, um eine *bestehende* Spalte zu √§ndern, nicht um eine neue hinzuzuf√ºgen. \n- **Option C & D** verwenden eine falsche Syntax f√ºr das Hinzuf√ºgen von Spalten und das Setzen von Standardwerten.",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert (DDL)"
        },
        {
            "question": "Sie haben zwei Tabellen: `A(id)` mit den Werten (1, 2, 3) und `B(id)` mit den Werten (2, 3, 4). Was ist das Ergebnis von `SELECT id FROM A UNION SELECT id FROM B`? üîÑ",
            "options": [
                "(1, 2, 3, 2, 3, 4)",
                "(2, 3)",
                "(1, 2, 3, 4)",
                "Ein Syntaxfehler"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Der `UNION`-Operator kombiniert die Ergebnisse von zwei oder mehr `SELECT`-Anweisungen und entfernt dabei automatisch **Duplikate**. Die Ergebnismenge enth√§lt also jeden Wert aus beiden Abfragen nur einmal. Die kombinierten Werte sind 1, 2, 3, 2, 3, 4. Nach Entfernung der Duplikate (2 und 3) bleibt (1, 2, 3, 4) √ºbrig. üóëÔ∏è\n\nHinweis: Um Duplikate beizubehalten, m√ºsste man `UNION ALL` verwenden.",
            "difficulty": "fortgeschritten",
            "category": "Logisches R√§tsel (Operatoren)"
        },
        {
            "question": "Ein Manager m√∂chte die 5 umsatzst√§rksten Produkte des aktuellen Monats sehen. Welche Kombination von Klauseln ist in der korrekten Reihenfolge erforderlich? üèÜ",
            "options": [
                "WHERE, GROUP BY, ORDER BY, LIMIT 5",
                "GROUP BY, WHERE, ORDER BY, LIMIT 5",
                "WHERE, ORDER BY, GROUP BY, LIMIT 5",
                "LIMIT 5, WHERE, GROUP BY, ORDER BY"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die logische Verarbeitungsreihenfolge in SQL ist entscheidend. \n1. `WHERE`: Zuerst werden die Zeilen auf den aktuellen Monat gefiltert. \n2. `GROUP BY`: Dann werden die Daten nach Produkt gruppiert, um den Umsatz zu summieren. \n3. `ORDER BY ... DESC`: Die gruppierten Ergebnisse werden absteigend nach dem Umsatz sortiert. \n4. `LIMIT 5` (nicht im Dokument, aber Standard-SQL): Schlie√ülich wird die Ausgabe auf die ersten 5 Zeilen beschr√§nkt. \nDiese Reihenfolge stellt sicher, dass die Operationen in der richtigen logischen Abfolge ausgef√ºhrt werden. üî¢",
            "difficulty": "experte",
            "category": "Szenario-basiert (Klausel-Reihenfolge)"
        },
        {
            "question": "Welche Funktion extrahiert die Jahreszahl aus einem `DATE`-Feld namens `Bestelldatum`? üìÖ",
            "options": [
                "GETYEAR(Bestelldatum)",
                "DATEPART('year', Bestelldatum)",
                "YEAR(Bestelldatum)",
                "NOW(Bestelldatum, 'YYYY')"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die Funktion `YEAR(DatumZeit)` ist gem√§√ü der bereitgestellten Syntax die korrekte Funktion, um das Jahr aus einer Zeitangabe als Zahl zu extrahieren. Sie ist einfach und direkt. ‚úÖ\n\n- **Option A und D** sind keine Standard-SQL-Funktionen aus dem Dokument. \n- **Option B** (`DATEPART`) ist eine g√ºltige Funktion in einigen SQL-Dialekten (z.B. T-SQL), aber `YEAR()` ist die im Dokument angegebene und weit verbreitete Funktion.",
            "difficulty": "einsteiger",
            "category": "Funktionen (Datum)"
        },
        {
            "question": "Einem Junior-Entwickler wurde die Aufgabe gegeben, den Preis aller Produkte der Kategorie 'Software' um 10% zu erh√∂hen. Welches Statement ist daf√ºr korrekt? üí∏",
            "options": [
                "UPDATE Produkte SET Preis = Preis * 1.10 WHERE Kategorie = 'Software'",
                "INSERT INTO Produkte (Preis) VALUES (Preis * 1.10) WHERE Kategorie = 'Software'",
                "MODIFY Produkte SET Preis = Preis * 1.10 WHERE Kategorie = 'Software'",
                "SELECT Preis * 1.10 FROM Produkte WHERE Kategorie = 'Software'"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Der `UPDATE`-Befehl wird verwendet, um bestehende Datens√§tze zu √§ndern. `UPDATE Produkte` legt die Tabelle fest. `SET Preis = Preis * 1.10` definiert die Aktualisierungslogik. Die `WHERE`-Klausel stellt sicher, dass nur die Datens√§tze der richtigen Kategorie betroffen sind. üéØ\n\n- **Option B** w√ºrde versuchen, neue Datens√§tze einzuf√ºgen. \n- **Option C** ist syntaktisch falsch. \n- **Option D** w√ºrde die neuen Preise nur anzeigen (selektieren), aber nicht in der Datenbank speichern.",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert (DML)"
        },
        {
            "question": "Was ist der entscheidende Unterschied zwischen `COUNT(*)` und `COUNT(DISTINCT Spalte)`? üßê",
            "options": [
                "`COUNT(*)` ist schneller, liefert aber das gleiche Ergebnis.",
                "`COUNT(*)` z√§hlt alle Zeilen, w√§hrend `COUNT(DISTINCT Spalte)` nur die Anzahl der einzigartigen Werte in der Spalte z√§hlt.",
                "`COUNT(DISTINCT Spalte)` z√§hlt auch `NULL`-Werte als einen einzigartigen Wert.",
                "Es gibt keinen funktionalen Unterschied, nur einen syntaktischen."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `COUNT(*)` ist ein einfacher Zeilenz√§hler und z√§hlt alle Zeilen, die von der Abfrage zur√ºckgegeben werden. `DISTINCT` ist ein Schl√ºsselwort, das vor dem Spaltennamen platziert wird, um die Aggregatfunktion anzuweisen, nur einzigartige (nicht doppelte) Werte in dieser Spalte zu ber√ºcksichtigen. Wenn eine Spalte `Status` die Werte ('Neu', 'Offen', 'Neu', 'Geschlossen', 'Offen') enth√§lt, w√ºrde `COUNT(Status)` 5 zur√ºckgeben, aber `COUNT(DISTINCT Status)` w√ºrde 3 zur√ºckgeben. üî¢",
            "difficulty": "fortgeschritten",
            "category": "Vergleichende Analyse (Aggregatfunktionen)"
        },
        {
            "question": "Sie m√ºssen eine Fremdschl√ºsselbeziehung erstellen. Die Spalte `KundenID` in der Tabelle `Bestellungen` soll auf die Spalte `ID` in der Tabelle `Kunden` verweisen. Welcher Syntax-Ausschnitt ist korrekt? üîó",
            "options": [
                "FOREIGN KEY (KundenID) REFERENCES Kunden(ID)",
                "PRIMARY KEY (KundenID) REFERENCES Kunden(ID)",
                "REFERENCES Kunden(ID) ON Bestellungen(KundenID)",
                "FOREIGN KEY (ID) REFERENCES Bestellungen(KundenID)"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Die Syntax zur Definition eines Fremdschl√ºssels lautet `FOREIGN KEY (Spalte_in_dieser_Tabelle) REFERENCES Andere_Tabelle(Prim√§rschl√ºsselspalte_dort)`. Diese Zeile wird typischerweise innerhalb eines `CREATE TABLE` oder `ALTER TABLE` Befehls verwendet. Sie stellt die referentielle Integrit√§t sicher. ‚úÖ\n\n- Die anderen Optionen verdrehen die Schl√ºsselw√∂rter, die Tabellen oder die Spalten und sind syntaktisch falsch.",
            "difficulty": "einsteiger",
            "category": "Schl√ºssel (DDL)"
        },
        {
            "question": "Einem Analysten liegt eine Tabelle `Gehaelter` vor. Er soll die Standardabweichung der Geh√§lter berechnen. Welche Funktion muss er verwenden? üìä",
            "options": [
                "AVG(Gehalt) - MIN(Gehalt)",
                "VARIANCE(Gehalt)",
                "CORR(Gehalt, Alter)",
                "STDDEV(Gehalt)"
            ],
            "correct": 3,
            "explain": "**Begr√ºndung:** Die Funktion `STDDEV(Spaltenname)` ist die Standard-SQL-Funktion zur Berechnung der Standardabweichung, einem Ma√ü f√ºr die Streuung der Werte um den Mittelwert. üìà\n\n- **Option A** ist eine manuelle Berechnung, die nicht der Standardabweichung entspricht. \n- **Option B** (`VARIANCE`) berechnet die Varianz, welche das Quadrat der Standardabweichung ist. \n- **Option C** (`CORR`) berechnet die Korrelation zwischen zwei Variablen, nicht die Streuung einer einzelnen.",
            "difficulty": "fortgeschritten",
            "category": "Berechnungsaufgabe (Aggregatfunktionen)"
        },
        {
            "question": "Wahr oder Falsch: Die Klausel `ORDER BY` wird immer **vor** der `GROUP BY`-Klausel ausgef√ºhrt. ‚è©",
            "options": [
                "Wahr",
                "Falsch"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Falsch. In der logischen Verarbeitungsreihenfolge einer SQL-Abfrage wird die `GROUP BY`-Klausel ausgef√ºhrt, um die Zeilen zu Aggregaten zusammenzufassen. Erst **danach** wird die `ORDER BY`-Klausel angewendet, um diese aggregierten Gruppen zu sortieren. Man kann nicht etwas sortieren, das noch nicht gruppiert wurde. Die Reihenfolge im Code ist auch typischerweise `GROUP BY ... ORDER BY`. üî¢",
            "difficulty": "experte",
            "category": "Wahr/Falsch (Klausel-Reihenfolge)"
        },
        {
            "question": "Sie m√∂chten alle Produkte finden, die **nicht** in der Tabelle `Sonderangebote` aufgef√ºhrt sind. Welche der folgenden Abfragen l√∂st diese Aufgabe am effizientesten? üïµÔ∏è",
            "options": [
                "SELECT Name FROM Produkte WHERE ID NOT IN (SELECT ProduktID FROM Sonderangebote)",
                "SELECT Name FROM Produkte WHERE Name LIKE (SELECT Name FROM Sonderangebote)",
                "SELECT Name FROM Produkte INNER JOIN Sonderangebote ON Produkte.ID = Sonderangebote.ProduktID",
                "SELECT Name FROM Produkte WHERE ID IN (SELECT ProduktID FROM Sonderangebote)"
            ],
            "correct": 0,
            "explain": "**Begr√ºndung:** Der `NOT IN`-Operator ist ideal, um eine Liste von Werten auszuschlie√üen. Die Subquery `(SELECT ProduktID FROM Sonderangebote)` erstellt eine Liste aller Angebots-IDs. Die √§u√üere Abfrage w√§hlt dann alle Produkte aus, deren `ID` nicht in dieser Liste vorkommt. Alternativ w√§re auch ein `LEFT JOIN ... WHERE Sonderangebote.ProduktID IS NULL` eine sehr performante L√∂sung. üìâ\n\n- **Option B** ist syntaktisch falsch. \n- **Option C** w√ºrde nur Produkte finden, die ein Sonderangebot sind. \n- **Option D** w√ºrde das genaue Gegenteil tun und nur die Sonderangebot-Produkte auflisten.",
            "difficulty": "experte",
            "category": "Logisches R√§tsel (Subqueries)"
        },
        {
            "question": "Ein Datenbankadministrator muss alle Berechtigungen f√ºr den Benutzer `ex_mitarbeiter` auf die Datenbank `ProjekteDB` widerrufen. Welcher Befehl ist korrekt? üîí",
            "options": [
                "DELETE USER 'ex_mitarbeiter' FROM ProjekteDB",
                "REVOKE ALL ON ProjekteDB.* FROM 'ex_mitarbeiter'",
                "GRANT NONE ON ProjekteDB.* TO 'ex_mitarbeiter'",
                "UPDATE PERMISSIONS SET NONE WHERE USER = 'ex_mitarbeiter'"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** `REVOKE` ist der Befehl zum Entziehen von Berechtigungen. `ALL` spezifiziert, dass alle Berechtigungen (SELECT, INSERT, UPDATE etc.) entzogen werden sollen. `ON ProjekteDB.*` definiert den Geltungsbereich, und `FROM 'ex_mitarbeiter'` gibt den Benutzer an, dem die Rechte entzogen werden. üö´\n\n- Die anderen Optionen verwenden eine ung√ºltige SQL-Syntax f√ºr die Berechtigungsverwaltung.",
            "difficulty": "fortgeschritten",
            "category": "DCL (Berechtigungen)"
        },
        {
            "question": "Was ist das Ergebnis der Funktion `LEFT('Datenbank', 4)`? ‚úÇÔ∏è",
            "options": [
                "bank",
                "aten",
                "Daten",
                "Ein Fehler, da die Funktion RIGHT hei√üt"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die Funktion `LEFT(Zeichenkette, Anzahlzeichen)` extrahiert eine bestimmte Anzahl von Zeichen vom **linken** Anfang einer Zeichenkette. `LEFT('Datenbank', 4)` nimmt also die ersten 4 Zeichen, was 'Daten' ergibt. ‚úÖ",
            "difficulty": "einsteiger",
            "category": "Funktionen (String)"
        },
        {
            "question": "Vergleichen Sie `DELETE`, `TRUNCATE` und `DROP`. Welche Aussage beschreibt den Unterschied am besten? üí•",
            "options": [
                "`DELETE` ist am schnellsten, `DROP` am langsamsten.",
                "`DELETE` l√∂scht Zeilen einzeln (langsam, kann r√ºckg√§ngig gemacht werden), `TRUNCATE` l√∂scht alle Zeilen auf einmal (schnell, nicht r√ºckg√§ngig), `DROP` l√∂scht die ganze Tabelle.",
                "`DROP` und `TRUNCATE` sind Synonyme, `DELETE` ist anders.",
                "`DELETE` entfernt die Tabelle, `TRUNCATE` leert sie, `DROP` l√∂scht die Datenbank."
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Diese drei Befehle haben unterschiedliche Auswirkungen und Anwendungsf√§lle: \n- **DELETE:** DML-Befehl. L√∂scht Zeilen basierend auf einer `WHERE`-Klausel (oder alle, wenn keine da ist). Jede L√∂schung wird protokolliert, daher ist es langsamer und kann oft via Transaktion zur√ºckgerollt werden. \n- **TRUNCATE:** DDL-Befehl. Entfernt alle Zeilen aus einer Tabelle, indem die Speicherseiten dealloziert werden. Es wird nichts protokolliert, daher ist es extrem schnell, kann aber nicht zur√ºckgerollt werden. Setzt Auto-Inkrement-Z√§hler zur√ºck. \n- **DROP:** DDL-Befehl. L√∂scht die gesamte Tabellenstruktur und alle Daten unwiderruflich. üî•",
            "difficulty": "experte",
            "category": "Vergleichende Analyse (DML/DDL)"
        },
        {
            "question": "Sie m√ºssen eine Abfrage erstellen, die pr√ºft, ob f√ºr einen Kunden √ºberhaupt Bestellungen existieren, ohne die Bestelldaten selbst zu laden. Welcher Operator ist daf√ºr am performantesten? üí®",
            "options": [
                "WHERE (SELECT COUNT(*) FROM Bestellungen WHERE KundenID = K.ID) > 0",
                "WHERE EXISTS (SELECT 1 FROM Bestellungen WHERE KundenID = K.ID)",
                "INNER JOIN Bestellungen ON Bestellungen.KundenID = K.ID",
                "WHERE K.ID IN (SELECT KundenID FROM Bestellungen)"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Der `EXISTS`-Operator ist f√ºr genau diesen Zweck optimiert. Er pr√ºft nur auf die **Existenz** von mindestens einer Zeile in der Subquery, die die Bedingung erf√ºllt. Sobald die erste passende Zeile gefunden ist, bricht die Subquery die Ausf√ºhrung ab und gibt `TRUE` zur√ºck. Dies ist deutlich performanter als `COUNT(*)`, welches alle passenden Zeilen z√§hlen m√ºsste, oder `IN`, welches die gesamte Liste der IDs im Speicher aufbauen muss. ‚úÖ",
            "difficulty": "experte",
            "category": "Logisches R√§tsel (Performance)"
        },
        {
            "question": "Wie lautet die korrekte `UPDATE`-Anweisung, um bei allen Mitarbeitern in der Abteilung 'IT' das Gehalt um 500 zu erh√∂hen und die Spalte `LetzteAenderung` auf das aktuelle Datum zu setzen? ‚úçÔ∏è",
            "options": [
                "UPDATE Mitarbeiter SET Gehalt = Gehalt + 500 AND LetzteAenderung = NOW() WHERE Abteilung = 'IT'",
                "UPDATE Mitarbeiter SET Gehalt = Gehalt + 500, LetzteAenderung = NOW() WHERE Abteilung = 'IT'",
                "UPDATE Mitarbeiter SET Gehalt += 500, LetzteAenderung = NOW() WHERE Abteilung = 'IT'",
                "MODIFY Mitarbeiter SET Gehalt = Gehalt + 500, LetzteAenderung = NOW() WHERE Abteilung = 'IT'"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** In einer `UPDATE`-Anweisung werden mehrere Spaltenzuweisungen in der `SET`-Klausel durch ein **Komma (,)** voneinander getrennt. Die `WHERE`-Klausel filtert dann die zu aktualisierenden Zeilen. \n\n- **Option A** verwendet `AND`, was in der `SET`-Klausel syntaktisch falsch ist. `AND` wird in der `WHERE`-Klausel zur Verkn√ºpfung von Bedingungen verwendet. \n- **Option C** verwendet den `+=` Operator, der in Standard-SQL nicht f√ºr Zuweisungen existiert. \n- **Option D** verwendet das falsche Schl√ºsselwort `MODIFY`.",
            "difficulty": "fortgeschritten",
            "category": "Szenario-basiert (DML)"
        },
        {
            "question": "Ein Auszubildender soll eine Liste aller eindeutigen St√§dtenamen aus der Kundentabelle erstellen, absteigend sortiert. Welcher Befehl ist korrekt? üèôÔ∏è",
            "options": [
                "SELECT Stadt FROM Kunden ORDER BY Stadt DESC",
                "SELECT DISTINCT Stadt FROM Kunden GROUP BY Stadt DESC",
                "SELECT DISTINCT Stadt FROM Kunden ORDER BY Stadt DESC",
                "SELECT UNIQUE Stadt FROM Kunden SORT BY Stadt DESC"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** `SELECT DISTINCT Stadt` w√§hlt jeden eindeutigen St√§dtenamen genau einmal aus. `FROM Kunden` spezifiziert die Tabelle. `ORDER BY Stadt DESC` sortiert diese eindeutige Liste dann in absteigender alphabetischer Reihenfolge (Z-A). ‚úÖ\n\n- **Option A** w√ºrde alle St√§dtenamen auflisten, auch Duplikate. \n- **Option B und D** verwenden eine falsche Syntax (`GROUP BY DESC` / `UNIQUE`, `SORT BY`).",
            "difficulty": "einsteiger",
            "category": "DQL (SELECT)"
        },
        {
            "question": "Welche Aggregatfunktion w√ºrde man verwenden, um die Korrelation zwischen dem Alter eines Kunden und seinem Jahresumsatz zu berechnen? ü§ù",
            "options": [
                "SUM(Alter, Jahresumsatz)",
                "AVG(Alter) / AVG(Jahresumsatz)",
                "CORR(Alter, Jahresumsatz)",
                "STDDEV(Alter, Jahresumsatz)"
            ],
            "correct": 2,
            "explain": "**Begr√ºndung:** Die Funktion `CORR(Spaltenname_1, Spaltenname_2)` ist speziell daf√ºr vorgesehen, den Korrelationskoeffizienten zwischen zwei numerischen Merkmalen zu berechnen. Das Ergebnis liegt zwischen -1 (perfekte negative Korrelation) und +1 (perfekte positive Korrelation), wobei 0 keinen linearen Zusammenhang anzeigt. üìà",
            "difficulty": "fortgeschritten",
            "category": "Aggregatfunktionen"
        },
        {
            "question": "Sie haben eine Tabelle `Logins` mit einer Spalte `LoginZeit` vom Typ `DATETIME`. Wie viele erfolgreiche Logins gab es am heutigen Wochentag (z.B. alle Montage, wenn heute Montag ist)? üóìÔ∏è",
            "options": [
                "SELECT COUNT(*) FROM Logins WHERE DAY(LoginZeit) = DAY(NOW())",
                "SELECT COUNT(*) FROM Logins WHERE WEEKDAY(LoginZeit) = WEEKDAY(NOW())",
                "SELECT COUNT(*) FROM Logins WHERE DATEADD('DAY', 0, LoginZeit)",
                "SELECT COUNT(*) FROM Logins WHERE MONTH(LoginZeit) = MONTH(NOW())"
            ],
            "correct": 1,
            "explain": "**Begr√ºndung:** Die Funktion `WEEKDAY(DatumZeit)` gibt den Wochentag als Zahl zur√ºck (z.B. Montag = 0, Dienstag = 1, ...). Indem man den Wochentag jedes Login-Datums mit dem Wochentag des aktuellen Datums (`NOW()`) vergleicht, filtert man alle Eintr√§ge heraus, die am selben Wochentag stattfanden, unabh√§ngig vom genauen Datum. üéØ\n\n- **Option A** w√ºrde alle Logins vom selben *Tag des Monats* (z.B. der 26.) z√§hlen. \n- **Option C** ist syntaktisch unvollst√§ndig. \n- **Option D** w√ºrde nach dem Monat filtern.",
            "difficulty": "experte",
            "category": "Berechnungsaufgabe (Datumsfunktionen)"
        },
        {
            "question": "Ein Entwickler m√∂chte sicherstellen, dass eine Spalte `Email` in der Tabelle `Benutzer` immer einen Wert enthalten muss. Welches Schl√ºsselwort muss er bei der Spaltendefinition hinzuf√ºgen? üìß",
            "options": [
                "IS NOT NULL",
                "UNIQUE",
                "PRIMARY KEY",
                "NOT NULL"
            ],
            "correct": 3,
            "explain": "**Begr√ºndung:** Das Constraint `NOT NULL` wird bei der Definition einer Spalte (`CREATE TABLE` oder `ALTER TABLE`) hinzugef√ºgt, um zu erzwingen, dass diese Spalte bei jedem `INSERT` oder `UPDATE` einen Wert haben muss. Ein Versuch, eine Zeile mit einem `NULL`-Wert in dieser Spalte einzuf√ºgen, w√ºrde zu einem Fehler f√ºhren. ‚úÖ\n\n- **IS NOT NULL** ist ein Operator, der in `WHERE`-Klauseln verwendet wird, aber nicht zur Definition von Spalten-Constraints. \n- **UNIQUE** stellt sicher, dass jeder Wert in der Spalte einzigartig ist, erlaubt aber (oft) einen `NULL`-Wert. \n- **PRIMARY KEY** impliziert `NOT NULL` und `UNIQUE`, ist aber f√ºr den prim√§ren Identifikator der Tabelle reserviert.",
            "difficulty": "einsteiger",
            "category": "DDL (Constraints)"
        }
    ]
}