[Previous content remains the same up until updateUI function...]

    // Quiz functionality with improved error handling
    function toggleTheme() {
        try {
            darkMode = !darkMode;
            document.body.setAttribute('data-theme', darkMode ? 'dark' : 'light');
            localStorage.setItem('darkMode', darkMode);
        } catch (error) {
            console.error('Error toggling theme:', error);
        }
    }

    async function initializeQuizCategories() {
        try {
            const categoriesContainer = document.getElementById('quiz-categories');
            if (!categoriesContainer) return;
            
            categoriesContainer.innerHTML = quizCategories.map(category => `
                <div class="quiz-category" data-category-id="${category.id}">
                    <h3><span class="quiz-category-icon">${category.icon}</span> ${category.name}</h3>
                    <p>${category.description}</p>
                    <div class="category-progress"></div>
                </div>
            `).join('');

            // Add click handlers with error handling
            categoriesContainer.querySelectorAll('.quiz-category').forEach(category => {
                category.addEventListener('click', async (e) => {
                    try {
                        const categoryId = category.dataset.categoryId;
                        await startQuizCategory(categoryId);
                    } catch (error) {
                        console.error('Error starting quiz category:', error);
                        showFeedback('Fehler beim Starten der Kategorie', false);
                    }
                });
            });
        } catch (error) {
            console.error('Error initializing categories:', error);
            showFeedback('Fehler beim Initialisieren der Kategorien', false);
        }
    }

    async function startQuizCategory(categoryId) {
        try {
            const menuElement = document.getElementById('quiz-selection-menu');
            const contentElement = document.getElementById('quiz-content');
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'loading-indicator';
            loadingIndicator.innerHTML = '⏳ Lade Fragen...';
            
            // Reset quiz state
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            if (currentCategory !== categoryId) {
                const streakElement = document.querySelector('.status-item:nth-child(2)');
                if (streakElement && currentStreak > 0) {
                    streakElement.style.animation = 'fadeOutUp 0.5s ease';
                    await new Promise(r => setTimeout(r, 500));
                    currentStreak = 0;
                    showFeedback('Streak zurückgesetzt wegen Kategoriewechsel', false);
                }
            }
            
            currentCategory = categoryId;
            
            if (menuElement && contentElement) {
                menuElement.classList.add('hidden');
                await new Promise(r => setTimeout(r, 300));
                menuElement.style.display = 'none';
                
                contentElement.style.display = 'block';
                contentElement.classList.add('hidden');
                contentElement.appendChild(loadingIndicator);
                
                await new Promise(r => setTimeout(r, 50));
                contentElement.classList.remove('hidden');
                
                await loadQuestions(categoryId);
                
                loadingIndicator.remove();
                contentElement.style.opacity = '1';
                contentElement.style.animation = 'fadeIn 0.5s ease';
                
                saveGameData();
            }
        } catch (error) {
            console.error('Error starting quiz category:', error);
            showFeedback('Fehler beim Laden der Kategorie', false);
            if (loadingIndicator) loadingIndicator.remove();
            backToMenu();
        }
    }

    async function loadQuestions(categoryId) {
        try {
            let fileName;
            switch(categoryId) {
                case 'mix':
                    const allQuestions = [];
                    for (const file of ['cpu.json', 'mainboard.json', 'grundwissen.json', 'flashcards.json']) {
                        try {
                            const response = await fetch(file);
                            if (response.ok) {
                                const data = await response.json();
                                allQuestions.push(...data.questions);
                            }
                        } catch (e) {
                            console.warn(`Konnte ${file} nicht laden:`, e);
                        }
                    }
                    questions = allQuestions;
                    break;
                default:
                    fileName = quizCategories.find(cat => cat.id === categoryId)?.file || 'cpu.json';
                    const response = await fetch(fileName);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    questions = data.questions;
            }
            
            if (!questions || !questions.length) {
                throw new Error('Keine Fragen geladen');
            }
            
            createQuiz();
            
        } catch (error) {
            console.error('Error loading questions:', error);
            showFeedback('Fehler beim Laden der Fragen', false);
            const container = document.getElementById('current-question');
            if (container) {
                container.innerHTML = '<div class="error-message">Fehler beim Laden der Fragen. Bitte versuche es später erneut.</div>';
            }
        }
    }

    function selectRandomQuestions(amount = 10) {
        if (!questions || !questions.length) return [];
        const shuffled = [...questions].sort(() => Math.random() - 0.5);
        return shuffled.slice(0, Math.min(amount, questions.length));
    }

    function createQuiz() {
        try {
            currentQuestionIndex = 0;
            answeredQuestions.clear();
            currentQuestions = selectRandomQuestions();
            score = 0;
            
            const scoreElement = document.getElementById('score');
            if (scoreElement) scoreElement.textContent = '0';
            
            updateProgressBar();
            displayCurrentQuestion();
            
            const totalQuestionsElement = document.getElementById('total-questions');
            if (totalQuestionsElement) {
                totalQuestionsElement.textContent = currentQuestions.length;
            }
            
        } catch (error) {
            console.error('Error creating quiz:', error);
            showFeedback('Fehler beim Erstellen des Quiz', false);
        }
    }

    function displayCurrentQuestion() {
        try {
            const container = document.getElementById('current-question');
            if (!container || !currentQuestions[currentQuestionIndex]) return;
            
            const question = currentQuestions[currentQuestionIndex];
            const isFlashcard = question.hasOwnProperty('answer');
            
            container.dataset.questionIndex = currentQuestionIndex;
            container.classList.add('slide-out');
            
            const navigationElement = document.querySelector('.question-navigation');
            if (navigationElement) {
                navigationElement.style.display = isFlashcard ? 'none' : 'flex';
            }
            
            // Clear existing flashcard elements
            const existingControls = document.querySelector('.flashcard-controls-outside');
            if (existingControls) existingControls.remove();
            
            const existingProgress = document.querySelector('.flashcard-progress');
            if (existingProgress) existingProgress.remove();
            
            setTimeout(() => {
                // Update question number
                const questionNumberElement = document.getElementById('current-question-number');
                if (questionNumberElement) {
                    questionNumberElement.textContent = currentQuestionIndex + 1;
                }
                
                if (isFlashcard) {
                    displayFlashcard(question, container);
                } else {
                    displayMultipleChoice(question, container);
                }
                
                container.classList.remove('slide-out');
                container.classList.add('slide-in');
                
                setTimeout(() => {
                    container.classList.remove('slide-in');
                }, 500);
                
            }, 300);
            
            updateNavigation(isFlashcard);
            
            if (timerActive) startQuestionTimer();
            
        } catch (error) {
            console.error('Error displaying question:', error);
            showFeedback('Fehler beim Anzeigen der Frage', false);
        }
    }

    function displayFlashcard(question, container) {
        // Add progress indicator
        container.insertAdjacentHTML('beforebegin', `
            <div class="flashcard-progress">
                ${currentQuestions.map((_, index) =>
                    `<div class="progress-dot${index === currentQuestionIndex ? ' active' : ''}"></div>`
                ).join('')}
            </div>
        `);
        
        // Create flashcard
        container.innerHTML = `
            <div class="flashcard" id="flashcard-${currentQuestionIndex}">
                <div class="card-face card-front">
                    ${question.imageUrl ? `<img src="${question.imageUrl}" alt="Kartenabbildung" class="card-image">` : ''}
                    <h3>${question.question}</h3>
                    <div class="card-hint">Tippen zum Umdrehen</div>
                </div>
                <div class="card-face card-back">
                    <h3>${question.answer}</h3>
                </div>
            </div>
        `;
        
        // Add control buttons
        const controls = document.createElement('div');
        controls.className = 'flashcard-controls-outside';
        controls.dataset.questionIndex = currentQuestionIndex;
        controls.innerHTML = `
            <button class="flashcard-button correct-button">✅ Richtig</button>
            <button class="flashcard-button incorrect-button">❌ Falsch</button>
        `;
        
        const questionContainer = document.getElementById('single-question-container');
        if (questionContainer) {
            questionContainer.parentNode.insertBefore(controls, questionContainer.nextSibling);
        }
        
        container.parentElement.classList.add('flashcard-active');
        initSwipeGestures();
    }

    function displayMultipleChoice(question, container) {
        const correctOptionIndex = question.correct;
        const options = [...question.options];
        const randomizedOptions = [];
        
        // Create index mapping
        const optionIndexMap = {};
        const originalOptions = [...options];
        
        options.sort(() => Math.random() - 0.5);
        randomizedOptions.push(...options);
        
        randomizedOptions.forEach((option, newIndex) => {
            optionIndexMap[newIndex] = originalOptions.indexOf(option);
        });
        
        question.optionIndexMap = optionIndexMap;
        
        container.innerHTML = `
            <div class="question-text">${question.question}</div>
            <div class="question-options">
                ${randomizedOptions.map((option, index) =>
                    `<div class="option" data-index="${index}">${option}</div>`
                ).join('')}
            </div>
        `;
        
        container.parentElement.classList.remove('flashcard-active');
    }

    function updateNavigation(isFlashcard) {
        const prevButton = document.getElementById('prev-question');
        const nextButton = document.getElementById('next-question');
        
        if (prevButton) {
            prevButton.disabled = currentQuestionIndex === 0;
        }
        
        if (nextButton) {
            nextButton.disabled = currentQuestionIndex === currentQuestions.length - 1 ||
                                !answeredQuestions.has(currentQuestionIndex);
        }
    }

    function checkAnswer(questionIndex, selectedOption) {
        if (answeredQuestions.has(questionIndex)) return;
        
        try {
            const question = currentQuestions[questionIndex];
            if (!question) return;
            
            const options = document.querySelectorAll('.option');
            const originalSelectedIndex = question.optionIndexMap ? 
                                       question.optionIndexMap[selectedOption] : 
                                       selectedOption;
            
            const isCorrect = originalSelectedIndex === question.correct;
            question.lastSelected = originalSelectedIndex;
            
            // Disable options
            options.forEach(option => option.style.pointerEvents = 'none');
            
            // Mark selected answer
            if (options[selectedOption]) {
                options[selectedOption].classList.add(isCorrect ? 'correct' : 'incorrect');
            }
            
            // Show correct answer if wrong
            if (!isCorrect) {
                let correctDisplayIndex = selectedOption;
                if (question.optionIndexMap) {
                    for (const [newIndex, originalIndex] of Object.entries(question.optionIndexMap)) {
                        if (parseInt(originalIndex) === question.correct) {
                            correctDisplayIndex = parseInt(newIndex);
                            break;
                        }
                    }
                }
                
                if (options[correctDisplayIndex]) {
                    setTimeout(() => {
                        options[correctDisplayIndex].classList.add('correct');
                    }, 300);
                }
            }
            
            // Update game state
            handleAnswerResult(isCorrect);
            
        } catch (error) {
            console.error('Error checking answer:', error);
            showFeedback('Fehler beim Prüfen der Antwort', false);
        }
    }

    function handleAnswerResult(isCorrect) {
        try {
            answeredQuestions.add(currentQuestionIndex);
            totalQuestions++;
            
            clearTimer();
            
            if (isCorrect) {
                processCorrectAnswer();
            } else {
                processIncorrectAnswer();
            }
            
            // Update UI and save
            updateUI();
            saveGameData();
            
            // Handle navigation
            const nextButton = document.getElementById('next-question');
            if (nextButton) {
                nextButton.disabled = currentQuestionIndex === currentQuestions.length - 1;
            }
            
            // Auto advance
            if (currentQuestionIndex < currentQuestions.length - 1) {
                setTimeout(nextQuestion, 1500);
            } else {
                setTimeout(showQuizSummary, 1500);
            }
            
        } catch (error) {
            console.error('Error handling answer result:', error);
            showFeedback('Fehler beim Verarbeiten der Antwort', false);
        }
    }

    function processCorrectAnswer() {
        score++;
        totalCorrect++;
        updateStreak(true);
        
        const basePoints = 10;
        const streakBonus = Math.min(5, currentStreak);
        const timeBonus = timerActive ? Math.ceil((timeRemaining / maxTime) * 5) : 0;
        
        const xpGained = basePoints + streakBonus + timeBonus;
        totalXP += xpGained;
        
        showFeedback(
            `Richtig! +${xpGained} XP${streakBonus > 0 ? ` (${streakBonus} Streak Bonus)` : ''}${timeBonus > 0 ? ` (${timeBonus} Zeit Bonus)` : ''}`,
            true
        );
    }

    function processIncorrectAnswer() {
        if (currentStreak >= 3) {
            showFeedback(`Streak von ${currentStreak} beendet!`, false);
        }
        updateStreak(false);
        showFeedback('Leider falsch! Weiter so! 💪', false);
    }

    // Timer functions
    function toggleTimerMode() {
        try {
            timerActive = !timerActive;
            const timerContainer = document.getElementById('timer-container');
            const timerToggle = document.getElementById('timer-toggle');
            
            if (!timerContainer || !timerToggle) return;
            
            if (timerActive) {
                timerContainer.style.display = 'block';
                timerToggle.style.backgroundColor = 'var(--error-color)';
                startQuestionTimer();
            } else {
                timerContainer.style.display = 'none';
                timerToggle.style.backgroundColor = 'var(--primary-color)';
                clearTimer();
            }
        } catch (error) {
            console.error('Error toggling timer:', error);
            showFeedback('Fehler beim Timer-Modus', false);
        }
    }

    function startQuestionTimer() {
        try {
            clearTimer();
            
            const timerBar = document.getElementById('timer-bar');
            if (!timerBar) return;
            
            timeRemaining = maxTime;
            timerBar.style.width = '100%';
            
            let lastUpdateTime = Date.now();
            
            timerInterval = setInterval(() => {
                if (document.hidden) return;
                
                const currentTime = Date.now();
                const deltaTime = (currentTime - lastUpdateTime) / 1000;
                lastUpdateTime = currentTime;
                
                timeRemaining -= deltaTime;
                
                updateTimerBar(timerBar);
                
                if (timeRemaining <= 0) {
                    clearTimer();
                    if (!answeredQuestions.has(currentQuestionIndex)) {
                        showFeedback('Zeit abgelaufen!', false);
                        checkAnswer(currentQuestionIndex, -1);
                    }
                }
            }, 100);
            
        } catch (error) {
            console.error('Error starting timer:', error);
            showFeedback('Fehler beim Timer', false);
        }
    }

    function updateTimerBar(timerBar) {
        const percentage = Math.max(0, (timeRemaining / maxTime) * 100);
        timerBar.style.width = `${percentage}%`;
        
        if (timeRemaining <= 5) {
            timerBar.style.backgroundColor = 'var(--error-color)';
            timerBar.style.animation = 'pulse 1s infinite';
        } else {
            timerBar.style.backgroundColor = '';
            timerBar.style.animation = '';
        }
    }

    function clearTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }

    // Navigation functions
    function nextQuestion() {
        try {
            if (currentQuestionIndex < currentQuestions.length - 1) {
                currentQuestionIndex++;
                displayCurrentQuestion();
            }
        } catch (error) {
            console.error('Error navigating to next question:', error);
            showFeedback('Fehler beim Navigieren', false);
        }
    }

    function previousQuestion() {
        try {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayCurrentQuestion();
            }
        } catch (error) {
            console.error('Error navigating to previous question:', error);
            showFeedback('Fehler beim Navigieren', false);
        }
    }

    // Menu and UI functions
    async function backToMenu() {
        try {
            resetQuizState();
            
            const contentElement = document.getElementById('quiz-content');
            const menuElement = document.getElementById('quiz-selection-menu');
            
            if (contentElement && menuElement) {
                contentElement.classList.add('hidden');
                
                updateUI();
                
                menuElement.style.display = 'block';
                menuElement.classList.add('hidden');
                
                await new Promise(r => setTimeout(r, 300));
                contentElement.style.display = 'none';
                
                await new Promise(r => setTimeout(r, 50));
                menuElement.classList.remove('hidden');
            }
            
            saveGameData();
            loadSavedData();
        } catch (error) {
            console.error('Error returning to menu:', error);
            showFeedback('Fehler beim Zurückkehren zum Menü', false);
        }
    }

    function resetQuizState() {
        currentQuestions = [];
        currentQuestionIndex = 0;
        answeredQuestions.clear();
        score = 0;
        clearTimer();
        
        const timerContainer = document.getElementById('timer-container');
        const timerToggle = document.getElementById('timer-toggle');
        if (timerContainer) timerContainer.style.display = 'none';
        if (timerToggle) timerToggle.style.backgroundColor = 'var(--primary-color)';
        
        timerActive = false;
    }

    function showFeedback(message, isSuccess) {
        try {
            const feedbackMessage = document.getElementById('feedback-message');
            if (!feedbackMessage) return;
            
            feedbackMessage.textContent = message;
            feedbackMessage.className = `feedback-message ${isSuccess ? 'feedback-success' : 'feedback-error'}`;
            
            feedbackMessage.style.animation = 'none';
            feedbackMessage.offsetHeight;
            feedbackMessage.style.animation = `${isSuccess ? 'successPulse' : 'errorShake'} 0.5s ease`;
        } catch (error) {
            console.error('Error showing feedback:', error);
        }
    }

    // Streak and achievement handling
    function updateStreak(isCorrect) {
        try {
            const currentTime = new Date().getTime();
            const streakTimeout = 5 * 60 * 1000;
            
            if (lastAnswerTime && (currentTime - lastAnswerTime) > streakTimeout) {
                currentStreak = 0;
                showFeedback('Streak zurückgesetzt wegen Inaktivität!', false);
            }
            
            if (isCorrect) {
                currentStreak++;
                if (currentStreak > bestStreak) {
                    bestStreak = currentStreak;
                    checkStreakAchievements();
                }
            } else {
                currentStreak = 0;
            }
            
            lastAnswerTime = currentTime;
            
            const streakText = document.getElementById('streak-text');
            if (streakText) streakText.textContent = currentStreak;
            
            updateStreakVisuals();
            
        } catch (error) {
            console.error('Error updating streak:', error);
        }
    }

    function updateStreakVisuals() {
        const streakItem = document.querySelector('.status-item:nth-child(2)');
        if (!streakItem) return;
        
        if (currentStreak > 0) {
            streakItem.classList.add('active-streak');
            if (currentStreak >= 5) {
                streakItem.style.animation = 'streakPulse 1s infinite';
            }
        } else {
            streakItem.classList.remove('active-streak');
            streakItem.style.animation = 'none';
        }
    }

    function checkStreakAchievements() {
        if (bestStreak === 5) {
            showAchievement('Streak Master! 🔥', '5er Streak erreicht!');
        } else if (bestStreak === 10) {
            showAchievement('Streak Champion! 🏆', '10er Streak erreicht!');
        } else if (bestStreak === 25) {
            showAchievement('Streak Legend! 👑', '25er Streak erreicht!');
        }
    }

    // Achievement system
    const achievementQueue = [];
    let isShowingAchievement = false;

    function showAchievement(title, description, icon = '🏆') {
        try {
            const achievementKey = `${title}_${description}`;
            if (earnedAchievements.includes(achievementKey)) return;
            
            earnedAchievements.push(achievementKey);
            saveGameData();
            
            achievementQueue.push({ title, description, icon });
            
            if (!isShowingAchievement) {
                showNextAchievement();
            }
        } catch (error) {
            console.error('Error showing achievement:', error);
        }
    }

    async function showNextAchievement() {
        if (achievementQueue.length === 0) {
            isShowingAchievement = false;
            return;
        }
        
        try {
            isShowingAchievement = true;
            const { title, description, icon } = achievementQueue.shift();
            
            const achievementPopup = document.getElementById('achievement-popup');
            const overlay = document.getElementById('overlay');
            const achievementTitle = document.getElementById('achievement-title');
            const achievementIcon = document.getElementById('achievement-icon');
            const achievementDescription = document.getElementById('achievement-description');
            
            if (achievementPopup && overlay && achievementTitle && achievementIcon && achievementDescription) {
                achievementTitle.textContent = title;
                achievementIcon.textContent = icon;
                achievementDescription.textContent = description;
                
                achievementPopup.classList.add('show');
                overlay.classList.add('show');
                
                if (window.confetti && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    confetti({
                        particleCount: 50,
                        spread: 70,
                        origin: { y: 0.6 },
                        disableForReducedMotion: true
                    });
                }
                
                await new Promise(r => setTimeout(r, 3000));
                closeAchievementPopup();
                
                await new Promise(r => setTimeout(r, 500));
                showNextAchievement();
            }
        } catch (error) {
            console.error('Error showing achievement popup:', error);
            isShowingAchievement = false;
        }
    }

    function closeAchievementPopup() {
        try {
            const achievementPopup = document.getElementById('achievement-popup');
            const overlay = document.getElementById('overlay');
            
            if (achievementPopup && overlay) {
                achievementPopup.classList.remove('show');
                overlay.classList.remove('show');
            }
        } catch (error) {
            console.error('Error closing achievement popup:', error);
        }
    }

    // Initialize event listeners for visibility changes
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && timerActive) {
            startQuestionTimer();
        }
    });
    </script>
</body>
</html>
