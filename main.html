<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPU Quiz</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.9/purify.min.js"></script>
    <style>
        /* Flashcard specific styles */
        .flashcard {
            position: relative;
            width: 100%;
            height: 320px;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d;
            cursor: pointer;
            margin: 20px auto;
            max-width: 600px;
            touch-action: manipulation; /* Improved touch handling */
        }
        
        .flashcard.flipped {
            transform: rotateY(180deg);
        }
        
        /* Mobile optimization for flashcard */
        @media (max-width: 768px) {
            .flashcard {
                height: 280px; /* Slightly smaller height on mobile */
                margin: 15px auto;
            }
            
            .flashcard-controls-outside {
                flex-direction: row;
                gap: 10px;
                padding: 10px;
            }
            
            .flashcard-button {
                flex: 1;
                padding: 12px 0;
                min-height: 50px; /* Better touch target */
            }
            
            /* Reorder quiz content on mobile - move game status below question container */
            .quiz-content {
                display: flex;
                flex-direction: column;
            }
            
            .game-status {
                order: 2; /* Move below question container */
                margin-top: 20px;
            }
            
            #single-question-container {
                order: 1;
            }
            
            #timer-container {
                order: 0; /* Keep timer at the top */
            }
            
            .controls {
                order: -1; /* Keep controls at the very top */
            }
        }
        
        @media (max-width: 480px) {
            .flashcard {
                height: 250px; /* Even smaller on very small screens */
            }
            
            .card-face h3 {
                font-size: 1.2em;
            }
            
            .card-hint {
                font-size: 0.9em;
            }
            
            /* Stack buttons on very small screens */
            .flashcard-controls-outside {
                flex-direction: row; /* Keep side by side for better UX */
                padding: 8px;
            }
            
            /* Further optimize game status on smaller screens */
            .game-status .status-content {
                padding: 8px;
            }
            
            .status-item {
                font-size: 0.9em;
                padding: 6px;
            }
        }
        
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
            border: 1px solid var(--border-color, #ddd);
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            transition: all 0.3s;
            overflow: hidden; /* Prevent overflow of content */
        }
        
        /* Pulsating effect for hint to tap */
        .card-hint {
            margin-top: 15px;
            font-style: italic;
            opacity: 0.7;
            animation: pulsate 2s ease-out infinite;
        }
        
        @keyframes pulsate {
            0% { opacity: 0.5; }
            50% { opacity: 0.8; }
            100% { opacity: 0.5; }
        }
        
        /* Hintergrundfarben für Light und Dark Mode */
        body:not([data-theme="dark"]) .card-face {
            background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%);
            color: #333;
        }
        
        body[data-theme="dark"] .card-face {
            background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%);
            color: #fff;
            border-color: #444;
        }
        
        .card-back {
            transform: rotateY(180deg);
            text-align: left; /* Align text to the left for better readability */
        }
          /* Protocol card formatting */
        .card-back h3 {
            font-size: 16px;
            line-height: 1.6;
            white-space: pre-line; /* Preserve line breaks in the text */
            padding: 0 10px;
            text-align: left;
        }
        
        .card-back h3 strong {
            color: var(--accent-color);
        }
        
        /* Protocol content formatting */
        .protocol-content {
            font-size: 16px;
            line-height: 1.6;
            text-align: left;
            padding: 10px;
            overflow-y: auto;
            max-height: 100%;
        }
        
        .protocol-content strong {
            color: var(--accent-color);
        }
        
        .card-image {
            max-width: 85%;
            max-height: 180px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border-radius: 8px;
            object-fit: contain;
            transition: transform 0.3s ease; /* Smooth zoom effect */
        }
        
        /* Zoom effect on image when card is flipped */
        .flashcard.flipped .card-image {
            transform: scale(0.9); /* Slightly smaller on card back */
        }
        
        @media (max-width: 768px) {
            .card-image {
                max-height: 140px;
                margin-bottom: 15px;
            }
        }
        
        .card-face h3 {
            font-size: 1.4em;
            text-align: center;
            margin-top: 10px;
            transition: transform 0.3s ease;
        }
        
        /* Enhance feedback that card is tapped */
        .flashcard:active .card-face {
            transform: scale(0.98);
        }
        
        .flashcard-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px auto;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        /* Improved feedback animations */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.8s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.8s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.8s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.8s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Question navigation styles */
        .question-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
        }

        .question-navigation button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-navigation button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .question-navigation button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }

        /* Styling für die Flashcard-Controls außerhalb des Containers */
        .flashcard-controls-outside {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px auto 25px;
            padding: 15px;
            background-color: var(--container-bg, #fff);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Dark Mode für Flashcard-Controls */
        body[data-theme="dark"] .flashcard-controls-outside {
            background-color: #2d2d2d;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        body:not([data-theme="dark"]) .flashcard-controls-outside {
            background-color: #fff;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Button ripple effect for better touch feedback */
        .flashcard-button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        
        .flashcard-button:active:after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .correct-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        .incorrect-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
        }
        
        /* Animations für Light und Dark Mode */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.6s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.6s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Question navigation styles */
        .question-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
        }

        .question-navigation button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-navigation button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .question-navigation button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }

        /* Styling für die Flashcard-Controls außerhalb des Containers */
        .flashcard-controls-outside {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px auto 25px;
            padding: 15px;
            background-color: var(--container-bg, #fff);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Dark Mode für Flashcard-Controls */
        body[data-theme="dark"] .flashcard-controls-outside {
            background-color: #2d2d2d;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        body:not([data-theme="dark"]) .flashcard-controls-outside {
            background-color: #fff;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Button ripple effect for better touch feedback */
        .flashcard-button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        
        .flashcard-button:active:after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .correct-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        .incorrect-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
        }
        
        /* Animations für Light und Dark Mode */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.6s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.6s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Question navigation styles */
        .question-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
        }

        .question-navigation button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-navigation button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .question-navigation button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }

        /* Styling für die Flashcard-Controls außerhalb des Containers */
        .flashcard-controls-outside {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px auto 25px;
            padding: 15px;
            background-color: var(--container-bg, #fff);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Dark Mode für Flashcard-Controls */
        body[data-theme="dark"] .flashcard-controls-outside {
            background-color: #2d2d2d;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        body:not([data-theme="dark"]) .flashcard-controls-outside {
            background-color: #fff;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Button ripple effect for better touch feedback */
        .flashcard-button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        
        .flashcard-button:active:after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .correct-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        .incorrect-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
        }
        
        /* Animations für Light und Dark Mode */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.6s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.6s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Question navigation styles */
        .question-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
        }

        .question-navigation button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-navigation button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .question-navigation button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }

        /* Styling für die Flashcard-Controls außerhalb des Containers */
        .flashcard-controls-outside {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px auto 25px;
            padding: 15px;
            background-color: var(--container-bg, #fff);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Dark Mode für Flashcard-Controls */
        body[data-theme="dark"] .flashcard-controls-outside {
            background-color: #2d2d2d;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        body:not([data-theme="dark"]) .flashcard-controls-outside {
            background-color: #fff;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Button ripple effect for better touch feedback */
        .flashcard-button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        
        .flashcard-button:active:after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .correct-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        .incorrect-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
        }
        
        /* Animations für Light und Dark Mode */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.6s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.6s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Question navigation styles */
        .question-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
        }

        .question-navigation button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-navigation button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .question-navigation button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }

        /* Styling für die Flashcard-Controls außerhalb des Containers */
        .flashcard-controls-outside {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px auto 25px;
            padding: 15px;
            background-color: var(--container-bg, #fff);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Dark Mode für Flashcard-Controls */
        body[data-theme="dark"] .flashcard-controls-outside {
            background-color: #2d2d2d;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        body:not([data-theme="dark"]) .flashcard-controls-outside {
            background-color: #fff;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Button ripple effect for better touch feedback */
        .flashcard-button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        
        .flashcard-button:active:after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .correct-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        .incorrect-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
        }
        
        /* Animations für Light und Dark Mode */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.6s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.6s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Question navigation styles */
        .question-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
        }

        .question-navigation button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-navigation button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .question-navigation button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }

        /* Styling für die Flashcard-Controls außerhalb des Containers */
        .flashcard-controls-outside {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px auto 25px;
            padding: 15px;
            background-color: var(--container-bg, #fff);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Dark Mode für Flashcard-Controls */
        body[data-theme="dark"] .flashcard-controls-outside {
            background-color: #2d2d2d;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        body:not([data-theme="dark"]) .flashcard-controls-outside {
            background-color: #fff;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Button ripple effect for better touch feedback */
        .flashcard-button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        
        .flashcard-button:active:after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .correct-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        .incorrect-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
        }
        
        /* Animations für Light und Dark Mode */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.6s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.6s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Question navigation styles */
        .question-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
        }

        .question-navigation button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-navigation button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .question-navigation button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }

        /* Styling für die Flashcard-Controls außerhalb des Containers */
        .flashcard-controls-outside {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px auto 25px;
            padding: 15px;
            background-color: var(--container-bg, #fff);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Dark Mode für Flashcard-Controls */
        body[data-theme="dark"] .flashcard-controls-outside {
            background-color: #2d2d2d;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        body:not([data-theme="dark"]) .flashcard-controls-outside {
            background-color: #fff;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Button ripple effect for better touch feedback */
        .flashcard-button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        
        .flashcard-button:active:after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .correct-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        .incorrect-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
        }
        
        /* Animations für Light und Dark Mode */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.6s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.6s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Question navigation styles */
        .question-navigation {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
        }

        .question-navigation button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .question-navigation button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .question-navigation button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }

        /* Styling für die Flashcard-Controls außerhalb des Containers */
        .flashcard-controls-outside {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px auto 25px;
            padding: 15px;
            background-color: var(--container-bg, #fff);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 600px;
            transition: all 0.3s ease;
        }

        /* Dark Mode für Flashcard-Controls */
        body[data-theme="dark"] .flashcard-controls-outside {
            background-color: #2d2d2d;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        body:not([data-theme="dark"]) .flashcard-controls-outside {
            background-color: #fff;
        }
        
        .flashcard-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Button ripple effect for better touch feedback */
        .flashcard-button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }
        
        .flashcard-button:active:after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }
        
        .correct-button {
            background-color: var(--success-color, #28a745);
            color: white;
        }
        
        .correct-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
        }
        
        .incorrect-button {
            background-color: var(--error-color, #dc3545);
            color: white;
        }
        
        .incorrect-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
        }
        
        /* Animations für Light und Dark Mode */
        body:not([data-theme="dark"]) .flashcard.correct .card-face {
            animation: lightGreenFlash 0.6s;
        }
        
        body:not([data-theme="dark"]) .flashcard.incorrect .card-face {
            animation: lightRedFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.correct .card-face {
            animation: darkGreenFlash 0.6s;
        }
        
        body[data-theme="dark"] .flashcard.incorrect .card-face {
            animation: darkRedFlash 0.6s;
        }
        
        /* Light Mode Animationen */
        @keyframes lightGreenFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #a3e4a3 0%, #7fd77f 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        @keyframes lightRedFlash {
            0% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
            50% { background: linear-gradient(135deg, #f5a6a6 0%, #e67a7a 100%); }
            100% { background: linear-gradient(135deg, #fff 0%, #f9f9f9 100%); }
        }
        
        /* Dark Mode Animationen */
        @keyframes darkGreenFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #2d5a2d 0%, #1e3e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        @keyframes darkRedFlash {
            0% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
            50% { background: linear-gradient(135deg, #5a2d2d 0%, #3e1e1e 100%); }
            100% { background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); }
        }
        
        /* Progress indicator for flashcards */
        .flashcard-progress {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            margin: 0 5px;
            opacity: 0.4;
        }
        
        .progress-dot.active {
            background-color: var(--primary-color);
            opacity: 1;
        }
        
        /* Verstecke die Navigationsschaltflächen bei Karteikarten */
        .flashcard-active .question-navigation {
            display: none !important; /* Force hide */
        }
    </style>
    <style>
        /* Audio section styles */
        .lernfeld-audio-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color, #ddd);
        }

        .lernfeld-audio-section h4 {
            font-size: 1.3em;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .lernfeld-audio-item {
            background-color: var(--container-bg, #fff);
            border: 1px solid var(--border-color, #ddd);
            border-radius: var(--border-radius, 8px);
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-sm, 0 2px 4px rgba(0,0,0,0.1));
        }

        body[data-theme="dark"] .lernfeld-audio-item {
            background-color: var(--container-bg-dark, #1e1e1e);
            border-color: var(--border-color-dark, #424242);
        }

        .lernfeld-audio-item .audio-name {
            font-size: 1.2em;
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 8px;
        }

        .lernfeld-audio-item .audio-description {
            font-size: 0.95em;
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .lernfeld-audio-player {
            width: 100%;
            margin-top: 10px;
        }
        
        /* Mobile-specific styles for audio section */
        @media (max-width: 768px) {
            .lernfeld-audio-section {
                margin-top: 20px;
                padding-top: 15px;
            }
            
            .lernfeld-audio-item {
                padding: 12px;
                margin-bottom: 15px;
            }
            
            .lernfeld-audio-item .audio-name {
                font-size: 1.1em;
            }
            
            .lernfeld-audio-item .audio-description {
                font-size: 0.9em;
                margin-bottom: 12px;
            }
            
            /* Optimize audio controls for touch */
            .lernfeld-audio-player {
                margin-top: 8px;
                height: 40px; /* Larger touch target */
            }
        }
        /* Screen reader only class */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Live region for announcements */
        .live-region {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
            pointer-events: none;
        }

        /* Explanation popup and overlay styles */
        .explanation-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            opacity: 0;
            background-color: var(--container-bg);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            z-index: 1001; /* Ensure popup is above overlay */
            max-width: 80%;
            width: auto;
            text-align: left;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .explanation-popup.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: all;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            z-index: 2000;
            display: none;
            animation: fadeIn 0.2s ease;
        }

        /* Markdown styles */
        .explanation-content {
            color: var(--text-color);
            line-height: 1.6;
        }

        .explanation-content h1,
        .explanation-content h2,
        .explanation-content h3,
        .explanation-content h4 {
            margin-top: 0.8em;
            margin-bottom: 0.4em;
            color: var(--text-color);
        }

        .explanation-content p {
            margin-bottom: 1em;
        }

        .explanation-content ul,
        .explanation-content ol {
            margin-left: 1.5em;
            margin-bottom: 1em;
        }

        .explanation-content code {
            background-color: rgba(0, 0, 0, 0.1);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }

        body[data-theme="dark"] .explanation-content code {
            background-color: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        .explanation-content pre {
            background-color: rgba(0, 0, 0, 0.1);
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 1em;
        }

        body[data-theme="dark"] .explanation-content pre {
            background-color: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        .explanation-content pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit;
        }

        .explanation-content blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 1em;
            margin-left: 0;
            margin-bottom: 1em;
            color: var(--text-color-secondary, #666);
        }

        .explanation-content img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            margin: 1em 0;
        }

        .explanation-content a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .explanation-content a:hover {
            text-decoration: underline;
        }

        .explanation-content table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
        }

        .explanation-content th,
        .explanation-content td {
            padding: 0.5em;
            border: 1px solid var(--border-color, #ddd);
        }

        .explanation-content th {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .overlay.show {
            display: block;
        }

        .explanation-popup h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-color);
        }

        .explanation-popup p {
            margin-bottom: 15px;
            line-height: 1.5;
            color: var(--text-color);
        }

        .explanation-popup .close-button,
        .explanation-popup .copy-button {
            padding: 10px 20px;
            border: 2px solid transparent;
            background-color: var(--primary-color);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            position: relative;
            overflow: hidden;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .explanation-popup .close-button:hover {
            background-color: var(--primary-color-dark);
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .explanation-popup .close-button:focus {
            outline: none;
            border-color: var(--primary-color-dark);
            box-shadow: 0 0 0 3px rgba(var(--primary-color-rgb), 0.3);
        }

        .explanation-popup .close-button:active {
            transform: translateY(0);
            box-shadow: none;
        }

        /* Mobile tap state animation */
        .explanation-popup button:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }

        .explanation-popup button:active:after {
            animation: buttonRipple 0.4s ease-out;
        }

        @keyframes buttonRipple {
            0% {
                transform: scale(0, 0) translate(-50%, -50%);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20) translate(-50%, -50%);
                opacity: 0;
            }
        }

        /* Mobile optimization for explanation popup */
        @media (max-width: 768px) {
            .explanation-popup {
                width: 90%;
                padding: 20px;
                font-size: 0.95em;
            }

            .explanation-popup button {
                width: 100%;
                padding: 12px;
                margin-top: 10px;
                font-size: 1.1em;
            }
        }

        /* Explanation button styles */
        .explanation-button {
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 1;
        }

        .explanation-button:disabled {
            background-color: var(--disabled-color, #ccc);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .explanation-button:not(:disabled):hover {
            background-color: var(--primary-color-dark);
            transform: translateY(-2px);
        }

        /* Code syntax highlighting for light and dark mode */
        .code-block {
            border: 1px solid var(--border-color, #ddd);
            margin-bottom: 1em;
            position: relative;
        }
        
        .code-block::before {
            content: attr(data-language);
            position: absolute;
            top: 0;
            right: 10px;
            padding: 2px 6px;
            font-size: 0.8em;
            color: var(--text-color-secondary);
            opacity: 0.7;
        }

        /* Improved code block styles */
        .explanation-content pre {
            background: var(--container-bg, #f5f5f5);
            padding: 2em 1em 1em;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1em 0;
            border: 1px solid var(--border-color, #ddd);
            position: relative;
        }
        
        body[data-theme="dark"] .explanation-content pre {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .explanation-content pre code {
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.4;
            tab-size: 4;
        }
        
        /* Improved explanation popup navigation */
        .explanation-content-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color, #ddd);
        }
        
        /* Center the close button */
        .explanation-controls {
            display: flex;
            justify-content: center; /* Center the single button */
        }

        /* Loading indicator styles */
        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            text-align: center;
            font-size: 1.2em;
            animation: fadeIn 0.3s ease;
        }
        
        /* Transition animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; transform: translate(-50%, -50%); }
            to { opacity: 0; transform: translate(-50%, -40%); }
        }
        
        @keyframes fadeInDown {
            from { 
                opacity: 0; 
                transform: translateY(-20px); 
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeOutUp {
            from { 
                opacity: 1;
                transform: translateY(0);
            }
            to { 
                opacity: 0;
                transform: translateY(-20px);
            }
        }
        
        /* Menu and content transitions */
        .quiz-selection-menu,
        .quiz-content,
        .lernfeld-view { /* Added .lernfeld-view here */
            transition: all 0.3s ease;
            background-color: var(--background-color, #fff);
            transform-origin: center;
            will-change: opacity, transform;
            backface-visibility: hidden;
        }
        
        body[data-theme="dark"] .quiz-selection-menu,
        body[data-theme="dark"] .quiz-content,
        body[data-theme="dark"] .lernfeld-view { /* Added .lernfeld-view here */
            background-color: var(--background-color-dark, #1a1a1a);
        }

        .quiz-selection-menu.hidden,
        .quiz-content.hidden,
        .lernfeld-view.hidden { /* Added .lernfeld-view.hidden */
            opacity: 0;
            transform: scale(0.98);
            pointer-events: none;
        }

        /* Styles for Lernfeld View */
        .lernfeld-view {
            padding: 20px;
            text-align: center;
            /* background-color, transition, transform-origin, will-change, backface-visibility
               are inherited from .quiz-selection-menu, .quiz-content if we add .lernfeld-view
               to the rule at line 2056. Let's do that for consistency. */
        }
        
        /* Add .lernfeld-view to the common transition/background style rule */
        /* This change will be made to the rule starting around line 2056 */

        .lernfeld-view h2 {
            font-size: 2em;
            color: var(--primary-color);
            margin-bottom: 25px;
        }

        /* Style for Lernfeld items on the main menu */
        .lernfeld-item {
            background-color: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            margin: 15px auto; /* Centering items */
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            max-width: 600px; /* Consistent width with other category items */
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }

        body[data-theme="dark"] .lernfeld-item {
            background-color: var(--container-bg-dark);
            border-color: var(--border-color-dark);
        }

        .lernfeld-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
        }

        .lernfeld-item h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.4em;
            color: var(--primary-color);
            display: flex; /* Align icon and text */
            align-items: center;
        }
        
        .lernfeld-item .lernfeld-icon { /* Specific class for Lernfeld icon */
            font-size: 1.5em;
            margin-right: 10px;
        }

        .lernfeld-item p {
            font-size: 0.95em;
            color: var(--text-color-secondary);
            margin-bottom: 0;
        }

        /* Styles for items within Lernfeld View */
        .lernfeld-quiz-options { /* Container for quiz buttons in Lernfeld view */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .lernfeld-view .quiz-category-button, /* For individual quizzes in Lernfeld view */
        .lernfeld-view .lernfeld-mixed-quiz-button {
            background-color: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 15px 20px; /* Slightly smaller padding than main menu items */
            margin: 0 auto; /* Centered by flex container */
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            width: 100%; /* Take full width of the flex container */
            max-width: 500px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
            display: flex; /* To align icon and text */
            align-items: center;
        }

        body[data-theme="dark"] .lernfeld-view .quiz-category-button,
        body[data-theme="dark"] .lernfeld-view .lernfeld-mixed-quiz-button {
            background-color: var(--container-bg-dark);
            border-color: var(--border-color-dark);
        }

        .lernfeld-view .quiz-category-button:hover,
        .lernfeld-view .lernfeld-mixed-quiz-button:hover {
            transform: translateY(-3px); /* Slightly less hover effect */
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }
        
        .lernfeld-view .quiz-category-button .quiz-icon, /* Icon for individual quiz */
        .lernfeld-view .lernfeld-mixed-quiz-button .quiz-icon { /* Icon for mixed quiz */
            font-size: 1.3em;
            margin-right: 12px;
        }

        .lernfeld-view .quiz-details { /* New container for name and description */
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        .lernfeld-view .quiz-category-button .quiz-name,
        .lernfeld-view .lernfeld-mixed-quiz-button .quiz-name {
            font-size: 1.2em;
            color: var(--text-color);
            /* flex-grow: 1; Removed as quiz-details handles flex growth */
            margin-bottom: 5px; /* Add some space if description follows */
        }

        .lernfeld-view .quiz-description { /* New style for description */
            font-size: 0.9em;
            color: var(--text-color-secondary, #555); /* Added a default for text-color-secondary */
            /* margin-left is not needed as .quiz-details handles alignment with icon */
            display: block; /* Ensure it takes its own line */
            line-height: 1.3;
        }

        body[data-theme="dark"] .lernfeld-view .quiz-category-button .quiz-name,
        body[data-theme="dark"] .lernfeld-view .lernfeld-mixed-quiz-button .quiz-name {
            color: var(--text-color-dark);
        }
        body[data-theme="dark"] .lernfeld-view .quiz-description { /* Dark mode for description */
            color: var(--text-color-secondary-dark, #aaa);
        }
        
        .lernfeld-view .back-to-main-menu-button {
            display: inline-block;
            margin-top: 30px;
            padding: 12px 25px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .lernfeld-view .back-to-main-menu-button:hover {
            background-color: var(--secondary-color-dark);
            transform: translateY(-2px);
        }
        
        /* Timer and Streak animations */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        @keyframes streakPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .timer-bar {
            transition: width 0.1s linear, background-color 0.3s ease;
        }
        
        .timer-bar.warning {
            background-color: var(--error-color) !important;
            animation: pulse 1s infinite;
        }
        
        .status-item.active-streak {
            position: relative;
        }
        
        .status-item.active-streak::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid var(--success-color);
            border-radius: inherit;
            animation: streakPulse 1s infinite;
            pointer-events: none;
        }
        
        .status-item.high-streak::after {
            border-color: gold;
            box-shadow: 0 0 10px gold;
        }
    </style>
</head>
<body>
    <div id="quiz-selection-menu" class="quiz-selection-menu">
        <h1 class="main-title">🎮 Maurice's Learning Game</h1>
        <p class="main-subtitle">Wähle ein Quiz-Thema und verbessere dein Wissen</p>
        
        <div id="quiz-categories" class="quiz-categories">
            <!-- Wird dynamisch gefüllt -->
        </div>
        
        <!-- Game Stats im Hauptmenü - nach unten verschoben -->
        <div class="main-menu-stats">
            <div class="stats-header">
                <h2>Deine Statistiken 📈</h2>
            </div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="total-quizzes">0</div>
                    <div class="stat-label">Gespielte Quizze</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="total-correct">0</div>
                    <div class="stat-label">Korrekte Antworten</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="average-score">0%</div>
                    <div class="stat-label">Durchschnittliche Punktzahl</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="best-streak">0</div>
                    <div class="stat-label">Längste Streak</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="earned-badges">0/4</div>
                    <div class="stat-label">Verdiente Badges</div>
                </div>
            </div>
            <div class="current-badge-display">
                <div class="badge-status">Aktuelles Badge:</div>
                <div id="menu-current-badge" class="menu-badge"></div>
            </div>
        </div>
    </div>

    <div id="lernfeld-view" class="lernfeld-view hidden">
        <!-- Content will be dynamically populated by JavaScript -->
        <!-- Example structure:
        <h2>Lernfeld Title</h2>
        <div class="lernfeld-quiz-options">
            <div class="quiz-category-button" onclick="startQuizCategory('quizId1')">
                <span class="quiz-icon">ICON</span>
                <span class="quiz-name">Quiz 1 Name</span>
            </div>
            <div class="lernfeld-mixed-quiz-button" onclick="startQuizCategory('lfX-mix')">
                <span class="quiz-icon">🔄</span>
                <span class="quiz-name">Lernfeld X Gemischtes Quiz</span>
            </div>
        </div>
        <button onclick="backToMenu()" class="back-to-main-menu-button">↩️ Zurück zum Hauptmenü</button>
        -->
    </div>
 
    <div id="quiz-content" class="quiz-content">
        <div class="controls">
            <button onclick="backToMenu()" class="back-button">
                <span class="btn-emoji">↩️</span><span class="btn-text">↩️ Zurück zum Menü</span>
            </button>
            <button onclick="toggleTheme()" id="theme-toggle">
                <span class="btn-emoji">🌓</span><span class="btn-text">🌓 Dark/Light Mode</span>
            </button>
            <button onclick="newQuiz()">
                <span class="btn-emoji">🔄</span><span class="btn-text">🔄 neues Quiz</span>
            </button>
            <button onclick="toggleTimerMode()" id="timer-toggle">
                <span class="btn-emoji">⏱️</span><span class="btn-text">⏱️ Zeitmodus</span>
            </button>
        </div>

        <div id="timer-container" class="timer-container">
            <div id="timer-bar" class="timer-bar"></div>
        </div>

        <div id="single-question-container" class="single-question-container">
            <div class="question-header">
                <div class="question-progress">
                    Frage <span id="current-question-number">1</span> von <span id="total-questions">10</span>
                </div>
                <div class="question-category">
                    Kategorie: <span id="current-category">CPU</span>
                </div>
            </div>

            <div id="current-question" class="current-question">
                <!-- Wird dynamisch gefüllt -->
            </div>

            <div class="question-navigation">
                <button id="prev-question" onclick="previousQuestion()" disabled>⬅️ Vorherige Frage</button>
                <button id="explanation-button" onclick="showExplanation()" class="explanation-button" disabled>💡</button>
                <button id="next-question" onclick="nextQuestion()">Nächste Frage ➡️</button>
            </div>

            <!-- Popup Container -->
            <div id="popup-container">
                <!-- Explanation Popup -->
                <div id="explanation-popup" 
                     class="explanation-popup" 
                     style="display: none;"
                     role="dialog"
                     aria-labelledby="explanation-title"
                     aria-modal="true"
                     aria-hidden="true">
                    <h3 id="explanation-title">Erklärung</h3>
                    <div id="explanation-text" class="explanation-content" role="document"></div>
                    <div class="explanation-content-footer">
                        <div class="explanation-controls">
                            <button onclick="closeExplanation()" 
                                    class="close-button"
                                    aria-label="Dialog schließen">
                                Schließen
                            </button>
                            <button onclick="copyExplanation()" 
                                    class="copy-button"
                                    aria-label="Erklärung kopieren">
                                📋 Kopieren
                            </button>
                        </div>
                    </div>
                </div>
                <!-- Blur Overlay -->
                <div id="blur-overlay" class="blur-overlay"></div>
            </div>
        </div>
        
        <!-- Moved the game-status div to appear after the single-question-container -->
        <div class="game-status">
            <div class="status-content">
                <div class="status-row">
                    <div class="status-item">
                        <div class="status-label">Level:</div>
                        <div class="status-value"><span id="level">1</span> 🌟</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Serie:</div>
                        <div class="status-value"><span id="streak-text">0</span> 🔥</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Punkte:</div>
                        <div class="status-value"><span id="score">0</span> 📊</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">XP:</div>
                        <div class="status-value"><span id="xp-display">0/100</span></div>
                    </div>
                </div>
            </div>
            <div id="feedback-message" class="feedback-message"></div>
        </div>
    </div>    <div id="overlay" class="overlay"></div>
    
    <!-- Achievement Popup als separates Element -->
    <div id="achievement-popup" class="achievement-popup">
        <h2 id="achievement-title">Achievement Unlocked!</h2>
        <div id="achievement-icon" class="badge-icon">🏆</div>
        <div id="achievement-description"></div>
        <button onclick="closeAchievementPopup()">Ok</button>
    </div>

    <script>
    // Theme toggle functionality
    let darkMode = localStorage.getItem('darkMode') !== 'false'; // Standardmäßig aktiviert, außer wenn explizit deaktiviert

    function toggleTheme() {
        darkMode = !darkMode;
        document.body.setAttribute('data-theme', darkMode ? 'dark' : 'light');
        localStorage.setItem('darkMode', darkMode);
    }

    // Game data saving and loading
    function saveGameData() {
        try {
            const currentTime = new Date().getTime();
            const gameData = {
                version: '1.0',
                totalXP: Math.max(0, totalXP),  // Prevent negative XP
                level: Math.min(Math.max(1, level), 100),  // Limit level range 1-100
                currentStreak,
                bestStreak,
                totalCorrect,
                totalQuestions,
                totalQuizzes,
                darkMode,
                lastActive: currentTime,
                badges: {
                    bronze: totalXP >= 100,
                    silver: totalXP >= 350,
                    gold: totalXP >= 750,
                    platinum: totalXP >= 1500
                },
                earnedAchievements: earnedAchievements || [], // Track unique achievements
                lastCategory: currentCategory
            };
            
            localStorage.setItem('quizGameData', JSON.stringify(gameData));
            
            // Backup to sessionStorage
            sessionStorage.setItem('quizGameData_backup', JSON.stringify(gameData));
            
            return true;
        } catch (error) {
            console.error('Failed to save game data:', error);
            return false;
        }
    }

    // Track earned achievements
    let earnedAchievements = [];
    let currentCategory = 'cpu';
    let lastAnswerTime = 0;
    
    function loadSavedData() {
        try {
            let savedData = localStorage.getItem('quizGameData');
            
            // Attempt to load from backup if primary load fails
            if (!savedData) {
                console.log('Primary data not found, attempting to load backup...');
                savedData = sessionStorage.getItem('quizGameData_backup');
            }
            
            if (savedData) {
                const data = JSON.parse(savedData);
                const currentTime = new Date().getTime();
                
                // Version check for future compatibility
                if (!data.version || data.version !== '1.0') {
                    console.warn('Data version mismatch, some features might not work correctly');
                }
                
                // Reset streak if inactive for more than 24 hours
                if (data.lastActive && (currentTime - data.lastActive) > 24 * 60 * 60 * 1000) {
                    data.currentStreak = 0;
                    console.log('Streak reset due to inactivity');
                }
                
                // Load and validate data with safe defaults
                totalXP = Math.max(0, data.totalXP || 0);
                level = Math.min(Math.max(1, data.level || 1), 100);
                currentStreak = Math.max(0, data.currentStreak || 0);
                bestStreak = Math.max(0, data.bestStreak || 0);
                totalCorrect = Math.max(0, data.totalCorrect || 0);
                totalQuestions = Math.max(0, data.totalQuestions || 0);
                totalQuizzes = Math.max(0, data.totalQuizzes || 0);
                darkMode = data.darkMode ?? true;
                currentCategory = data.lastCategory || 'cpu';
                earnedAchievements = data.earnedAchievements || [];
                
                // Update UI safely
                const updateElementText = (id, value) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                };
                
                // Update all UI elements
                updateElementText('total-xp', totalXP);
                updateElementText('level', level);
                updateElementText('menu-level', level);
                updateElementText('menu-total-xp', totalXP);
                
                // Update badges display
                updateBadgeDisplay();
                
                // Update other UI elements
                try {
                    const streakText = document.getElementById('streak-text');
                    if (streakText) updateStreak(false);
                    
                    const progressBar = document.getElementById('progress-bar');
                    if (progressBar) updateProgressBar();
                    
                    const levelElement = document.getElementById('level');
                    if (levelElement) updateLevel();
                    
                    updateProgressPath();
                    updateMainMenuStats();
                } catch (e) {
                    console.error('Some UI elements are not available yet:', e);
                }
                
                return true;
            }
            return false;
        } catch (error) {
            console.error('Failed to load saved data:', error);
            return false;
        }
    }

    function updateBadgeDisplay() {
        const menuCurrentBadge = document.getElementById('menu-current-badge');
        const earnedBadgesElement = document.getElementById('earned-badges');
        
        if (menuCurrentBadge) {
            if (totalXP >= 1500) menuCurrentBadge.textContent = '👑';
            else if (totalXP >= 750) menuCurrentBadge.textContent = '🥇';
            else if (totalXP >= 350) menuCurrentBadge.textContent = '🥈';
            else if (totalXP >= 100) menuCurrentBadge.textContent = '🥉';
            else menuCurrentBadge.textContent = '';
        }
        
        if (earnedBadgesElement) {
            let earnedCount = 0;
            if (totalXP >= 100) earnedCount++;
            if (totalXP >= 350) earnedCount++;
            if (totalXP >= 750) earnedCount++;
            if (totalXP >= 1500) earnedCount++;
            earnedBadgesElement.textContent = `${earnedCount}/4`;
        }
    }
 
    // Verfügbare Quiz-Kategorien und globale Variablen
    let questions = []; // Global questions array
    let currentQuestionIndex = 0;
    let answeredQuestions = new Set();

    // Lernfelder Definition
    const lernfelder = [
        {
            id: 'lf1',
            name: 'Lernfeld 1: Projektmanagement',
            icon: '📊',
            files: ['klassisches_projectmanagment.json'],
            quizzes: [
                {id: 'pm', name: 'Projektmanagement Quiz', file: 'klassisches_projectmanagment.json', icon: '📊'}
            ]
        },        {
            id: 'lf2',
            name: 'Lernfeld 2: Hardware & Basics',
            icon: '🛠️',
            files: ['cpu.json', 'grundwissen.json', 'mainboard.json', 'flashcards.json', 'RAM.json', 'BussystemeundSchnittstellen.json'],
            quizzes: [
                {id: 'cpu', name: 'CPU Quiz', description: 'Teste dein Wissen über Prozessoren.', file: 'cpu.json', icon: '💻'},
                {id: 'gw', name: 'Elektrogrundlagen Quiz', description: 'Grundlagen der Elektrotechnik und Elektronik.', file: 'grundwissen.json', icon: '⚡'},
                {id: 'mb', name: 'MainBoard Quiz', description: 'Alles rund um das Motherboard.', file: 'mainboard.json', icon: '🔌'},
                {id: 'flashcards', name: 'Karteikarten Quiz', description: 'Lerne mit digitalen Karteikarten zu Hardware & Basics.', file: 'flashcards.json', icon: '📚'},
                {id: 'ram', name: 'RAM Quiz', description: 'Fragen zu Arbeitsspeicher und dessen Technologien.', file: 'RAM.json', icon: '💾'},
                {id: 'bussysteme', name: 'Bussysteme & Schnittstellen', description: 'Fragen zu verschiedenen Bussystemen und Schnittstellen in der IT.', file: 'BussystemeundSchnittstellen.json', icon: '🔄'}
            ]
        },
        {
            id: 'lf3',
            name: 'Lernfeld 3: Netzwerk',
            description: 'Grundlagen und fortgeschrittene Konzepte der Netzwerktechnik.',
            mixedQuizDescription: 'Kombiniertes Quiz zu Netzwerk Grundlagen, Stufe 2 und Protokollen.',
            icon: '🌐',
            files: ['Netzwerk_Grundlagen.json', 'Netzwerk_Stufe_2.json', 'protocols.json'],
            audios: [
                {
                    id: 'lf3_audio_sicherungsschicht',
                    name: 'Netzwerk-Grundlagen: Sicherungsschicht, Vermittlungsschicht und Zahlensysteme',
                    description: 'Dieser Inhalt erklärt die Sicherungsschicht (Layer 2) für lokale Kommunikation und Medienzugriff sowie die Vermittlungsschicht (Layer 3) für Ende-zu-Ende-Datenübertragung über Netzwerke mit IPv4/IPv6 und Routing. Zusätzlich werden notwendige Zahlensysteme (binär, dezimal, hexadezimal) für das Verständnis von Netzwerkadressen vorgestellt.',
                    file: 'audios/Die Sicherungsschicht und Medienzugriff.wav',
                    type: 'audio/wav'
                },
                {
                    id: 'lf3_audio_adressaufloesung',
                    name: 'Adressauflösung und Grundlegende Router-Konfiguration',
                    description: 'Dieses Modul erklärt, wie ARP und ND die Kommunikation in einem Netzwerk ermöglichen, indem sie IP-Adressen in MAC-Adressen auflösen. Es behandelt auch die wesentlichen Schritte zur Konfiguration von Routern, wie die Sicherung des Zugriffs und die Konfiguration von Schnittstellen, die für die Weiterleitung von Paketen notwendig sind.',
                    file: 'audios/Adressauflösung und Router-Konfiguration.wav',
                    type: 'audio/wav'
                },
                {
                    id: 'lf3_audio_ethernet_mac',
                    name: 'Grundlagen von Ethernet, Frames und MAC-Adressen',
                    description: 'Dieses Material bietet eine Einführung in die Ethernet-Technologie, ihre Rolle in LANs und im OSI-Modell, insbesondere auf der Sicherungs- und Bitübertragungsschicht. Es erläutert die Struktur von Ethernet-Frames, die Funktion der einzelnen Felder wie MAC-Adressen und FCS, und beschreibt die Darstellung sowie die Zuweisung von MAC-Adressen, die zur eindeutigen Identifizierung von Geräten im LAN dienen.',
                    file: 'audios/Grundlagen von Ethernet und MAC-Adressen.wav',
                    type: 'audio/wav'
                }
            ],
            quizzes: [
                {id: 'netzwerk', name: 'Netzwerk Grundlagen Quiz', description: 'Basiswissen zu Netzwerken.', file: 'Netzwerk_Grundlagen.json', icon: '🌐'},
                {id: 'netzwerk2', name: 'Netzwerk Stufe 2 Quiz', description: 'Erweitere dein Wissen Ethernet, Osi Schichten Frames und mehr', file: 'Netzwerk_Stufe_2.json', icon: '🔗'},
                {id: 'protokolle', name: 'Netzwerkprotokolle', description: 'Wichtige Netzwerkprotokolle im Überblick.', file: 'protocols.json', icon: '🌍'}
            ]
        }
    ];
    
    // Quiz-Kategorien (vereinfacht, nur noch für das Haupt-Mix-Quiz)
    // Individuelle Quizze werden jetzt über die 'lernfelder' Struktur verwaltet.
    const quizCategories = [
        {
            id: 'mix',
            name: 'Gemischtes Quiz',
            description: 'Eine herausfordernde Mischung aus allen Kategorien für echte Profis',
            icon: '🔄',
            file: null // Wird von loadQuestions speziell behandelt, um alle Dateien aus lernfelder zu laden
        }
    ];

    // Initialisierung
    document.addEventListener('DOMContentLoaded', async function() {
        // Set initial theme
        document.body.setAttribute('data-theme', darkMode ? 'dark' : 'light');
        
        // Load saved data first (includes theme)
        loadSavedData(); // Ensures theme is applied from save if exists

        // Initialize main menu
        await initializeMainMenu(); // Changed from initializeQuizCategories
        
        // Show quiz selection menu
        await showQuizMenu(); // This handles the initial display logic
    });

    // Category transition handler
    async function startQuizCategory(categoryId) {
        const menuElement = document.getElementById('quiz-selection-menu');
        const lernfeldViewElement = document.getElementById('lernfeld-view');
        const contentElement = document.getElementById('quiz-content');
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'loading-indicator';
        loadingIndicator.innerHTML = '⏳ Lade Fragen...';
        
        try {
            // Reset quiz state
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            if (currentCategory !== categoryId) {
                const streakElement = document.querySelector('.status-item:nth-child(2)');
                if (streakElement && currentStreak > 0) {
                    streakElement.style.animation = 'fadeOutUp 0.5s ease';
                    await new Promise(r => setTimeout(r, 500));
                    currentStreak = 0;
                    showFeedback('Streak zurückgesetzt wegen Kategoriewechsel', false);
                    updateStreak(false);
                }
            }
            
            currentCategory = categoryId;
            
            if (menuElement && lernfeldViewElement && contentElement) {
                // Hide both menu and lernfeld view
                menuElement.classList.add('hidden');
                lernfeldViewElement.classList.add('hidden');
                
                await new Promise(r => setTimeout(r, 300));
                menuElement.style.display = 'none';
                lernfeldViewElement.style.display = 'none';
                
                contentElement.style.display = 'block';
                contentElement.classList.add('hidden');
                contentElement.appendChild(loadingIndicator);
                
                await new Promise(r => setTimeout(r, 50));
                contentElement.classList.remove('hidden');
                
                const categoryDisplay = document.getElementById('current-category');
                if (categoryDisplay) {
                    let displayName = 'Unbekannt';
                    if (categoryId.endsWith('-mix')) {
                        const lfId = categoryId.replace('-mix', '');
                        const lf = lernfelder.find(l => l.id === lfId);
                        displayName = lf ? `Gemischt: ${lf.name}` : 'Gemischtes Lernfeld Quiz';
                    } else {
                        const categoryInfo = quizCategories.find(cat => cat.id === categoryId);
                        if (categoryInfo) {
                            displayName = categoryInfo.name;
                        } else {
                            const lernfeldQuiz = lernfelder.flatMap(lf => lf.quizzes).find(q => q.id === categoryId);
                            displayName = lernfeldQuiz ? lernfeldQuiz.name : categoryId;
                        }
                    }
                    categoryDisplay.style.animation = 'fadeInDown 0.5s ease';
                    categoryDisplay.textContent = displayName;
                }
                
                await loadQuestions(categoryId);
                
                loadingIndicator.remove();
                contentElement.style.opacity = '1';

                saveGameData();
            }
        } catch (error) {
            console.error('Fehler beim Laden der Kategorie:', error);
            showFeedback('Fehler beim Laden der Fragen', false);
            if(loadingIndicator.parentNode) loadingIndicator.remove();
            backToMenu();
        }
    }

    // Main Menu initialisieren (früher initializeQuizCategories)
    async function initializeMainMenu() {
        const categoriesContainer = document.getElementById('quiz-categories');
        if (!categoriesContainer) return;

        let menuHTML = '';

        // Lernfelder hinzufügen
        lernfelder.forEach(lf => {
            menuHTML += `
                <div class="lernfeld-item" onclick="showLernfeldView('${lf.id}')" role="button" tabindex="0" aria-label="Lernfeld ${lf.name} öffnen">
                    <h3><span class="lernfeld-icon">${lf.icon || '📚'}</span> ${lf.name}</h3>
                    <p>${lf.description || `Enthält ${lf.quizzes.length} Quizze und ${lf.files.length} Themenbereiche.`}</p>
                </div>
            `;
        });

        // Haupt-Gemischtes Quiz hinzufügen
        const mainMixedQuiz = quizCategories.find(cat => cat.id === 'mix');
        if (mainMixedQuiz) {
            menuHTML += `
                <div class="quiz-category" onclick="startQuizCategory('${mainMixedQuiz.id}')" role="button" tabindex="0" aria-label="${mainMixedQuiz.name} starten">
                    <h3><span class="quiz-category-icon">${mainMixedQuiz.icon}</span> ${mainMixedQuiz.name}</h3>
                    <p>${mainMixedQuiz.description}</p>
                    <div class="category-progress"></div>
                </div>
            `;
        }
        categoriesContainer.innerHTML = menuHTML;

        // Add keydown event listeners for accessibility (Enter/Space to activate)
        document.querySelectorAll('.lernfeld-item, .quiz-category').forEach(item => {
            item.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    item.click();
                }
            });
        });
    }

    // Lernfeld Ansicht anzeigen
    async function showLernfeldView(lernfeldId) {
        const menuElement = document.getElementById('quiz-selection-menu');
        const lernfeldViewElement = document.getElementById('lernfeld-view');
        const quizContentElement = document.getElementById('quiz-content'); // Ensure quiz content is also managed

        if (!menuElement || !lernfeldViewElement || !quizContentElement) return;

        const selectedLernfeld = lernfelder.find(lf => lf.id === lernfeldId);
        if (!selectedLernfeld) {
            console.error(`Lernfeld with ID ${lernfeldId} not found.`);
            return;
        }

        let lernfeldViewHTML = `<h2>${selectedLernfeld.name}</h2>`;
        lernfeldViewHTML += `<div class="lernfeld-quiz-options">`;

        // Individuelle Quizze des Lernfelds
        selectedLernfeld.quizzes.forEach(quiz => {
            // Wrap icon and name/description in a flex container for better alignment
            lernfeldViewHTML += `
                <div class="quiz-category-button" onclick="startQuizCategory('${quiz.id}')" role="button" tabindex="0" aria-label="Quiz ${quiz.name} starten">
                    <span class="quiz-icon">${quiz.icon || '❓'}</span>
                    <div class="quiz-details">
                        <span class="quiz-name">${quiz.name}</span>
                        ${quiz.description ? `<span class="quiz-description">${quiz.description}</span>` : ''}
                    </div>
                </div>
            `;
        });

        // Gemischtes Quiz des Lernfelds
        lernfeldViewHTML += `
            <div class="lernfeld-mixed-quiz-button" onclick="startQuizCategory('${selectedLernfeld.id}-mix')" role="button" tabindex="0" aria-label="Gemischtes Quiz für ${selectedLernfeld.name} starten">
                <span class="quiz-icon">🔄</span>
                <div class="quiz-details">
                    <span class="quiz-name">Gemischtes Quiz für ${selectedLernfeld.name}</span>
                    ${selectedLernfeld.mixedQuizDescription ? `<span class="quiz-description">${selectedLernfeld.mixedQuizDescription}</span>` : ''}
                </div>
            </div>
        `;
        lernfeldViewHTML += `</div>`; // Close lernfeld-quiz-options

        // Add audio section if there are audio files
        if (selectedLernfeld.audios && selectedLernfeld.audios.length > 0) {
            lernfeldViewHTML += `<div class="lernfeld-audio-section"><h4>Audio-Inhalte:</h4>`;
            selectedLernfeld.audios.forEach(audio => {
                // Ensure the file path is URL-encoded if it contains spaces or special characters
                const audioFileSrc = encodeURIComponent(audio.file);
                lernfeldViewHTML += `
                    <div class="lernfeld-audio-item" id="audio-item-${audio.id}">
                        <h5 class="audio-name">${audio.name}</h5>
                        <p class="audio-description">${audio.description}</p>
                        <audio controls preload="metadata" class="lernfeld-audio-player">
                            <source src="${audioFileSrc}" type="${audio.type}">
                            Dein Browser unterstützt das Audio-Element nicht.
                        </audio>
                    </div>
                `;
            });
            lernfeldViewHTML += `</div>`;
        }

        // Zurück-Button
        lernfeldViewHTML += `<button onclick="backToMenu()" class="back-to-main-menu-button" aria-label="Zurück zum Hauptmenü">↩️ Zurück zum Hauptmenü</button>`;
        
        lernfeldViewElement.innerHTML = lernfeldViewHTML;

        // Add keydown event listeners for accessibility (Enter/Space to activate)
        lernfeldViewElement.querySelectorAll('.quiz-category-button, .lernfeld-mixed-quiz-button, .back-to-main-menu-button').forEach(item => {
            item.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    item.click();
                }
            });
        });
        
        menuElement.classList.add('hidden');
        quizContentElement.classList.add('hidden');
        
        await new Promise(r => setTimeout(r, 50));
        menuElement.style.display = 'none';
        quizContentElement.style.display = 'none';

        lernfeldViewElement.style.display = 'block';
        await new Promise(r => setTimeout(r, 50));
        lernfeldViewElement.classList.remove('hidden');
    }

    function createQuiz() {
        currentQuestionIndex = 0;
        answeredQuestions.clear();
        currentQuestions = selectRandomQuestions();
        score = 0;
        document.getElementById('score').textContent = 'Punktzahl: 0 Punkte 📊';
        updateProgressBar();
        displayCurrentQuestion();
        
        // Update total questions display
        document.getElementById('total-questions').textContent = currentQuestions.length;
    }

    // Show quiz menu with smooth transitions
    async function showQuizMenu() {
        const menuElement = document.getElementById('quiz-selection-menu');
        const contentElement = document.getElementById('quiz-content');
        
        if (menuElement && contentElement) {
            // Update stats before transition
            updateMainMenuStats();
            
            // Prepare elements for transition
            contentElement.classList.add('hidden');
            menuElement.style.display = 'block';
            
            // Small delay to ensure display change is processed
            await new Promise(r => setTimeout(r, 50));
            
            // Remove hidden class to trigger transition
            menuElement.classList.remove('hidden');
        }
        
        // Ensure quiz content is properly reset
        if (contentElement) {
            contentElement.style.opacity = '0';
            const timerBar = document.getElementById('timer-bar');
            if (timerBar) {
                timerBar.style.width = '100%';
                timerBar.style.backgroundColor = '';
                timerBar.style.animation = '';
            }
        }
    }

    // Fragen laden und Quiz initialisieren
    let currentQuestions = [];
    let xp = 0;
    let totalXP = 0;
    let level = 1;
    let currentStreak = 0;
    let bestStreak = 0;
    let totalCorrect = 0;
    let totalQuestions = 0;
    let totalQuizzes = 0;
    let timerActive = false;
    let timerInterval = null;
    let maxTime = 30; // Sekunden pro Frage
    let timeRemaining = maxTime;

    function toggleTimerMode() {
        timerActive = !timerActive;
        const timerContainer = document.getElementById('timer-container');
        const timerToggle = document.getElementById('timer-toggle');
        
        if (!timerContainer || !timerToggle) return;
        
        if (timerActive) {
            timerContainer.style.display = 'block';
            timerToggle.style.backgroundColor = 'var(--error-color)';
            startQuestionTimer();
        } else {
            timerContainer.style.display = 'none';
            timerToggle.style.backgroundColor = 'var(--primary-color)';
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
    }

    function startQuestionTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        
        const timerBar = document.getElementById('timer-bar');
        if (!timerBar) return;
        
        timeRemaining = maxTime;
        timerBar.style.width = '100%';
        
        let lastUpdateTime = Date.now();
        
        timerInterval = setInterval(() => {
            // Überprüfe, ob der Tab aktiv ist
            if (document.hidden) {
                return;
            }
            
            // Berechne die tatsächlich vergangene Zeit
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastUpdateTime) / 1000;
            lastUpdateTime = currentTime;
            
            timeRemaining -= deltaTime;
            
            // Update Timer Bar
            if (timerBar) {
                const percentage = Math.max(0, (timeRemaining / maxTime) * 100);
                timerBar.style.width = `${percentage}%`;
                
                // Füge Warnung hinzu wenn wenig Zeit übrig ist
                if (timeRemaining <= 5) {
                    timerBar.style.backgroundColor = 'var(--error-color)';
                    timerBar.style.animation = 'pulse 1s infinite';
                } else {
                    timerBar.style.backgroundColor = '';
                    timerBar.style.animation = '';
                }
            }
            
            // Zeit abgelaufen
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;
                
                if (!answeredQuestions.has(currentQuestionIndex)) {
                    showFeedback('Zeit abgelaufen!', false);
                    checkAnswer(currentQuestionIndex, -1);
                }
            }
        }, 100); // Häufigere Updates für flüssigere Animation
        
        // Event Listener für Tab Visibility
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && timerActive) {
                lastUpdateTime = Date.now();
            }
        });
    }

    async function loadQuestions(categoryId) {
        try {
            let filesToLoad = [];
            let isMixedQuiz = false;
            let finalQuestions = [];
    
            if (categoryId.endsWith('-mix')) { // Lernfeld-specific mixed quiz
                isMixedQuiz = true;
                const lernfeldId = categoryId.replace('-mix', '');
                const lernfeld = lernfelder.find(lf => lf.id === lernfeldId);
                if (lernfeld && lernfeld.files) {
                    filesToLoad = lernfeld.files;
                } else {
                    console.error(`Lernfeld with ID ${lernfeldId} not found or has no files.`);
                    questions = [];
                    createQuiz();
                    return;
                }
            } else if (categoryId === 'mix') { // Main mixed quiz
                isMixedQuiz = true;
                lernfelder.forEach(lf => {
                    if (lf.files) {
                        filesToLoad.push(...lf.files);
                    }
                });
                filesToLoad = [...new Set(filesToLoad)]; // Remove duplicates
            }
    
            if (isMixedQuiz) {
                for (const file of filesToLoad) {
                    try {
                        const response = await fetch(file);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.questions && Array.isArray(data.questions)) {
                                finalQuestions.push(...data.questions);
                            } else {
                               console.warn(`File ${file} does not contain a valid "questions" array.`);
                            }
                        } else {
                            console.warn(`Could not load ${file} for mixed quiz: ${response.status}`);
                        }
                    } catch (e) {
                        console.warn(`Error fetching or parsing ${file} for mixed quiz:`, e);
                    }
                }
            } else {
                // Logic for single, non-mixed quiz files
                let fileName;
                const categoryInfo = quizCategories.find(cat => cat.id === categoryId);
    
                if (categoryInfo && categoryInfo.file) {
                    fileName = categoryInfo.file;
                } else {
                    // Fallback: if not in quizCategories, check the new lernfelder.quizzes structure
                    let foundQuiz = null;
                    for (const lf of lernfelder) {
                        if (lf.quizzes) { // Ensure quizzes array exists
                            foundQuiz = lf.quizzes.find(q => q.id === categoryId);
                            if (foundQuiz && foundQuiz.file) {
                                fileName = foundQuiz.file;
                                break;
                            }
                        }
                    }
                }
                
                if (!fileName) {
                    console.error(`Cannot find file for single quiz categoryId: ${categoryId}`);
                    questions = [];
                    createQuiz();
                    return;
                }
    
                const response = await fetch(fileName);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for file ${fileName}`);
                }
                const data = await response.json();
                if (data.questions && Array.isArray(data.questions)) {
                    finalQuestions = data.questions;
                } else {
                    console.warn(`File ${fileName} does not contain a valid "questions" array.`);
                    finalQuestions = [];
                }
            }
    
            questions = finalQuestions;
            createQuiz();
    
        } catch (error) {
            console.error('Fehler beim Laden der Fragen:', error);
            const container = document.getElementById('current-question');
            if (container) {
                container.innerHTML = '<div class="error-message">Fehler beim Laden der Fragen. Bitte versuche es später erneut.</div>';
            }
            questions = [];
            createQuiz();
        }
    }

    // neues Quiz starten
    function newQuiz() {
        currentQuestions = selectRandomQuestions();
        currentQuestionIndex = 0;
        answeredQuestions.clear();
        score = 0;
        document.getElementById('score').textContent = 'Punktzahl: 0 Punkte 📊';
        updateProgressBar();
        displayCurrentQuestion();
        
        // Update total questions display
        document.getElementById('total-questions').textContent = currentQuestions.length;
    }

    // Verbesserte Navigation zwischen den Fragen
    function displayCurrentQuestion() {
        const container = document.getElementById('current-question');
        const question = currentQuestions[currentQuestionIndex];
        const isFlashcard = question.hasOwnProperty('answer'); // Prüfen, ob es eine Karteikarte ist
        
        // Füge Slide-Out Animation hinzu
        container.classList.add('slide-out');
        
        // Navigation entsprechend dem Fragetyp anzeigen/verstecken
        const navigationElement = document.querySelector('.question-navigation');
        if (navigationElement) {
            navigationElement.style.display = 'none'; // Immer ausblenden für mehr Konsistenz
        }
        
        // Flashcard-Controls außerhalb der Karte entfernen, falls vorhanden
        const existingFlashcardControls = document.querySelector('.flashcard-controls-outside');
        if (existingFlashcardControls) {
            existingFlashcardControls.remove();
        }
        
        // Flashcard-Progress entfernen, falls vorhanden
        const existingFlashcardProgress = document.querySelector('.flashcard-progress');
        if (existingFlashcardProgress) {
            existingFlashcardProgress.remove();
        }
        
        setTimeout(() => {
            // Update question number
            document.getElementById('current-question-number').textContent = currentQuestionIndex + 1;

            // Darstellung abhängig vom Fragetyp (Normales Quiz oder Flashcard)
            if (isFlashcard) {
                // Erstelle Fortschrittsanzeige für Karteikarten (Punkte)
                const progressHTML = `
                    <div class="flashcard-progress">
                        ${currentQuestions.map((_, index) => 
                            `<div class="progress-dot${index === currentQuestionIndex ? ' active' : ''}"></div>`
                        ).join('')}
                    </div>
                `;
                
                // Füge die Fortschrittsanzeige vor dem Container ein
                container.insertAdjacentHTML('beforebegin', progressHTML);
                
                // Erstelle das Flashcard-HTML
                const isProtocol = currentCategory === 'protokolle';
                
                // Flashcard-Darstellung - ohne Flashcard-Controls innerhalb
                container.innerHTML = `
                    <div class="flashcard" id="flashcard-${currentQuestionIndex}" onclick="flipCard(${currentQuestionIndex})">
                        <div class="card-face card-front">
                            ${question.imageUrl ? `<img src="${question.imageUrl}" alt="Kartenabbildung" class="card-image">` : ''}
                            <h3>${question.question}</h3>
                            <div class="card-hint">Tippen zum Umdrehen</div>
                        </div>
                        <div class="card-face card-back">
                            <div class="protocol-content"></div>
                        </div>
                    </div>
                `;
                
                // Setze den HTML-Inhalt für die Rückseite
                const protocolContent = container.querySelector('.protocol-content');
                if (protocolContent) {
                    // Sicheres Einfügen von HTML-Inhalten
                    protocolContent.innerHTML = question.answer;
                }
                
                // Füge Flashcard-Controls außerhalb des Containers hinzu
                const flashcardControls = document.createElement('div');
                flashcardControls.className = 'flashcard-controls-outside';
                flashcardControls.innerHTML = `
                    <button onclick="markFlashcardCorrect(${currentQuestionIndex})" class="flashcard-button correct-button">✅ Richtig</button>
                    <button onclick="markFlashcardIncorrect(${currentQuestionIndex})" class="flashcard-button incorrect-button">❌ Falsch</button>
                `;
                
                // Füge die Controls nach dem single-question-container ein
                const questionContainer = document.getElementById('single-question-container');
                questionContainer.parentNode.insertBefore(flashcardControls, questionContainer.nextSibling);
                
                // Aktiviere die Flashcard-Klasse am Container
                container.parentElement.classList.add('flashcard-active');
                
                // Initialisiere Swipe-Gesten für mobile Geräte
                initSwipeGestures();
            } else {
                // Normales Multiple-Choice-Quiz
                const correctOptionIndex = question.correct;
                const randomizedOptions = [];
                const options = [...question.options];
                
                // Erstelle eine Zuordnungstabelle zwischen ursprünglichen und gemischten Indices
                const optionIndexMap = {};
                const originalOptions = [...question.options];
                
                // Mische die Optionen
                options.sort(() => Math.random() - 0.5);
                randomizedOptions.push(...options);
                
                // Erstelle die Zuordnungstabelle
                randomizedOptions.forEach((option, newIndex) => {
                    const originalIndex = originalOptions.indexOf(option);
                    optionIndexMap[newIndex] = originalIndex;
                });
                
                // Speichere die Zuordnungstabelle in der Frage
                question.optionIndexMap = optionIndexMap;

                // Create options with staggered animation
                container.innerHTML = `
                    <div class="question-text">${question.question}</div>
                    ${question.imageUrl ? `<img src="${question.imageUrl}" alt="Frage Bild" class="question-image">` : ''}
                    <div class="question-options">
                        ${randomizedOptions.map((option, index) => `
                            <div class="option" onclick="checkAnswer(${currentQuestionIndex}, ${index})">${option}</div>
                        `).join('')}
                    </div>
                `;
                
                // Entferne die Flashcard-Klasse
                container.parentElement.classList.remove('flashcard-active');
                
                // Zeige die normalen Navigationselemente für Multiple-Choice-Fragen
                if (navigationElement) {
                    navigationElement.style.display = 'flex';
                }
            }
            
            // Update explanation button state
            const explanationButton = document.getElementById('explanation-button');
            if (explanationButton) {
                explanationButton.disabled = !question.explain;
            }

            // Füge Slide-In Animation hinzu
            container.classList.remove('slide-out');
            container.classList.add('slide-in');
            setTimeout(() => {
                container.classList.remove('slide-in');
            }, 500);

        }, 300); // Warte auf Slide-Out Animation

        // Update navigation buttons für normale Fragen
        if (!isFlashcard) {
            document.getElementById('prev-question').disabled = currentQuestionIndex === 0;
            document.getElementById('next-question').disabled = 
                currentQuestionIndex === currentQuestions.length - 1 || 
                !answeredQuestions.has(currentQuestionIndex);
        }
        
        // Start timer if aktiv
        if (timerActive) {
            startQuestionTimer();
        }
    }
    
    // Funktion zum Initialisieren von Swipe-Gesten für Karteikarten
    function initSwipeGestures() {
        const flashcard = document.querySelector('.flashcard');
        if (!flashcard) return;
        
        let touchStartX = 0;
        let touchEndX = 0;
        let touchStartY = 0;
        let touchEndY = 0;
        
        // Touch-Events registrieren
        flashcard.addEventListener('touchstart', function(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, false);
        
        flashcard.addEventListener('touchend', function(e) {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, false);
        
        // Swipe-Richtung auswerten
        function handleSwipe() {
            // Horizontale Bewegung muss größer sein als vertikale, um als Swipe zu gelten
            const horizontalDiff = Math.abs(touchEndX - touchStartX);
            const verticalDiff = Math.abs(touchEndY - touchStartY);
            
            // Mindestabstand für Swipe (50px)
            const minSwipeDistance = 50;
            
            if (horizontalDiff > minSwipeDistance && horizontalDiff > verticalDiff) {
                if (touchEndX < touchStartX) {
                    // Swipe nach links -> nächste Frage
                    if (currentQuestionIndex < currentQuestions.length - 1 && answeredQuestions.has(currentQuestionIndex)) {
                        nextQuestion();
                    }
                } else {
                    // Swipe nach rechts -> vorherige Frage
                    if (currentQuestionIndex > 0) {
                        previousQuestion();
                    }
                }
            } else if (verticalDiff > minSwipeDistance && verticalDiff > horizontalDiff) {
                if (touchEndY < touchStartY) {
                    // Swipe nach oben -> Karte umdrehen
                    flipCard(currentQuestionIndex);
                }
            }
        }
    }

    // Konsolidierte Version der [checkAnswer] Funktion
    function checkAnswer(questionIndex, selectedOption) {
        if (answeredQuestions.has(questionIndex)) return;
        
        const question = currentQuestions[questionIndex];
        if (!question) return;
        
        const options = document.querySelectorAll('.option');
        
        // Verwende die Zuordnungstabelle, um den ursprünglichen Index zu ermitteln
        const originalSelectedIndex = question.optionIndexMap ? question.optionIndexMap[selectedOption] : selectedOption;
        const isCorrect = originalSelectedIndex === question.correct;
        
        // Speichere die ausgewählte Option
        question.lastSelected = originalSelectedIndex;
        
        // Deaktiviere alle Optionen
        options.forEach(option => option.style.pointerEvents = 'none');
        
        // Markiere ausgewählte Antwort
        if (options[selectedOption]) {
            options[selectedOption].classList.add(isCorrect ? 'correct' : 'incorrect');
        }
        
        // Zeige korrekte Antwort bei falscher Auswahl
        if (!isCorrect) {
            // Finde den neuen Index der korrekten Antwort basierend auf der Zuordnungstabelle
            let correctDisplayIndex = selectedOption; // Fallback
            if (question.optionIndexMap) {
                for (const [newIndex, originalIndex] of Object.entries(question.optionIndexMap)) {
                    if (parseInt(originalIndex) === question.correct) {
                        correctDisplayIndex = parseInt(newIndex);
                        break;
                    }
                }
            }
            
            if (options[correctDisplayIndex]) {
                setTimeout(() => {
                    options[correctDisplayIndex].classList.add('correct');
                }, 300);
            }
        }

        // Enable explanation button if available
        const explanationButton = document.getElementById('explanation-button');
        if (explanationButton && question.explain) {
            explanationButton.disabled = false;
        }

        // Update Spielstatus
        answeredQuestions.add(questionIndex);
        totalQuestions++;

        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        // Verarbeite das Ergebnis
        if (isCorrect) {
            score++;
            totalCorrect++;
            updateStreak(true);
            
            // XP Berechnung
            const basePoints = 10;
            const streakBonus = Math.min(5, currentStreak);
            const timeBonus = timerActive ? Math.ceil((timeRemaining / maxTime) * 5) : 0;
            
            const xpGained = basePoints + streakBonus + timeBonus;
            totalXP += xpGained;
            
            // Feedback anzeigen
            showFeedback(`Richtig! +${xpGained} XP${streakBonus > 0 ? ` (${streakBonus} Streak Bonus)` : ''}${timeBonus > 0 ? ` (${timeBonus} Zeit Bonus)` : ''}`, true);
        } else {
            updateStreak(false);
            showFeedback('Leider falsch! Weiter so! 💪', false);
        }

        // Update UI
        updateGameStatus();
        saveGameData();
        
        // Navigation
        const nextButton = document.getElementById('next-question');
        if (nextButton) {
            nextButton.disabled = currentQuestionIndex === currentQuestions.length - 1;
        }

        // Automatische Weiterleitung nach Verzögerung
        if (currentQuestionIndex < currentQuestions.length - 1) {
            setTimeout(nextQuestion, 1500);
        } else {
            setTimeout(showQuizSummary, 1500);
        }
    }

    function showQuizSummary() {
        const container = document.getElementById('current-question');
        if (!container) return;
        
        const correctAnswers = Array.from(answeredQuestions).filter(index => 
            currentQuestions[index].lastSelected === currentQuestions[index].correct
        ).length;
        
        const percentage = Math.round((correctAnswers / currentQuestions.length) * 100);
        
        container.innerHTML = `
            <div class="quiz-summary">
                <h2>Quiz abgeschlossen! 🎉</h2>
                <div class="summary-stats">
                    <div class="summary-stat">
                        <div class="stat-value">${correctAnswers}/${currentQuestions.length}</div>
                        <div class="stat-label">Richtige Antworten</div>
                    </div>
                    <div class="summary-stat">
                        <div class="stat-value">${percentage}%</div>
                        <div class="stat-label">Genauigkeit</div>
                    </div>
                    <div class="summary-stat">
                        <div class="stat-value">${totalXP}</div>
                        <div class="stat-label">Gesamt XP</div>
                    </div>
                </div>
                <button onclick="newQuiz()" class="retry-button">🔄 Noch einmal versuchen</button>
                <button onclick="backToMenu()" class="menu-button">↩️ Zurück zum Menü</button>
            </div>
        `;

        // Speichere den Fortschritt
        totalQuizzes++;
        saveGameData();
        
        // Zeige Achievement wenn Genauigkeit hoch ist
        if (percentage >= 90) {
            showAchievement('Perfektionist! 🏆', 'Du hast über 90% richtig beantwortet!');
        }
    }

    function updateStreak(isCorrect) {
        const streakText = document.getElementById('streak-text');
        const streakItem = document.querySelector('.status-item:nth-child(2)');
        
        if (isCorrect) {
            currentStreak++;
            if (currentStreak > bestStreak) {
                bestStreak = currentStreak;
                // Zeige Achievement für neue Beststreak
                if (bestStreak >= 5) {
                    showAchievement('Streak Master! 🔥', `Neue Beststreak: ${bestStreak}!`);
                }
            }
        } else {
            if (currentStreak >= 3) {
                showFeedback(`Streak von ${currentStreak} beendet!`, false);
            }
            currentStreak = 0;
        }
        
        if (streakText) {
            streakText.textContent = currentStreak;
        }
        
        // Visuelles Feedback für aktive Streak
        if (streakItem) {
            if (currentStreak > 0) {
                streakItem.classList.add('active-streak');
            } else {
                streakItem.classList.remove('active-streak');
            }
        }
        
        // Speichere den aktuellen Spielstand
        saveGameData();
        updateGameStatus();
    }
 
    // Update UI
    function updateGameStatus() {
        // Update Level und XP-Anzeige
        const levelElement = document.getElementById('level');
        const xpDisplay = document.getElementById('xp-display');
        const streakText = document.getElementById('streak-text');
        const scoreElement = document.getElementById('score');
        const currentBadgeElement = document.getElementById('current-badge');
        
        if (levelElement) levelElement.textContent = level;
        if (xpDisplay) xpDisplay.textContent = `${totalXP % 100}/100 (${100 - (totalXP % 100)} bis Level ${level + 1})`;
        if (streakText) streakText.textContent = currentStreak;
        if (scoreElement) scoreElement.textContent = `${score}`;
        
        // Update aktuelles Badge
        if (currentBadgeElement) {
            if (totalXP >= 1500) currentBadgeElement.textContent = '👑';
            else if (totalXP >= 750) currentBadgeElement.textContent = '🥇';
            else if (totalXP >= 350) currentBadgeElement.textContent = '🥈';
            else if (totalXP >= 100) currentBadgeElement.textContent = '🥉';
            else currentBadgeElement.textContent = '';
        }
    }
 
    async function backToMenu() {
        currentQuestions = [];
        currentQuestionIndex = 0;
        answeredQuestions.clear();
        score = 0;
        
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        
        const timerContainer = document.getElementById('timer-container');
        const timerToggle = document.getElementById('timer-toggle');
        if (timerContainer) timerContainer.style.display = 'none';
        if (timerToggle) timerToggle.style.backgroundColor = 'var(--primary-color)';
        timerActive = false;
        
        const contentElement = document.getElementById('quiz-content');
        const menuElement = document.getElementById('quiz-selection-menu');
        const lernfeldViewElement = document.getElementById('lernfeld-view');
        
        if (contentElement && menuElement && lernfeldViewElement) {
            contentElement.classList.add('hidden');
            lernfeldViewElement.classList.add('hidden');
            
            updateMainMenuStats(); // Update stats before showing menu
            
            menuElement.style.display = 'block';
            menuElement.classList.add('hidden');
            
            await new Promise(r => setTimeout(r, 300));
            contentElement.style.display = 'none';
            lernfeldViewElement.style.display = 'none';
            
            await new Promise(r => setTimeout(r, 50));
            menuElement.classList.remove('hidden');
        }
        
        saveGameData();
        // loadSavedData(); // Not strictly necessary here if saveGameData is comprehensive and UI updates are handled by showQuizMenu/initializeMainMenu
    }

    function updateMainMenuStats() {
        // Calculate accurate stats
        const averageScore = totalQuestions > 0 
            ? Math.round((totalCorrect / totalQuestions) * 100) 
            : 0;
        
        // Update all menu stats elements
        const updateElement = (id, value) => {
            const element = document.getElementById(id);
            if (element) element.textContent = value;
        };
        
        updateElement('total-quizzes', totalQuizzes);
        updateElement('total-correct', totalCorrect);
        updateElement('average-score', `${averageScore}%`);
        updateElement('best-streak', bestStreak);
        
        // Update badge display
        const earnedBadgesElement = document.getElementById('earned-badges');
        if (earnedBadgesElement) {
            let earnedCount = 0;
            if (totalXP >= 100) earnedCount++;
            if (totalXP >= 350) earnedCount++;
            if (totalXP >= 750) earnedCount++;
            if (totalXP >= 1500) earnedCount++;
            earnedBadgesElement.textContent = `${earnedCount}/4`;
        }
        
        // Update current badge
        const menuCurrentBadge = document.getElementById('menu-current-badge');
        if (menuCurrentBadge) {
            if (totalXP >= 1500) menuCurrentBadge.textContent = '👑';
            else if (totalXP >= 750) menuCurrentBadge.textContent = '🥇';
            else if (totalXP >= 350) menuCurrentBadge.textContent = '🥈';
            else if (totalXP >= 100) menuCurrentBadge.textContent = '🥉';
            else menuCurrentBadge.textContent = '';
        }
    }

    function showFeedback(message, isSuccess) {
        const feedbackMessage = document.getElementById('feedback-message');
        if (!feedbackMessage) return;
        
        feedbackMessage.textContent = message;
        feedbackMessage.className = `feedback-message ${isSuccess ? 'feedback-success' : 'feedback-error'}`;
        
        // Animation Effect
        feedbackMessage.style.animation = 'none';
        feedbackMessage.offsetHeight; // Trigger reflow
        feedbackMessage.style.animation = `${isSuccess ? 'successPulse' : 'errorShake'} 0.5s ease`;
    }

    function selectRandomQuestions(amount = 10) {
        if (!questions || !questions.length) return [];
        
        const shuffled = [...questions].sort(() => Math.random() - 0.5);
        return shuffled.slice(0, Math.min(amount, questions.length));
    }

    function updateLevel() {
        level = Math.floor(totalXP / 100) + 1;
        const levelElement = document.getElementById('level');
        const menuLevelElement = document.getElementById('menu-level');
        
        if (levelElement) levelElement.textContent = level;
        if (menuLevelElement) menuLevelElement.textContent = level;
    }

    function nextQuestion() {
        if (currentQuestionIndex < currentQuestions.length - 1) {
            currentQuestionIndex++;
            displayCurrentQuestion();
        }
    }

    function previousQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            displayCurrentQuestion();
        }
    }

    function updateProgressBar() {
        const progressBar = document.querySelector('.progress-bar');
        if (progressBar) {
            const progress = Math.round((score / (currentQuestions.length || 1)) * 100);
            progressBar.style.width = `${progress}%`;
        }
        // updateMainMenuStats(); // Removed: Not necessary to update main menu stats here
    }

    // Achievement popup queue system
    const achievementQueue = [];
    let isShowingAchievement = false;

    function showAchievement(title, description, icon = '🏆') {
        // Check if achievement was already earned
        const achievementKey = `${title}_${description}`;
        if (earnedAchievements.includes(achievementKey)) {
            return;
        }

        // Add to earned achievements and save
        earnedAchievements.push(achievementKey);
        saveGameData();

        // Add to queue
        achievementQueue.push({ title, description, icon });
        
        // If not currently showing an achievement, start showing them
        if (!isShowingAchievement) {
            showNextAchievement();
        }
    }

    function showNextAchievement() {
        if (achievementQueue.length === 0) {
            isShowingAchievement = false;
            return;
        }

        isShowingAchievement = true;
        const { title, description, icon } = achievementQueue.shift();
        
        const achievementPopup = document.getElementById('achievement-popup');
        const overlay = document.getElementById('overlay');
        const achievementTitle = document.getElementById('achievement-title');
        const achievementIcon = document.getElementById('achievement-icon');
        const achievementDescription = document.getElementById('achievement-description');
        
        if (achievementPopup && overlay && achievementTitle && achievementIcon && achievementDescription) {
            achievementTitle.textContent = title;
            achievementIcon.textContent = icon;
            achievementDescription.textContent = description;
            
            overlay.style.display = "block"; // Stellen Sie sicher, dass das Overlay sichtbar ist
            overlay.classList.add('show');
            achievementPopup.classList.add('show');
            
            // Optional: Konfetti-Effekt with reduced particles for performance
            if (window.confetti && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                confetti({
                    particleCount: 50,
                    spread: 70,
                    origin: { y: 0.6 },
                    disableForReducedMotion: true
                });
            }
            
            // Auto-close after 5 seconds (erhöht von 3 auf 5 Sekunden)
            setTimeout(() => {
                closeAchievementPopup();
                // Show next achievement in queue after a small delay
                setTimeout(showNextAchievement, 1000);
            }, 8000);
        }
    }

    function closeAchievementPopup() {
        const achievementPopup = document.getElementById('achievement-popup');
        const overlay = document.getElementById('overlay');
        
        if (achievementPopup && overlay) {
            achievementPopup.classList.remove('show');
            overlay.classList.remove('show');
            
            // Nach der Animation das Overlay auch ausblenden
            setTimeout(() => {
                overlay.style.display = "none";
            }, 900);
        }
    }
 
    // Hinzufügen der fehlenden updateProgressPath Funktion
    // Explanation popup functionality
    function showExplanation() {
        const question = currentQuestions[currentQuestionIndex];
        if (!question || !question.explain) return;
        
        const popupContainer = document.getElementById('popup-container');
        const popup = document.getElementById('explanation-popup');
        const blurOverlay = document.getElementById('blur-overlay');
        const explanationText = document.getElementById('explanation-text');
        const closeButton = popup?.querySelector('.close-button');
        
        if (!popup || !explanationText || !blurOverlay || !closeButton || !popupContainer) return;
        
        // Parse markdown and set content
        const htmlContent = marked.parse(question.explain || '');
        explanationText.innerHTML = DOMPurify.sanitize(htmlContent);
        
        // Show container and elements
        popupContainer.classList.add('show');
        popup.style.display = 'block';
        blurOverlay.classList.add('show');
        
        // Update ARIA attributes
        popup.setAttribute('aria-hidden', 'false');
        document.body.setAttribute('aria-hidden', 'true');
        popup.setAttribute('aria-describedby', 'explanation-text');
        
        // Add animation classes
        popup.classList.add('show');
        
        // Focus management
        setTimeout(() => {
            closeButton.focus();
            
            // Announce to screen readers
            const liveRegion = document.createElement('div');
            liveRegion.setAttribute('aria-live', 'polite');
            liveRegion.setAttribute('class', 'sr-only');
            liveRegion.textContent = 'Erklärung wurde geöffnet';
            document.body.appendChild(liveRegion);
            
            setTimeout(() => liveRegion.remove(), 1000);
        }, 100);
        
        // Click outside to close
        overlay.onclick = closeExplanation;
        
        // Keyboard event handlers
        const handleKeydown = (e) => {
            if (e.key === 'Escape') {
                closeExplanation();
            } else if (e.key === 'Tab') {
                // Trap focus within popup
                e.preventDefault();
                const focusableElements = popup.querySelectorAll('button');
                const currentIndex = Array.from(focusableElements).indexOf(document.activeElement);
                const nextIndex = (currentIndex + (e.shiftKey ? -1 : 1) + focusableElements.length) % focusableElements.length;
                focusableElements[nextIndex].focus();
            } else if (e.key === 'c' && e.ctrlKey) {
                // Support keyboard shortcut for copy
                e.preventDefault();
                copyExplanation();
            }
        };
        
        popup.addEventListener('keydown', handleKeydown);
        
        // Store cleanup function
        popup.cleanupListeners = () => {
            popup.removeEventListener('keydown', handleKeydown);
        };
    }

    function copyExplanation() {
        const explanationText = document.getElementById('explanation-text');
        const copyButton = document.querySelector('.copy-button');
        
        if (!explanationText || !copyButton) return;
        
        try {
            // Get text content without HTML tags and normalize whitespace
            const textToCopy = explanationText.innerText
                .replace(/\s+/g, ' ')
                .trim();
                
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Success feedback
                copyButton.classList.add('success');
                const originalText = copyButton.textContent;
                copyButton.textContent = '✅ Kopiert!';
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    copyButton.classList.remove('success');
                    copyButton.textContent = originalText;
                }, 2000);
                
                // Announce to screen readers
                const liveRegion = document.createElement('div');
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('class', 'sr-only');
                liveRegion.textContent = 'Erklärung wurde in die Zwischenablage kopiert';
                document.body.appendChild(liveRegion);
                
                setTimeout(() => liveRegion.remove(), 1000);
            }).catch(err => {
                console.error('Failed to copy text:', err);
                // Error feedback
                copyButton.classList.add('error');
                copyButton.textContent = '❌ Fehler beim Kopieren';
                
                setTimeout(() => {
                    copyButton.classList.remove('error');
                    copyButton.textContent = '📋 Kopieren';
                }, 2000);
            });
        } catch (err) {
            console.error('Copy functionality not supported:', err);
            showFeedback('Kopieren wird von deinem Browser nicht unterstützt', false);
        }
    }

    function closeExplanation() {
        const popupContainer = document.getElementById('popup-container');
        const popup = document.getElementById('explanation-popup');
        const blurOverlay = document.getElementById('blur-overlay');
        
        if (popup && blurOverlay && popupContainer) {
            // Cleanup event listeners
            if (popup.cleanupListeners) {
                popup.cleanupListeners();
                popup.cleanupListeners = null;
            }
            
            // Update ARIA attributes
            popup.setAttribute('aria-hidden', 'true');
            document.body.setAttribute('aria-hidden', 'false');
            
            // Remove show classes
            popup.classList.remove('show');
            blurOverlay.classList.remove('show');
            popupContainer.classList.remove('show');
            
            // Return focus and announce closure
            const explanationButton = document.getElementById('explanation-button');
            if (explanationButton) {
                explanationButton.focus();
                
                const liveRegion = document.createElement('div');
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('class', 'sr-only');
                liveRegion.textContent = 'Erklärung wurde geschlossen';
                document.body.appendChild(liveRegion);
                
                setTimeout(() => liveRegion.remove(), 1000);
            }
            
            // Hide popup after animation
            setTimeout(() => {
                popup.style.display = 'none';
            }, 300);
        }
    }

    function updateProgressPath() {
        // Diese Funktion aktualisiert den visuellen Fortschritt, falls benötigt
        // Da sie im ursprünglichen Code aufgerufen aber nicht definiert war
        const currentXP = totalXP % 100;
        const progressPercent = Math.round((currentXP / 100) * 100);
        
        // Falls ein Fortschrittsbalken existiert, aktualisieren wir diesen
        const progressBar = document.querySelector('.progress-bar');
        if (progressBar) {
            progressBar.style.width = `${progressPercent}%`;
        }
    }

    // Flashcard-spezifische Funktionen
    function flipCard(questionIndex) {
        const flashcardEl = document.querySelector('.flashcard');
        if (!flashcardEl) return;
        
        // Flip the card
        flashcardEl.classList.toggle('flipped');
        
        // Get the hint element reference to update text
        const cardHint = flashcardEl.classList.contains('flipped') 
            ? flashcardEl.querySelector('.card-back .card-hint')
            : flashcardEl.querySelector('.card-front .card-hint');
        
        // Update hint text based on card state
        if (flashcardEl.classList.contains('flipped')) {
            // Create hint element on back if it doesn't exist
            if (!flashcardEl.querySelector('.card-back .card-hint')) {
                const backFace = flashcardEl.querySelector('.card-back');
                const hintElement = document.createElement('div');
                hintElement.className = 'card-hint';
                hintElement.textContent = 'Tippen zum Zurückdrehen';
                backFace.appendChild(hintElement);
            }
            
            // Try to trigger vibration for haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }
    }
    
    function markFlashcardCorrect(questionIndex) {
        if (answeredQuestions.has(questionIndex)) return;
        
        const flashcardEl = document.querySelector('.flashcard');
        if (!flashcardEl) return;
        
        // Add "correct" class to the flashcard
        flashcardEl.classList.add('correct');
        
        // Try to trigger vibration for haptic feedback on mobile
        if (navigator.vibrate) {
            navigator.vibrate([50, 30, 50]);
        }
        
        // Update game states
        answeredQuestions.add(questionIndex);
        score++;
        totalQuestions++;
        totalCorrect++;
        updateStreak(true);
        
        // XP calculation
        const basePoints = 10;
        const streakBonus = Math.min(5, currentStreak);
        const timeBonus = timerActive ? Math.ceil((timeRemaining / maxTime) * 5) : 0;
        
        const xpGained = basePoints + streakBonus + timeBonus;
        totalXP += xpGained;
        
        // Feedback
        showFeedback(`Richtig! +${xpGained} XP${streakBonus > 0 ? ` (${streakBonus} Streak Bonus)` : ''}${timeBonus > 0 ? ` (${timeBonus} Zeit Bonus)` : ''}`, true);
        
        // Clear timer if active
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        
        // Update UI
        updateGameStatus();
        saveGameData();
        
        // Enable next button
        const nextButton = document.getElementById('next-question');
        if (nextButton) {
            nextButton.disabled = currentQuestionIndex === currentQuestions.length - 1;
        }
        
        // Automatic redirect after delay
        if (currentQuestionIndex < currentQuestions.length - 1) {
            setTimeout(nextQuestion, 1500);
        } else {
            setTimeout(showQuizSummary, 1500);
        }
    }
    
    function markFlashcardIncorrect(questionIndex) {
        if (answeredQuestions.has(questionIndex)) return;
        
        const flashcardEl = document.querySelector('.flashcard');
        if (!flashcardEl) return;
        
        // Add "incorrect" class to the flashcard
        flashcardEl.classList.add('incorrect');
        
        // Try to trigger vibration for haptic feedback on mobile (different pattern for incorrect)
        if (navigator.vibrate) {
            navigator.vibrate([100, 30, 100]);
        }
        
        // Update game states
        answeredQuestions.add(questionIndex);
        totalQuestions++;
        updateStreak(false);
        
        // Feedback
        showFeedback('Weiter üben! 💪', false);
        
        // Clear timer if active
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        
        // Update UI
        updateGameStatus();
        saveGameData();
        
        // Enable next button
        const nextButton = document.getElementById('next-question');
        if (nextButton) {
            nextButton.disabled = currentQuestionIndex === currentQuestions.length - 1;
        }
        
        // Automatic redirect after delay
        if (currentQuestionIndex < currentQuestions.length - 1) {
            setTimeout(nextQuestion, 1500);
        } else {
            setTimeout(showQuizSummary, 1500);
        }
    }
    </script>
</body>
</html>
