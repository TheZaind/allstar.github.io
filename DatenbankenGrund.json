{
    "questions": [
        {
            "question": "ğŸŒ³ Ein XML-Dokument muss immer eine Baumstruktur haben. Was ist das charakteristische Merkmal dieser Struktur?",
            "options": [
                "Alle Elemente mÃ¼ssen auf derselben Hierarchieebene stehen",
                "Es gibt genau ein Wurzel-Element, das alle anderen Elemente umschlieÃŸt",
                "Jedes Element kann beliebig viele Ã¼bergeordnete Elemente haben",
                "Die Struktur muss mindestens 3 Ebenen tief sein"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸŒ³ Die XML-Baumstruktur basiert auf einem einzigen Wurzel-Element (Root-Element), das alle anderen Elemente hierarchisch umschlieÃŸt. Dies ist ein fundamentales Prinzip von XML - nach der XML-Deklaration folgt immer genau ein Wurzel-Element, in dem alle weiteren Elemente verschachtelt sind.\n\n**Warum andere Optionen falsch sind:**\n- Option A: Elemente stehen in verschiedenen Hierarchieebenen (Parent-Child-Beziehungen)\n- Option C: Jedes Element hat maximal ein Ã¼bergeordnetes Element (eindeutige Hierarchie)\n- Option D: Die Tiefe ist nicht vorgeschrieben - auch flache Strukturen sind gÃ¼ltig ğŸ“Š",
            "difficulty": "einsteiger",
            "category": "XML-Grundlagen"
        },
        {
            "question": "ğŸ“ Bei der Erstellung von XML-Dateien fÃ¼r einen internationalen Datenaustausch mÃ¼ssen Dateinamen-Richtlinien beachtet werden. Welcher Dateiname entspricht den Best Practices?",
            "options": [
                "MÃ¼ller&SÃ¶hne_Produktkatalog_2025.xml",
                "produktkatalog_mÃ¼ller_sÃ¶hne_2025.xml",
                "PRODUKTKATALOG_mueller_soehne_2025.xml",
                "produktkatalog_mueller_soehne_2025.xml"
            ],
            "correct": 3,
            "explain": "**BegrÃ¼ndung:** ğŸ“ Option D befolgt alle wichtigen Richtlinien fÃ¼r XML-Dateinamen:\n- âœ… Keine Umlaute (mÃ¼ller â†’ mueller, sÃ¶hne â†’ soehne)\n- âœ… Keine Sonderzeichen (&-Zeichen vermieden)\n- âœ… Konsistente Kleinschreibung\n- âœ… Underscore als Trennzeichen\n\n**Probleme der anderen Optionen:**\n- Option A: Sonderzeichen (&) und Umlaute (Ã¶)\n- Option B: Umlaute (Ã¼, Ã¶) kÃ¶nnen KompatibilitÃ¤tsprobleme verursachen\n- Option C: Inkonsistente GroÃŸ-/Kleinschreibung (PRODUKTKATALOG vs. mueller) ğŸš«\n\n**Praxisrelevanz:** Diese Regeln gewÃ¤hrleisten KompatibilitÃ¤t zwischen verschiedenen Betriebssystemen und Servern! ğŸŒ",
            "difficulty": "einsteiger",
            "category": "XML-Best-Practices"
        },
        {
            "question": "ğŸ” Analysieren Sie diese DTD-Zeile: <!ELEMENT song (title, year, duration?)>. Was bedeutet diese Definition fÃ¼r die XML-Struktur?",
            "options": [
                "Ein song-Element muss title und year enthalten, duration ist optional",
                "Ein song-Element kann beliebig viele title, year und duration Elemente haben",
                "Ein song-Element muss entweder title, year oder duration enthalten",
                "Ein song-Element kann title und year mehrfach enthalten, duration nur einmal"
            ],
            "correct": 0,
            "explain": "**BegrÃ¼ndung:** ğŸ” Die DTD-Syntax verwendet spezielle Zeichen fÃ¼r HÃ¤ufigkeitsangaben:\n- **title, year** (ohne Zeichen): Genau einmal erforderlich âœ…\n- **duration?** (Fragezeichen): Optional - kann 0 oder 1 mal vorkommen â“\n\n**DTD-Syntax-Reminder:**\n- `+` = Ein- oder mehrmals\n- `*` = Kein-, ein- oder mehrmals  \n- `?` = Kein- oder einmal (optional)\n- `|` = Oder-VerknÃ¼pfung\n- `()` = Gruppierung\n\n**Praktische Anwendung:** Diese Definition ist typisch fÃ¼r Musikdatenbanken, wo Titel und Jahr Pflichtfelder sind, die Spieldauer aber optional erfasst wird ğŸµ",
            "difficulty": "fortgeschritten",
            "category": "DTD-Validierung"
        },
        {
            "question": "âš–ï¸ Was ist der Unterschied zwischen 'wohlgeformtem' und 'validem' XML?",
            "options": [
                "Wohlgeformt bedeutet korrekte Syntax, valid bedeutet zusÃ¤tzlich DTD/Schema-KonformitÃ¤t",
                "Wohlgeformt und valid sind synonyme Begriffe",
                "Valid bedeutet korrekte Syntax, wohlgeformt bedeutet zusÃ¤tzlich DTD-KonformitÃ¤t",
                "Wohlgeformt gilt nur fÃ¼r HTML, valid nur fÃ¼r XML"
            ],
            "correct": 0,
            "explain": "**BegrÃ¼ndung:** âš–ï¸ Dies sind zwei verschiedene QualitÃ¤tsstufen in XML:\n\n**Wohlgeformt (Well-formed):** ğŸ“\n- Korrekte XML-Syntax (Ã¶ffnende/schlieÃŸende Tags stimmen Ã¼berein)\n- Ein Wurzel-Element vorhanden\n- Korrekte Verschachtelung der Elemente\n- Attribute in AnfÃ¼hrungszeichen\n\n**Valid (GÃ¼ltig):** âœ…\n- Wohlgeformt UND zusÃ¤tzlich konform zu DTD oder XML-Schema\n- Strukturregeln werden eingehalten\n- Erlaubte Elemente und Attribute werden verwendet\n\n**Hierarchie:** Jedes valide XML ist wohlgeformt, aber nicht jedes wohlgeformte XML ist valid! Ein XML kann syntaktisch korrekt sein, aber gegen die definierten GeschÃ¤ftsregeln verstoÃŸen ğŸ¯",
            "difficulty": "fortgeschritten",
            "category": "XML-Validierung"
        },
        {
            "question": "ğŸ—ï¸ Ein E-Commerce-System soll Produktdaten zwischen verschiedenen Abteilungen austauschen. Welche XML-Struktur ist fÃ¼r skalierbare Produktkataloge am besten geeignet?",
            "options": [
                "<products><product><name>Laptop</name><price>999</price></product></products>",
                "<catalog><category id='electronics'><product sku='LAP001'><name>Laptop</name><price currency='EUR'>999</price><stock>50</stock></product></category></catalog>",
                "<data><item>Laptop|999|EUR</item></data>",
                "<root><laptop>999</laptop></root>"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ—ï¸ Option B bietet die beste Struktur fÃ¼r Enterprise-Anwendungen:\n\n**Vorteile der gewÃ¤hlten Struktur:**\n- ğŸ·ï¸ **Eindeutige Identifikation:** SKU-Attribute fÃ¼r Produktreferenzen\n- ğŸ’° **WÃ¤hrungsunterstÃ¼tzung:** Currency-Attribut fÃ¼r internationale MÃ¤rkte\n- ğŸ“¦ **Lagerbestand:** Stock-Element fÃ¼r VerfÃ¼gbarkeitsprÃ¼fung\n- ğŸ“‚ **Kategorisierung:** Category-Container fÃ¼r Produktgruppierung\n- ğŸ” **Erweiterbarkeit:** Klare Struktur fÃ¼r zusÃ¤tzliche Attribute\n\n**Probleme anderer Optionen:**\n- Option A: Zu simpel, keine WÃ¤hrung/Kategorien\n- Option C: Pipe-separated Values in XML = Anti-Pattern\n- Option D: Produktspezifische Tags = nicht skalierbar ğŸš«",
            "difficulty": "fortgeschritten",
            "category": "XML-Anwendungsdesign"
        },
        {
            "question": "ğŸ’¾ Relationale Datenbanken speichern Daten in Tabellen. Was ist das Hauptmerkmal des relationalen Modells?",
            "options": [
                "Alle Daten werden in einer einzigen groÃŸen Tabelle gespeichert",
                "Tabellen sind Ã¼ber FremdschlÃ¼ssel miteinander verbunden",
                "Jede Tabelle kann nur maximal 255 Zeilen enthalten",
                "Die Reihenfolge der DatensÃ¤tze ist fest vorgegeben"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ’¾ Das relationale Datenbankmodell basiert auf der Verbindung (Relation) zwischen Tabellen:\n\n**Kernprinzipien relationaler Datenbanken:**\n- ğŸ”— **FremdschlÃ¼ssel-Beziehungen:** VerknÃ¼pfung zwischen Tabellen Ã¼ber gemeinsame Werte\n- ğŸ“Š **Normalisierung:** Daten werden auf mehrere Tabellen aufgeteilt, um Redundanzen zu vermeiden\n- ğŸ” **SQL-Abfragen:** JOIN-Operationen verbinden Daten aus verschiedenen Tabellen\n\n**Beispiel E-Commerce:**\n- Tabelle 'Kunden' (ID, Name, E-Mail)\n- Tabelle 'Bestellungen' (ID, Kunden_ID, Datum)\n- VerknÃ¼pfung Ã¼ber Kunden_ID ğŸ›’\n\n**Warum andere Optionen falsch sind:**\n- A: Eine Tabelle = nicht relational\n- C: Zeilenlimit ist implementierungsabhÃ¤ngig\n- D: SQL erlaubt flexible Sortierung",
            "difficulty": "einsteiger",
            "category": "Relationale-Datenbanken"
        },
        {
            "question": "ğŸ”§ Bei der Entwicklung eines datenbankbasierten Webshops mÃ¼ssen verschiedene Tabellen entworfen werden. Welche Normalisierungsregel sollte beachtet werden?",
            "options": [
                "Alle Produktinformationen in einer Tabelle speichern fÃ¼r bessere Performance",
                "Redundante Daten vermeiden durch Aufteilung in logisch getrennte Tabellen",
                "Jede Tabelle sollte mindestens 10 Spalten haben",
                "FremdschlÃ¼ssel nur in der Haupttabelle verwenden"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ”§ Die Normalisierung ist ein Kernprinzip relationaler Datenbankdesigns:\n\n**Vorteile der Normalisierung:**\n- ğŸš« **Redundanz-Vermeidung:** Jede Information wird nur einmal gespeichert\n- ğŸ”„ **Update-Anomalien vermeiden:** Ã„nderungen mÃ¼ssen nur an einer Stelle erfolgen\n- ğŸ’¾ **Speicherplatz-Effizienz:** Weniger doppelte Daten\n- ğŸ›¡ï¸ **DatenintegritÃ¤t:** Konsistenz durch zentrale Datenhaltung\n\n**Beispiel Webshop-Design:**\n- Tabelle 'Hersteller' (ID, Name, Land)\n- Tabelle 'Produkte' (ID, Name, Hersteller_ID, Preis)\n- Statt: Herstellername in jeder Produktzeile zu wiederholen\n\n**Warum andere Optionen problematisch sind:**\n- A: Eine Mega-Tabelle fÃ¼hrt zu Redundanzen und Update-Problemen\n- C: Spaltenanzahl ist nicht relevant fÃ¼r Design-QualitÃ¤t\n- D: FremdschlÃ¼ssel werden in abhÃ¤ngigen Tabellen benÃ¶tigt ğŸ¯",
            "difficulty": "fortgeschritten",
            "category": "Datenbankdesign"
        },
        {
            "question": "ğŸ“Š Welches Datenaustauschformat ist fÃ¼r die Ãœbertragung hierarchischer Produktkatalog-Daten zwischen verschiedenen E-Commerce-Systemen am besten geeignet?",
            "options": [
                "CSV, weil es einfacher zu parsen ist",
                "XML, wegen der hierarchischen Struktur und ValidierungsmÃ¶glichkeiten",
                "JSON, weil es weniger Speicherplatz benÃ¶tigt",
                "Plain Text, wegen der universellen KompatibilitÃ¤t"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ“Š XML ist ideal fÃ¼r hierarchische E-Commerce-Daten:\n\n**Vorteile von XML fÃ¼r Produktkataloge:**\n- ğŸŒ³ **Hierarchische Struktur:** Kategorien â†’ Unterkategorien â†’ Produkte â†’ Varianten\n- âœ… **Schema-Validierung:** DTD/XSD gewÃ¤hrleisten DatenqualitÃ¤t\n- ğŸ·ï¸ **Metadaten-Support:** Attribute fÃ¼r IDs, WÃ¤hrungen, Sprachen\n- ğŸ” **XPath-Abfragen:** Gezielte Datenextraktion mÃ¶glich\n- ğŸŒ **Standard-Compliance:** Viele E-Commerce-Standards basieren auf XML\n\n**Limitierungen anderer Formate:**\n- **CSV:** Flache Struktur, keine Hierarchien, keine Validierung ğŸ“ˆ\n- **JSON:** Weniger Validierungsoptionen, keine standardisierten Schemas fÃ¼r E-Commerce\n- **Plain Text:** Keine Struktur, keine Typisierung, fehleranfÃ¤llig ğŸ“\n\n**Praxis-Beispiel:** Amazon MWS, eBay API, viele PIM-Systeme nutzen XML-basierte Produktdatenformate! ğŸ›’",
            "difficulty": "fortgeschritten",
            "category": "Datenaustausch-Strategien"
        },
        {
            "question": "ğŸ¯ Ein XML-Parser meldet einen Fehler bei diesem Code: <song><title>Rock & Roll</title></song>. Was ist das Problem?",
            "options": [
                "Das Attribut 'nr' fehlt im song-Element",
                "Der Text 'Rock & Roll' enthÃ¤lt ein nicht-erlaubtes Sonderzeichen",
                "Die XML-Deklaration fehlt am Anfang",
                "Das schlieÃŸende Tag ist falsch geschrieben"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ¯ Das Ampersand-Zeichen (&) ist ein reserviertes Zeichen in XML:\n\n**XML-Reservierte Zeichen:** âš ï¸\n- `&` â†’ `&amp;` (Ampersand)\n- `<` â†’ `&lt;` (Kleiner als)\n- `>` â†’ `&gt;` (GrÃ¶ÃŸer als)\n- `\"` â†’ `&quot;` (AnfÃ¼hrungszeichen)\n- `'` â†’ `&apos;` (Apostroph)\n\n**Korrekte Version:**\n```xml\n<song><title>Rock &amp; Roll</title></song>\n```\n\n**Warum das passiert:** ğŸ¤–\n- XML-Parser interpretieren & als Beginn einer Entity-Referenz\n- Ohne nachfolgende gÃ¼ltige Entity (amp, lt, gt, etc.) entsteht ein Parse-Fehler\n- Dies ist ein hÃ¤ufiger Fehler bei Musikdatenbanken und Firmennames!\n\n**Andere Optionen sind falsch:**\n- A: Attribute sind optional (je nach DTD)\n- C: XML-Deklaration ist optional fÃ¼r wohlgeformtes XML\n- D: Tags sind korrekt geschrieben ğŸµ",
            "difficulty": "fortgeschritten",
            "category": "XML-Parsing-Fehler"
        },
        {
            "question": "ğŸ—‚ï¸ In einer DTD ist definiert: <!ELEMENT playlist (song+)>. Was bedeutet das fÃ¼r eine gÃ¼ltige XML-Datei?",
            "options": [
                "Ein playlist-Element kann beliebig viele oder keine song-Elemente enthalten",
                "Ein playlist-Element muss mindestens ein song-Element enthalten",
                "Ein playlist-Element kann maximal ein song-Element enthalten",
                "Ein playlist-Element muss genau drei song-Elemente enthalten"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ—‚ï¸ Das Plus-Zeichen (+) in DTD bedeutet \"ein oder mehrmals\":\n\n**DTD-HÃ¤ufigkeitsoperatoren:** ğŸ“‹\n- **Ohne Zeichen:** Genau einmal (z.B. `song`)\n- **?** Ein- oder keinmal / Optional (z.B. `song?`)\n- **+** Ein- oder mehrmals / Mindestens eines (z.B. `song+`) âœ…\n- **\\*** Kein-, ein- oder mehrmals / Beliebig oft (z.B. `song*`)\n\n**Praktische Bedeutung:**\n- Eine leere Playlist wÃ¤re NICHT valid (mindestens 1 Song erforderlich)\n- Eine Playlist mit 1, 5, 100 Songs ist valid\n- Dies macht Sinn: Eine Playlist ohne Songs ist logisch fragwÃ¼rdig! ğŸµ\n\n**Anwendungsbeispiel:**\n```xml\n<playlist>\n    <song>...</song>\n    <song>...</song>\n    <!-- Weitere Songs optional -->\n</playlist>\n```",
            "difficulty": "einsteiger",
            "category": "DTD-Syntax"
        },
        {
            "question": "ğŸ”„ Ein Webshop-System soll Produktdaten sowohl aus XML-Dateien als auch aus einer SQL-Datenbank verarbeiten. Welcher Ansatz ist fÃ¼r die Datenintegration optimal?",
            "options": [
                "XML-Daten direkt in HTML konvertieren ohne Zwischenspeicherung",
                "Alle XML-Daten in relationale Tabellen importieren und einheitlich mit SQL verarbeiten",
                "Zwei separate Systeme ohne Datenintegration betreiben",
                "Alle SQL-Daten nach XML exportieren und nur XML verwenden"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ”„ Die Konsolidierung in relationalen Tabellen bietet die beste LÃ¶sung:\n\n**Vorteile der SQL-zentrierten Integration:**\n- ğŸ¯ **Einheitliche Abfragen:** Eine Query-Sprache fÃ¼r alle Daten\n- âš¡ **Performance:** Indexierte Datenbankabfragen sind schneller als XML-Parsing\n- ğŸ” **Suchfunktionen:** Volltext-Suche, Filter, Sortierung Ã¼ber alle Produkte\n- ğŸ›¡ï¸ **Transaktionssicherheit:** ACID-Eigenschaften fÃ¼r konsistente Datenoperationen\n- ğŸ“Š **Reporting:** Business Intelligence Tools kÃ¶nnen direkt auf SQL-Daten zugreifen\n\n**ETL-Prozess (Extract, Transform, Load):**\n1. XML-Dateien parsen ğŸ“„\n2. Daten transformieren und normalisieren ğŸ”„\n3. In relationale Tabellen laden ğŸ’¾\n4. Einheitliche SQL-Abfragen fÃ¼r Frontend ğŸ–¥ï¸\n\n**Warum andere AnsÃ¤tze suboptimal sind:**\n- A: Keine Persistierung, keine Suchfunktionen\n- C: Datensilos fÃ¼hren zu inkonsistenten Informationen\n- D: Verlust der SQL-Vorteile bei komplexen Abfragen ğŸ›ï¸",
            "difficulty": "experte",
            "category": "Systemarchitektur"
        },
        {
            "question": "ğŸ“ Betrachten Sie diese XML-Struktur: <catalog><category name='electronics'><product/></category></catalog>. Was macht diese Struktur problematisch fÃ¼r den Datenaustausch?",
            "options": [
                "Das category-Element sollte ein id-Attribut statt name haben",
                "Das product-Element ist leer und enthÃ¤lt keine Daten",
                "Die Verschachtelung ist zu tief fÃ¼r XML-Parser",
                "Das catalog-Element sollte Attribute haben"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ“ Ein leeres `<product/>` Element ist strukturell problematisch:\n\n**Probleme leerer Elemente:**\n- ğŸš« **Keine Nutzdaten:** Produkt ohne Name, Preis, ID ist wertlos\n- ğŸ” **Parsing-Ineffizienz:** Parser verarbeitet strukturlose Elemente\n- ğŸ“Š **Import-Probleme:** Datenbank-Import kann nicht zwischen echten und leeren Produkten unterscheiden\n- ğŸ¯ **Business-Logik:** Leere Produkte kÃ¶nnen Fehler in der Anwendungslogik verursachen\n\n**Bessere Struktur:**\n```xml\n<catalog>\n    <category name='electronics'>\n        <product id='LAP001'>\n            <name>Gaming Laptop</name>\n            <price currency='EUR'>1299.99</price>\n        </product>\n    </category>\n</catalog>\n```\n\n**Andere Optionen sind weniger kritisch:**\n- A: name-Attribut ist akzeptabel (ID wÃ¤re besser, aber nicht falsch)\n- C: 3 Ebenen sind normale Verschachtelung\n- D: Catalog-Attribute sind optional ğŸ’»",
            "difficulty": "fortgeschritten",
            "category": "XML-DatenqualitÃ¤t"
        },
        {
            "question": "âš¡ Ein XML-basiertes Content Management System verarbeitet tÃ¤glich 10.000 Produktaktualisierungen. Welcher Ansatz optimiert die Performance?",
            "options": [
                "Alle XML-Dateien einzeln parsen und validieren",
                "XML-Streaming-Parser verwenden und inkrementelle Updates in die Datenbank schreiben",
                "XML in JSON konvertieren und dann verarbeiten",
                "Alle XML-Daten im Arbeitsspeicher laden und dort verarbeiten"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** âš¡ Bei High-Volume-Datenverarbeitung ist Streaming-basierte Architektur optimal:\n\n**Vorteile von XML-Streaming + Inkrementelle Updates:**\n- ğŸŒŠ **Memory-Effizienz:** SAX/StAX Parser laden nicht die gesamte XML-Datei in den RAM\n- ğŸš€ **Skalierbarkeit:** Konstanter Speicherverbrauch unabhÃ¤ngig von DateigrÃ¶ÃŸe\n- âš¡ **Performance:** Parallel processing mÃ¶glich wÃ¤hrend des Parsens\n- ğŸ”„ **Inkrementelle Updates:** Nur geÃ¤nderte DatensÃ¤tze werden in der DB aktualisiert\n- ğŸ’¾ **Transaktions-Batching:** Mehrere Updates in einer Transaktion = weniger DB-Overhead\n\n**Probleme anderer AnsÃ¤tze:**\n- A: **DOM-Parser:** 10.000 Ã— komplettes Parsen = exponentieller Zeitaufwand ğŸ“ˆ\n- C: **Format-Konvertierung:** ZusÃ¤tzlicher Overhead ohne Nutzen ğŸ”„\n- D: **RAM-Limiting:** Bei groÃŸen XML-Dateien kann der Arbeitsspeicher Ã¼berlasten ğŸ’¥\n\n**Praxis-Implementierung:** Apache Camel, Spring Batch oder Ã¤hnliche ETL-Frameworks nutzen genau diesen Ansatz! ğŸ› ï¸",
            "difficulty": "experte",
            "category": "Performance-Optimierung"
        },
        {
            "question": "ğŸ”— Eine relationale Datenbank fÃ¼r einen Webshop enthÃ¤lt die Tabellen 'Kunden', 'Bestellungen' und 'Produkte'. Welche SQL-Operation verbindet Daten aus mehreren Tabellen?",
            "options": [
                "SELECT mit WHERE-Klausel",
                "INSERT mit UNION",
                "JOIN mit ON-Bedingung",
                "UPDATE mit SET"
            ],
            "correct": 2,
            "explain": "**BegrÃ¼ndung:** ğŸ”— JOIN-Operationen sind das HerzstÃ¼ck relationaler Datenbanken:\n\n**JOIN-Typen fÃ¼r Webshop-Szenarien:**\n- ğŸ”— **INNER JOIN:** Nur DatensÃ¤tze mit Ãœbereinstimmungen (Bestellungen mit gÃ¼ltigen Kunden)\n- ğŸ“‹ **LEFT JOIN:** Alle DatensÃ¤tze der linken Tabelle (alle Kunden, auch ohne Bestellungen)\n- ğŸ“Š **RIGHT JOIN:** Alle DatensÃ¤tze der rechten Tabelle\n- ğŸ”„ **FULL OUTER JOIN:** Alle DatensÃ¤tze aus beiden Tabellen\n\n**Beispiel-Query:**\n```sql\nSELECT k.name, b.datum, p.produktname\nFROM Kunden k\nJOIN Bestellungen b ON k.kunden_id = b.kunden_id\nJOIN Produkte p ON b.produkt_id = p.produkt_id\n```\n\n**Warum andere Operationen nicht passen:**\n- A: WHERE filtert, verbindet aber keine Tabellen\n- B: UNION kombiniert Ergebnismengen vertikal, nicht horizontal\n- D: UPDATE Ã¤ndert Daten, liest aber nicht aus mehreren Tabellen ğŸ¯",
            "difficulty": "einsteiger",
            "category": "SQL-Grundlagen"
        },
        {
            "question": "ğŸ› ï¸ Sie mÃ¼ssen ein XML-Schema (XSD) erstellen, das sicherstellt, dass Produktpreise nur positive Dezimalzahlen mit maximal 2 Nachkommastellen sind. Welche XSD-Definition ist korrekt?",
            "options": [
                "<xs:element name='price' type='xs:string'/>",
                "<xs:element name='price' type='xs:decimal' minInclusive='0.01' fractionDigits='2'/>",
                "<xs:element name='price' type='xs:integer'/>",
                "<xs:element name='price' type='xs:float' pattern='[0-9]+\\.[0-9]{2}'/>"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ› ï¸ XSD bietet prÃ¤zise Datentyp-Validierung fÃ¼r Business-Logik:\n\n**Optimale XSD-Definition fÃ¼r Preise:**\n```xml\n<xs:element name='price' type='xs:decimal'>\n    <xs:restriction base='xs:decimal'>\n        <xs:minInclusive value='0.01'/>\n        <xs:fractionDigits value='2'/>\n    </xs:restriction>\n</xs:element>\n```\n\n**Warum diese Definition optimal ist:**\n- ğŸ’° **xs:decimal:** Exakte Dezimalzahlen ohne Rundungsfehler (im Gegensatz zu float)\n- âœ… **minInclusive='0.01':** Verhindert Null- oder Negativpreise\n- ğŸ¯ **fractionDigits='2':** Exakt 2 Nachkommastellen (Cent-Genauigkeit)\n- ğŸ›¡ï¸ **Business-Rule-Compliance:** Entspricht realen Preisanforderungen\n\n**Probleme anderer Optionen:**\n- A: String = keine numerische Validierung\n- C: Integer = keine Nachkommastellen mÃ¶glich\n- D: Float = Rundungsfehler + Pattern ist komplexer als nÃ¶tig ğŸ’¸",
            "difficulty": "experte",
            "category": "XML-Schema-Design"
        },
        {
            "question": "ğŸ“Š Wahr oder Falsch: CSV ist besser geeignet als XML fÃ¼r die Ãœbertragung relationaler Tabellendaten zwischen Datenbanksystemen.",
            "options": [
                "Wahr - CSV ist einfacher und effizienter",
                "Falsch - XML bietet mehr FlexibilitÃ¤t und Validierung",
                "Wahr - CSV hat weniger Overhead",
                "Falsch - CSV kann keine Beziehungen zwischen Tabellen darstellen"
            ],
            "correct": 3,
            "explain": "**BegrÃ¼ndung:** ğŸ“Š Die Aussage ist **FALSCH** - CSV hat fundamentale Limitierungen fÃ¼r relationale Daten:\n\n**CSV-Limitierungen bei relationalen Daten:** âš ï¸\n- ğŸš« **Keine FremdschlÃ¼ssel-Beziehungen:** Referentielle IntegritÃ¤t nicht darstellbar\n- ğŸ“‹ **Flache Struktur:** Nur eine Tabelle pro Datei\n- ğŸ”— **Keine JOIN-Information:** Beziehungen zwischen Tabellen gehen verloren\n- ğŸ’¾ **Datentyp-Verlust:** Alles wird als Text interpretiert\n- âŒ **Keine Constraints:** Keine Validierung von GeschÃ¤ftsregeln\n\n**XML-Vorteile fÃ¼r relationale Daten:**\n- ğŸŒ³ **Hierarchische Darstellung:** Parent-Child-Beziehungen mÃ¶glich\n- ğŸ” **Schema-Validierung:** XSD gewÃ¤hrleistet DatenintegritÃ¤t\n- ğŸ·ï¸ **Metadaten:** FremdschlÃ¼ssel als Attribute darstellbar\n- ğŸ¯ **Referentielle IntegritÃ¤t:** ID/IDREF-Mechanismen verfÃ¼gbar\n\n**Fazit:** FÃ¼r einfache, flache Tabellen ist CSV effizienter. FÃ¼r relationale Datenstrukturen mit Beziehungen ist XML die bessere Wahl! ğŸ›ï¸",
            "difficulty": "fortgeschritten",
            "category": "Format-Vergleich"
        },
        {
            "question": "ğŸµ Analysieren Sie dieses XML-Fragment: <album><song nr='1'/><song nr='1'/></album>. Welches Problem kÃ¶nnte in einer Musik-Datenbank auftreten?",
            "options": [
                "Die XML-Syntax ist fehlerhaft",
                "Doppelte Track-Nummern verletzen die Eindeutigkeit der Songpositionen",
                "Das album-Element benÃ¶tigt ein Attribut",
                "Die song-Elemente sind leer und daher ungÃ¼ltig"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸµ Doppelte Track-Nummern sind ein Business-Logic-Problem:\n\n**Warum doppelte Track-Nummern problematisch sind:**\n- ğŸ¯ **Eindeutigkeit:** Track-Nummer sollte Position im Album identifizieren\n- ğŸ” **Sortierprobleme:** Welcher Song ist wirklich \"Track 1\"?\n- ğŸ’¾ **Datenbank-Constraints:** Unique-Constraints wÃ¼rden verletzt\n- ğŸ§ **User Experience:** Playlist-Generierung wird mehrdeutig\n- ğŸ“Š **Reporting:** Verkaufsstatistiken pro Track werden verfÃ¤lscht\n\n**Bessere LÃ¶sung:**\n```xml\n<album id='ALB001'>\n    <song nr='1' id='S001'><title>Opening Song</title></song>\n    <song nr='2' id='S002'><title>Second Track</title></song>\n</album>\n```\n\n**XML-Schema-Validierung:**\n```xml\n<xs:unique name='unique-track-nr'>\n    <xs:selector xpath='song'/>\n    <xs:field xpath='@nr'/>\n</xs:unique>\n```\n\n**Andere Optionen sind falsch:**\n- A: Syntax ist korrekt (wohlgeformt)\n- C: Album-Attribute sind optional\n- D: Leere Elemente sind syntaktisch gÃ¼ltig ğŸ¼",
            "difficulty": "fortgeschritten",
            "category": "DatenintegritÃ¤t"
        },
        {
            "question": "âš™ï¸ Ein Content Management System importiert tÃ¤glich XML-Feeds von 50 verschiedenen Lieferanten. Jeder Lieferant verwendet ein anderes XML-Schema. Welche Architektur-Strategie ist optimal?",
            "options": [
                "FÃ¼r jeden Lieferanten einen eigenen XML-Parser entwickeln",
                "XSLT-Transformationen verwenden, um alle Formate in ein einheitliches Schema zu konvertieren",
                "Alle Lieferanten zwingen, dasselbe XML-Format zu verwenden",
                "Die XML-Daten direkt ohne Transformation in die Datenbank importieren"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** âš™ï¸ XSLT (eXtensible Stylesheet Language Transformations) ist die Standard-LÃ¶sung fÃ¼r XML-Format-Integration:\n\n**Vorteile der XSLT-basierten Architektur:**\n- ğŸ”„ **Format-Normalisierung:** Alle Eingabeformate â†’ Ein einheitliches Zielschema\n- ğŸ› ï¸ **Wartbarkeit:** Neue Lieferanten = Neue XSLT-Stylesheet hinzufÃ¼gen\n- âš¡ **Performance:** XSLT-Prozessoren sind hochoptimiert\n- ğŸ¯ **Skalierbarkeit:** Parallel processing verschiedener Transformationen\n- ğŸ“‹ **StandardkonformitÃ¤t:** W3C-Standard mit breiter Tool-UnterstÃ¼tzung\n\n**Typische ETL-Pipeline:**\n1. **Extract:** XML-Feeds von Lieferanten laden ğŸ“¥\n2. **Transform:** Lieferanten-spezifische XSLT anwenden ğŸ”„\n3. **Load:** Einheitliche XML-Struktur in Datenbank importieren ğŸ’¾\n\n**Warum andere AnsÃ¤tze problematisch sind:**\n- A: 50 Parser = 50Ã— Entwicklungs-/Wartungsaufwand\n- C: Lieferanten-Lock-in, verhandlungstechnisch unrealistisch\n- D: Schema-Chaos in der Datenbank, keine DatenqualitÃ¤t ğŸ›ï¸\n\n**Tool-Beispiele:** Saxon, Xalan, oder integrierte XSLT-Engines in Java/.NET ğŸ”§",
            "difficulty": "experte",
            "category": "Enterprise-Integration"
        },
        {
            "question": "ğŸ” Eine XML-Datei enthÃ¤lt sensible Kundendaten und soll validiert werden. Welche Kombination gewÃ¤hrleistet sowohl DatenintegritÃ¤t als auch Sicherheit?",
            "options": [
                "DTD-Validierung mit Klartextspeicherung",
                "XSD-Validierung mit XML-VerschlÃ¼sselung nach W3C XML Encryption Standard",
                "Keine Validierung, aber starke VerschlÃ¼sselung",
                "CSV-Export mit Passwort-Schutz"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸ” Moderne XML-Security erfordert sowohl Struktur-Validierung als auch Datenschutz:\n\n**Warum XSD + XML Encryption optimal ist:**\n- âœ… **XSD-Validierung:** Strukturelle IntegritÃ¤t und Business-Rule-Compliance\n- ğŸ›¡ï¸ **W3C XML Encryption:** Industriestandard fÃ¼r selektive VerschlÃ¼sselung\n- ğŸ¯ **Selektive VerschlÃ¼sselung:** Nur sensible Elemente verschlÃ¼sselt, Metadaten bleiben suchbar\n- ğŸ” **Validierung vor VerschlÃ¼sselung:** Schema-Check auf Plaintext, dann VerschlÃ¼sselung\n- ğŸ”— **Tool-Integration:** Enterprise-XML-Tools unterstÃ¼tzen beide Standards nativ\n\n**XML Encryption Beispiel:**\n```xml\n<customer id='C001'>\n    <name>John Doe</name>\n    <EncryptedData xmlns='http://www.w3.org/2001/04/xmlenc#'>\n        <!-- VerschlÃ¼sselte Kreditkartendaten -->\n    </EncryptedData>\n</customer>\n```\n\n**Probleme anderer AnsÃ¤tze:**\n- A: DTD ist weniger mÃ¤chtig als XSD, keine VerschlÃ¼sselung\n- C: Struktur-Chaos ohne Validierung\n- D: CSV verliert XML-Vorteile, Passwort-Schutz ist schwÃ¤cher ğŸ”’",
            "difficulty": "experte",
            "category": "XML-Security"
        },
        {
            "question": "ğŸš€ Ein E-Commerce-API soll sowohl XML- als auch JSON-Responses unterstÃ¼tzen. Die Datenbank verwendet relationale Tabellen. Welche Middleware-Architektur ist optimal?",
            "options": [
                "Separate APIs fÃ¼r XML und JSON mit redundanter GeschÃ¤ftslogik",
                "Einheitliche GeschÃ¤ftslogik mit Content-Negotiation und Format-spezifischen Serializers",
                "Nur XML-API implementieren und client-seitig nach JSON konvertieren",
                "Alle Daten als XML in der Datenbank speichern"
            ],
            "correct": 1,
            "explain": "**BegrÃ¼ndung:** ğŸš€ Content-Negotiation mit einheitlicher GeschÃ¤ftslogik folgt REST-Best-Practices:\n\n**Optimale API-Architektur:**\n```\n[Client] â†’ [API Gateway] â†’ [Business Logic] â†’ [Database]\n    â†“            â†“               â†‘\n[Accept: application/xml] â†’ [XML Serializer]\n[Accept: application/json] â†’ [JSON Serializer]\n```\n\n**Architektur-Vorteile:**\n- ğŸ¯ **DRY-Prinzip:** Eine GeschÃ¤ftslogik fÃ¼r beide Formate\n- ğŸ”„ **Content Negotiation:** HTTP Accept-Header bestimmt Response-Format\n- âš¡ **Performance:** Datenbank-Queries nur einmal ausfÃ¼hren\n- ğŸ› ï¸ **Wartbarkeit:** Neue Formate (YAML, etc.) leicht hinzufÃ¼gbar\n- ğŸ“Š **Consistent Data:** Identische GeschÃ¤ftsregeln fÃ¼r alle Clients\n\n**HTTP Content-Negotiation:**\n```http\nGET /api/products/123\nAccept: application/xml â†’ XML Response\nAccept: application/json â†’ JSON Response\n```\n\n**Warum andere AnsÃ¤tze problematisch:**\n- A: Code-Duplikation, Inkonsistenz-Risiko\n- C: Client-Overhead, Netzwerk-Ineffizienz\n- D: SQL-Performance-Probleme, JSON ist fÃ¼r relationale Daten oft effizienter ğŸ›ï¸",
            "difficulty": "experte",
            "category": "API-Design"
        }
    ]
}